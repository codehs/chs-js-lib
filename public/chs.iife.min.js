var CHSJS = (() => {
    var Nh = Object.create;
    var Dr = Object.defineProperty;
    var Oh = Object.getOwnPropertyDescriptor;
    var Dh = Object.getOwnPropertyNames;
    var Eh = Object.getPrototypeOf,
        Mh = Object.prototype.hasOwnProperty;
    var Fh = (r, t, e) =>
        t in r
            ? Dr(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e })
            : (r[t] = e);
    var ci = r => Dr(r, '__esModule', { value: !0 });
    var Ee = (r, t) => () => t || r((t = { exports: {} }).exports, t), t.exports,
        Ih = (r, t) => {
            ci(r);
            for (var e in t) Dr(r, e, { get: t[e], enumerable: !0 });
        },
        Rh = (r, t, e) => {
            if ((t && typeof t == 'object') || typeof t == 'function')
                for (let o of Dh(t))
                    !Mh.call(r, o) &&
                        o !== 'default' &&
                        Dr(r, o, { get: () => t[o], enumerable: !(e = Oh(t, o)) || e.enumerable });
            return r;
        },
        rn = r =>
            Rh(
                ci(
                    Dr(
                        r != null ? Nh(Eh(r)) : {},
                        'default',
                        r && r.__esModule && 'default' in r
                            ? { get: () => r.default, enumerable: !0 }
                            : { value: r, enumerable: !0 }
                    )
                ),
                r
            );
    var ot = (r, t, e) => (Fh(r, typeof t != 'symbol' ? t + '' : t, e), e);
    var Ni = Ee((om, Lr) => {
        function Yh(r) {
            if (Array.isArray(r)) return r;
        }
        Lr.exports = Yh;
        (Lr.exports.default = Lr.exports), (Lr.exports.__esModule = !0);
    });
    var Oi = Ee((rm, Wr) => {
        function Hh(r, t) {
            var e =
                r == null
                    ? null
                    : (typeof Symbol != 'undefined' && r[Symbol.iterator]) || r['@@iterator'];
            if (e != null) {
                var o = [],
                    s = !0,
                    n = !1,
                    i,
                    a;
                try {
                    for (
                        e = e.call(r);
                        !(s = (i = e.next()).done) && (o.push(i.value), !(t && o.length === t));
                        s = !0
                    );
                } catch (c) {
                    (n = !0), (a = c);
                } finally {
                    try {
                        !s && e.return != null && e.return();
                    } finally {
                        if (n) throw a;
                    }
                }
                return o;
            }
        }
        Wr.exports = Hh;
        (Wr.exports.default = Wr.exports), (Wr.exports.__esModule = !0);
    });
    var Di = Ee((sm, Br) => {
        function Xh(r, t) {
            (t == null || t > r.length) && (t = r.length);
            for (var e = 0, o = new Array(t); e < t; e++) o[e] = r[e];
            return o;
        }
        Br.exports = Xh;
        (Br.exports.default = Br.exports), (Br.exports.__esModule = !0);
    });
    var Mi = Ee((nm, jr) => {
        var Ei = Di();
        function Qh(r, t) {
            if (!!r) {
                if (typeof r == 'string') return Ei(r, t);
                var e = Object.prototype.toString.call(r).slice(8, -1);
                if (
                    (e === 'Object' && r.constructor && (e = r.constructor.name),
                    e === 'Map' || e === 'Set')
                )
                    return Array.from(r);
                if (e === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))
                    return Ei(r, t);
            }
        }
        jr.exports = Qh;
        (jr.exports.default = jr.exports), (jr.exports.__esModule = !0);
    });
    var Fi = Ee((im, Gr) => {
        function Zh() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        Gr.exports = Zh;
        (Gr.exports.default = Gr.exports), (Gr.exports.__esModule = !0);
    });
    var Ii = Ee((am, zr) => {
        var $h = Ni(),
            Kh = Oi(),
            Jh = Mi(),
            tp = Fi();
        function ep(r, t) {
            return $h(r) || Kh(r, t) || Jh(r, t) || tp();
        }
        zr.exports = ep;
        (zr.exports.default = zr.exports), (zr.exports.__esModule = !0);
    });
    var Ri = Ee((cm, Ur) => {
        function op(r, t) {
            if (!(r instanceof t)) throw new TypeError('Cannot call a class as a function');
        }
        Ur.exports = op;
        (Ur.exports.default = Ur.exports), (Ur.exports.__esModule = !0);
    });
    var qi = Ee((um, Yr) => {
        function Pi(r, t) {
            for (var e = 0; e < t.length; e++) {
                var o = t[e];
                (o.enumerable = o.enumerable || !1),
                    (o.configurable = !0),
                    'value' in o && (o.writable = !0),
                    Object.defineProperty(r, o.key, o);
            }
        }
        function rp(r, t, e) {
            return t && Pi(r.prototype, t), e && Pi(r, e), r;
        }
        Yr.exports = rp;
        (Yr.exports.default = Yr.exports), (Yr.exports.__esModule = !0);
    });
    var _n = Ee((Ts, Vi) => {
        (function (r, t) {
            typeof Ts == 'object' && typeof Vi != 'undefined'
                ? t(Ts, Ii(), Ri(), qi())
                : typeof define == 'function' && define.amd
                ? define(
                      [
                          'exports',
                          '@babel/runtime/helpers/slicedToArray',
                          '@babel/runtime/helpers/classCallCheck',
                          '@babel/runtime/helpers/createClass',
                      ],
                      t
                  )
                : ((r = typeof globalThis != 'undefined' ? globalThis : r || self),
                  t(
                      (r.automationEvents = {}),
                      r._slicedToArray,
                      r._classCallCheck,
                      r._createClass
                  ));
        })(Ts, function (r, t, e, o) {
            'use strict';
            function s(V) {
                return V && typeof V == 'object' && 'default' in V ? V : { default: V };
            }
            var n = s(t),
                i = s(e),
                a = s(o),
                c = function (C, I, A) {
                    return { endTime: I, insertTime: A, type: 'exponentialRampToValue', value: C };
                },
                u = function (C, I, A) {
                    return { endTime: I, insertTime: A, type: 'linearRampToValue', value: C };
                },
                l = function (C, I) {
                    return { startTime: I, type: 'setValue', value: C };
                },
                h = function (C, I, A) {
                    return { duration: A, startTime: I, type: 'setValueCurve', values: C };
                },
                p = function (C, I, A) {
                    var L = A.startTime,
                        U = A.target,
                        J = A.timeConstant;
                    return U + (I - U) * Math.exp((L - C) / J);
                },
                d = function (C) {
                    return C.type === 'exponentialRampToValue';
                },
                f = function (C) {
                    return C.type === 'linearRampToValue';
                },
                m = function (C) {
                    return d(C) || f(C);
                },
                _ = function (C) {
                    return C.type === 'setValue';
                },
                y = function (C) {
                    return C.type === 'setValueCurve';
                },
                w = function V(C, I, A, L) {
                    var U = C[I];
                    return U === void 0
                        ? L
                        : m(U) || _(U)
                        ? U.value
                        : y(U)
                        ? U.values[U.values.length - 1]
                        : p(A, V(C, I - 1, U.startTime, L), U);
                },
                O = function (C, I, A, L, U) {
                    return A === void 0
                        ? [L.insertTime, U]
                        : m(A)
                        ? [A.endTime, A.value]
                        : _(A)
                        ? [A.startTime, A.value]
                        : y(A)
                        ? [A.startTime + A.duration, A.values[A.values.length - 1]]
                        : [A.startTime, w(C, I - 1, A.startTime, U)];
                },
                k = function (C) {
                    return C.type === 'cancelAndHold';
                },
                x = function (C) {
                    return C.type === 'cancelScheduledValues';
                },
                v = function (C) {
                    return k(C) || x(C) ? C.cancelTime : d(C) || f(C) ? C.endTime : C.startTime;
                },
                b = function (C, I, A, L) {
                    var U = L.endTime,
                        J = L.value;
                    return A === J
                        ? J
                        : (0 < A && 0 < J) || (A < 0 && J < 0)
                        ? A * Math.pow(J / A, (C - I) / (U - I))
                        : 0;
                },
                T = function (C, I, A, L) {
                    var U = L.endTime,
                        J = L.value;
                    return A + ((C - I) / (U - I)) * (J - A);
                },
                F = function (C, I) {
                    var A = Math.floor(I),
                        L = Math.ceil(I);
                    return A === L ? C[A] : (1 - (I - A)) * C[A] + (1 - (L - I)) * C[L];
                },
                E = function (C, I) {
                    var A = I.duration,
                        L = I.startTime,
                        U = I.values,
                        J = ((C - L) / A) * (U.length - 1);
                    return F(U, J);
                },
                D = function (C) {
                    return C.type === 'setTarget';
                },
                N = (function (V) {
                    function C(I) {
                        i.default(this, C),
                            (this._automationEvents = []),
                            (this._currenTime = 0),
                            (this._defaultValue = I);
                    }
                    return (
                        a.default(C, [
                            {
                                key: V,
                                value: function () {
                                    return this._automationEvents[Symbol.iterator]();
                                },
                            },
                            {
                                key: 'add',
                                value: function (A) {
                                    var L = v(A);
                                    if (k(A) || x(A)) {
                                        var U = this._automationEvents.findIndex(function (De) {
                                                return x(A) && y(De)
                                                    ? De.startTime + De.duration >= L
                                                    : v(De) >= L;
                                            }),
                                            J = this._automationEvents[U];
                                        if (
                                            (U !== -1 &&
                                                (this._automationEvents =
                                                    this._automationEvents.slice(0, U)),
                                            k(A))
                                        ) {
                                            var R =
                                                this._automationEvents[
                                                    this._automationEvents.length - 1
                                                ];
                                            if (J !== void 0 && m(J)) {
                                                if (D(R))
                                                    throw new Error(
                                                        'The internal list is malformed.'
                                                    );
                                                var lt = y(R) ? R.startTime + R.duration : v(R),
                                                    At = y(R)
                                                        ? R.values[R.values.length - 1]
                                                        : R.value,
                                                    H = d(J) ? b(L, lt, At, J) : T(L, lt, At, J),
                                                    _e = d(J)
                                                        ? c(H, L, this._currenTime)
                                                        : u(H, L, this._currenTime);
                                                this._automationEvents.push(_e);
                                            }
                                            R !== void 0 &&
                                                D(R) &&
                                                this._automationEvents.push(l(this.getValue(L), L)),
                                                R !== void 0 &&
                                                    y(R) &&
                                                    R.startTime + R.duration > L &&
                                                    (this._automationEvents[
                                                        this._automationEvents.length - 1
                                                    ] = h(
                                                        new Float32Array([6, 7]),
                                                        R.startTime,
                                                        L - R.startTime
                                                    ));
                                        }
                                    } else {
                                        var $t = this._automationEvents.findIndex(function (De) {
                                                return v(De) > L;
                                            }),
                                            oe =
                                                $t === -1
                                                    ? this._automationEvents[
                                                          this._automationEvents.length - 1
                                                      ]
                                                    : this._automationEvents[$t - 1];
                                        if (oe !== void 0 && y(oe) && v(oe) + oe.duration > L)
                                            return !1;
                                        var xe = d(A)
                                            ? c(A.value, A.endTime, this._currenTime)
                                            : f(A)
                                            ? u(A.value, L, this._currenTime)
                                            : A;
                                        if ($t === -1) this._automationEvents.push(xe);
                                        else {
                                            if (
                                                y(A) &&
                                                L + A.duration > v(this._automationEvents[$t])
                                            )
                                                return !1;
                                            this._automationEvents.splice($t, 0, xe);
                                        }
                                    }
                                    return !0;
                                },
                            },
                            {
                                key: 'flush',
                                value: function (A) {
                                    var L = this._automationEvents.findIndex(function (R) {
                                        return v(R) > A;
                                    });
                                    if (L > 1) {
                                        var U = this._automationEvents.slice(L - 1),
                                            J = U[0];
                                        D(J) &&
                                            U.unshift(
                                                l(
                                                    w(
                                                        this._automationEvents,
                                                        L - 2,
                                                        J.startTime,
                                                        this._defaultValue
                                                    ),
                                                    J.startTime
                                                )
                                            ),
                                            (this._automationEvents = U);
                                    }
                                },
                            },
                            {
                                key: 'getValue',
                                value: function (A) {
                                    if (this._automationEvents.length === 0)
                                        return this._defaultValue;
                                    var L = this._automationEvents.findIndex(function (en) {
                                            return v(en) > A;
                                        }),
                                        U = this._automationEvents[L],
                                        J = (L === -1 ? this._automationEvents.length : L) - 1,
                                        R = this._automationEvents[J];
                                    if (
                                        R !== void 0 &&
                                        D(R) &&
                                        (U === void 0 || !m(U) || U.insertTime > A)
                                    )
                                        return p(
                                            A,
                                            w(
                                                this._automationEvents,
                                                J - 1,
                                                R.startTime,
                                                this._defaultValue
                                            ),
                                            R
                                        );
                                    if (R !== void 0 && _(R) && (U === void 0 || !m(U)))
                                        return R.value;
                                    if (
                                        R !== void 0 &&
                                        y(R) &&
                                        (U === void 0 || !m(U) || R.startTime + R.duration > A)
                                    )
                                        return A < R.startTime + R.duration
                                            ? E(A, R)
                                            : R.values[R.values.length - 1];
                                    if (R !== void 0 && m(R) && (U === void 0 || !m(U)))
                                        return R.value;
                                    if (U !== void 0 && d(U)) {
                                        var lt = O(
                                                this._automationEvents,
                                                J,
                                                R,
                                                U,
                                                this._defaultValue
                                            ),
                                            At = n.default(lt, 2),
                                            H = At[0],
                                            _e = At[1];
                                        return b(A, H, _e, U);
                                    }
                                    if (U !== void 0 && f(U)) {
                                        var $t = O(
                                                this._automationEvents,
                                                J,
                                                R,
                                                U,
                                                this._defaultValue
                                            ),
                                            oe = n.default($t, 2),
                                            xe = oe[0],
                                            De = oe[1];
                                        return T(A, xe, De, U);
                                    }
                                    return this._defaultValue;
                                },
                            },
                        ]),
                        C
                    );
                })(Symbol.iterator),
                W = function (C) {
                    return { cancelTime: C, type: 'cancelAndHold' };
                },
                q = function (C) {
                    return { cancelTime: C, type: 'cancelScheduledValues' };
                },
                Z = function (C, I) {
                    return { endTime: I, type: 'exponentialRampToValue', value: C };
                },
                G = function (C, I) {
                    return { endTime: I, type: 'linearRampToValue', value: C };
                },
                Y = function (C, I, A) {
                    return { startTime: I, target: C, timeConstant: A, type: 'setTarget' };
                };
            (r.AutomationEventList = N),
                (r.createCancelAndHoldAutomationEvent = W),
                (r.createCancelScheduledValuesAutomationEvent = q),
                (r.createExponentialRampToValueAutomationEvent = Z),
                (r.createLinearRampToValueAutomationEvent = G),
                (r.createSetTargetAutomationEvent = Y),
                (r.createSetValueAutomationEvent = l),
                (r.createSetValueCurveAutomationEvent = h),
                Object.defineProperty(r, '__esModule', { value: !0 });
        });
    });
    var th = Ee((yG, zs) => {
        var Il,
            Rl,
            Pl,
            ql,
            Vl,
            Ll,
            Wl,
            Bl,
            jl,
            js,
            Xn,
            Gl,
            zl,
            Ul,
            hr,
            Yl,
            Hl,
            Xl,
            Ql,
            Zl,
            $l,
            Kl,
            Jl,
            Gs;
        (function (r) {
            var t =
                typeof global == 'object'
                    ? global
                    : typeof self == 'object'
                    ? self
                    : typeof this == 'object'
                    ? this
                    : {};
            typeof define == 'function' && define.amd
                ? define('tslib', ['exports'], function (o) {
                      r(e(t, e(o)));
                  })
                : typeof zs == 'object' && typeof zs.exports == 'object'
                ? r(e(t, e(zs.exports)))
                : r(e(t));
            function e(o, s) {
                return (
                    o !== t &&
                        (typeof Object.create == 'function'
                            ? Object.defineProperty(o, '__esModule', { value: !0 })
                            : (o.__esModule = !0)),
                    function (n, i) {
                        return (o[n] = s ? s(n, i) : i);
                    }
                );
            }
        })(function (r) {
            var t =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                    function (o, s) {
                        o.__proto__ = s;
                    }) ||
                function (o, s) {
                    for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (o[n] = s[n]);
                };
            (Il = function (o, s) {
                if (typeof s != 'function' && s !== null)
                    throw new TypeError(
                        'Class extends value ' + String(s) + ' is not a constructor or null'
                    );
                t(o, s);
                function n() {
                    this.constructor = o;
                }
                o.prototype =
                    s === null ? Object.create(s) : ((n.prototype = s.prototype), new n());
            }),
                (Rl =
                    Object.assign ||
                    function (o) {
                        for (var s, n = 1, i = arguments.length; n < i; n++) {
                            s = arguments[n];
                            for (var a in s)
                                Object.prototype.hasOwnProperty.call(s, a) && (o[a] = s[a]);
                        }
                        return o;
                    }),
                (Pl = function (o, s) {
                    var n = {};
                    for (var i in o)
                        Object.prototype.hasOwnProperty.call(o, i) &&
                            s.indexOf(i) < 0 &&
                            (n[i] = o[i]);
                    if (o != null && typeof Object.getOwnPropertySymbols == 'function')
                        for (var a = 0, i = Object.getOwnPropertySymbols(o); a < i.length; a++)
                            s.indexOf(i[a]) < 0 &&
                                Object.prototype.propertyIsEnumerable.call(o, i[a]) &&
                                (n[i[a]] = o[i[a]]);
                    return n;
                }),
                (ql = function (o, s, n, i) {
                    var a = arguments.length,
                        c =
                            a < 3
                                ? s
                                : i === null
                                ? (i = Object.getOwnPropertyDescriptor(s, n))
                                : i,
                        u;
                    if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
                        c = Reflect.decorate(o, s, n, i);
                    else
                        for (var l = o.length - 1; l >= 0; l--)
                            (u = o[l]) && (c = (a < 3 ? u(c) : a > 3 ? u(s, n, c) : u(s, n)) || c);
                    return a > 3 && c && Object.defineProperty(s, n, c), c;
                }),
                (Vl = function (o, s) {
                    return function (n, i) {
                        s(n, i, o);
                    };
                }),
                (Ll = function (o, s) {
                    if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
                        return Reflect.metadata(o, s);
                }),
                (Wl = function (o, s, n, i) {
                    function a(c) {
                        return c instanceof n
                            ? c
                            : new n(function (u) {
                                  u(c);
                              });
                    }
                    return new (n || (n = Promise))(function (c, u) {
                        function l(d) {
                            try {
                                p(i.next(d));
                            } catch (f) {
                                u(f);
                            }
                        }
                        function h(d) {
                            try {
                                p(i.throw(d));
                            } catch (f) {
                                u(f);
                            }
                        }
                        function p(d) {
                            d.done ? c(d.value) : a(d.value).then(l, h);
                        }
                        p((i = i.apply(o, s || [])).next());
                    });
                }),
                (Bl = function (o, s) {
                    var n = {
                            label: 0,
                            sent: function () {
                                if (c[0] & 1) throw c[1];
                                return c[1];
                            },
                            trys: [],
                            ops: [],
                        },
                        i,
                        a,
                        c,
                        u;
                    return (
                        (u = { next: l(0), throw: l(1), return: l(2) }),
                        typeof Symbol == 'function' &&
                            (u[Symbol.iterator] = function () {
                                return this;
                            }),
                        u
                    );
                    function l(p) {
                        return function (d) {
                            return h([p, d]);
                        };
                    }
                    function h(p) {
                        if (i) throw new TypeError('Generator is already executing.');
                        for (; n; )
                            try {
                                if (
                                    ((i = 1),
                                    a &&
                                        (c =
                                            p[0] & 2
                                                ? a.return
                                                : p[0]
                                                ? a.throw || ((c = a.return) && c.call(a), 0)
                                                : a.next) &&
                                        !(c = c.call(a, p[1])).done)
                                )
                                    return c;
                                switch (((a = 0), c && (p = [p[0] & 2, c.value]), p[0])) {
                                    case 0:
                                    case 1:
                                        c = p;
                                        break;
                                    case 4:
                                        return n.label++, { value: p[1], done: !1 };
                                    case 5:
                                        n.label++, (a = p[1]), (p = [0]);
                                        continue;
                                    case 7:
                                        (p = n.ops.pop()), n.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            ((c = n.trys),
                                            !(c = c.length > 0 && c[c.length - 1]) &&
                                                (p[0] === 6 || p[0] === 2))
                                        ) {
                                            n = 0;
                                            continue;
                                        }
                                        if (p[0] === 3 && (!c || (p[1] > c[0] && p[1] < c[3]))) {
                                            n.label = p[1];
                                            break;
                                        }
                                        if (p[0] === 6 && n.label < c[1]) {
                                            (n.label = c[1]), (c = p);
                                            break;
                                        }
                                        if (c && n.label < c[2]) {
                                            (n.label = c[2]), n.ops.push(p);
                                            break;
                                        }
                                        c[2] && n.ops.pop(), n.trys.pop();
                                        continue;
                                }
                                p = s.call(o, n);
                            } catch (d) {
                                (p = [6, d]), (a = 0);
                            } finally {
                                i = c = 0;
                            }
                        if (p[0] & 5) throw p[1];
                        return { value: p[0] ? p[1] : void 0, done: !0 };
                    }
                }),
                (jl = function (o, s) {
                    for (var n in o)
                        n !== 'default' &&
                            !Object.prototype.hasOwnProperty.call(s, n) &&
                            Gs(s, o, n);
                }),
                (Gs = Object.create
                    ? function (o, s, n, i) {
                          i === void 0 && (i = n),
                              Object.defineProperty(o, i, {
                                  enumerable: !0,
                                  get: function () {
                                      return s[n];
                                  },
                              });
                      }
                    : function (o, s, n, i) {
                          i === void 0 && (i = n), (o[i] = s[n]);
                      }),
                (js = function (o) {
                    var s = typeof Symbol == 'function' && Symbol.iterator,
                        n = s && o[s],
                        i = 0;
                    if (n) return n.call(o);
                    if (o && typeof o.length == 'number')
                        return {
                            next: function () {
                                return (
                                    o && i >= o.length && (o = void 0),
                                    { value: o && o[i++], done: !o }
                                );
                            },
                        };
                    throw new TypeError(
                        s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.'
                    );
                }),
                (Xn = function (o, s) {
                    var n = typeof Symbol == 'function' && o[Symbol.iterator];
                    if (!n) return o;
                    var i = n.call(o),
                        a,
                        c = [],
                        u;
                    try {
                        for (; (s === void 0 || s-- > 0) && !(a = i.next()).done; ) c.push(a.value);
                    } catch (l) {
                        u = { error: l };
                    } finally {
                        try {
                            a && !a.done && (n = i.return) && n.call(i);
                        } finally {
                            if (u) throw u.error;
                        }
                    }
                    return c;
                }),
                (Gl = function () {
                    for (var o = [], s = 0; s < arguments.length; s++)
                        o = o.concat(Xn(arguments[s]));
                    return o;
                }),
                (zl = function () {
                    for (var o = 0, s = 0, n = arguments.length; s < n; s++)
                        o += arguments[s].length;
                    for (var i = Array(o), a = 0, s = 0; s < n; s++)
                        for (var c = arguments[s], u = 0, l = c.length; u < l; u++, a++)
                            i[a] = c[u];
                    return i;
                }),
                (Ul = function (o, s, n) {
                    if (n || arguments.length === 2)
                        for (var i = 0, a = s.length, c; i < a; i++)
                            (c || !(i in s)) &&
                                (c || (c = Array.prototype.slice.call(s, 0, i)), (c[i] = s[i]));
                    return o.concat(c || Array.prototype.slice.call(s));
                }),
                (hr = function (o) {
                    return this instanceof hr ? ((this.v = o), this) : new hr(o);
                }),
                (Yl = function (o, s, n) {
                    if (!Symbol.asyncIterator)
                        throw new TypeError('Symbol.asyncIterator is not defined.');
                    var i = n.apply(o, s || []),
                        a,
                        c = [];
                    return (
                        (a = {}),
                        u('next'),
                        u('throw'),
                        u('return'),
                        (a[Symbol.asyncIterator] = function () {
                            return this;
                        }),
                        a
                    );
                    function u(m) {
                        i[m] &&
                            (a[m] = function (_) {
                                return new Promise(function (y, w) {
                                    c.push([m, _, y, w]) > 1 || l(m, _);
                                });
                            });
                    }
                    function l(m, _) {
                        try {
                            h(i[m](_));
                        } catch (y) {
                            f(c[0][3], y);
                        }
                    }
                    function h(m) {
                        m.value instanceof hr
                            ? Promise.resolve(m.value.v).then(p, d)
                            : f(c[0][2], m);
                    }
                    function p(m) {
                        l('next', m);
                    }
                    function d(m) {
                        l('throw', m);
                    }
                    function f(m, _) {
                        m(_), c.shift(), c.length && l(c[0][0], c[0][1]);
                    }
                }),
                (Hl = function (o) {
                    var s, n;
                    return (
                        (s = {}),
                        i('next'),
                        i('throw', function (a) {
                            throw a;
                        }),
                        i('return'),
                        (s[Symbol.iterator] = function () {
                            return this;
                        }),
                        s
                    );
                    function i(a, c) {
                        s[a] = o[a]
                            ? function (u) {
                                  return (n = !n)
                                      ? { value: hr(o[a](u)), done: a === 'return' }
                                      : c
                                      ? c(u)
                                      : u;
                              }
                            : c;
                    }
                }),
                (Xl = function (o) {
                    if (!Symbol.asyncIterator)
                        throw new TypeError('Symbol.asyncIterator is not defined.');
                    var s = o[Symbol.asyncIterator],
                        n;
                    return s
                        ? s.call(o)
                        : ((o = typeof js == 'function' ? js(o) : o[Symbol.iterator]()),
                          (n = {}),
                          i('next'),
                          i('throw'),
                          i('return'),
                          (n[Symbol.asyncIterator] = function () {
                              return this;
                          }),
                          n);
                    function i(c) {
                        n[c] =
                            o[c] &&
                            function (u) {
                                return new Promise(function (l, h) {
                                    (u = o[c](u)), a(l, h, u.done, u.value);
                                });
                            };
                    }
                    function a(c, u, l, h) {
                        Promise.resolve(h).then(function (p) {
                            c({ value: p, done: l });
                        }, u);
                    }
                }),
                (Ql = function (o, s) {
                    return (
                        Object.defineProperty
                            ? Object.defineProperty(o, 'raw', { value: s })
                            : (o.raw = s),
                        o
                    );
                });
            var e = Object.create
                ? function (o, s) {
                      Object.defineProperty(o, 'default', { enumerable: !0, value: s });
                  }
                : function (o, s) {
                      o.default = s;
                  };
            (Zl = function (o) {
                if (o && o.__esModule) return o;
                var s = {};
                if (o != null)
                    for (var n in o)
                        n !== 'default' &&
                            Object.prototype.hasOwnProperty.call(o, n) &&
                            Gs(s, o, n);
                return e(s, o), s;
            }),
                ($l = function (o) {
                    return o && o.__esModule ? o : { default: o };
                }),
                (Kl = function (o, s, n, i) {
                    if (n === 'a' && !i)
                        throw new TypeError('Private accessor was defined without a getter');
                    if (typeof s == 'function' ? o !== s || !i : !s.has(o))
                        throw new TypeError(
                            'Cannot read private member from an object whose class did not declare it'
                        );
                    return n === 'm' ? i : n === 'a' ? i.call(o) : i ? i.value : s.get(o);
                }),
                (Jl = function (o, s, n, i, a) {
                    if (i === 'm') throw new TypeError('Private method is not writable');
                    if (i === 'a' && !a)
                        throw new TypeError('Private accessor was defined without a setter');
                    if (typeof s == 'function' ? o !== s || !a : !s.has(o))
                        throw new TypeError(
                            'Cannot write private member to an object whose class did not declare it'
                        );
                    return i === 'a' ? a.call(o, n) : a ? (a.value = n) : s.set(o, n), n;
                }),
                r('__extends', Il),
                r('__assign', Rl),
                r('__rest', Pl),
                r('__decorate', ql),
                r('__param', Vl),
                r('__metadata', Ll),
                r('__awaiter', Wl),
                r('__generator', Bl),
                r('__exportStar', jl),
                r('__createBinding', Gs),
                r('__values', js),
                r('__read', Xn),
                r('__spread', Gl),
                r('__spreadArrays', zl),
                r('__spreadArray', Ul),
                r('__await', hr),
                r('__asyncGenerator', Yl),
                r('__asyncDelegator', Hl),
                r('__asyncValues', Xl),
                r('__makeTemplateObject', Ql),
                r('__importStar', Zl),
                r('__importDefault', $l),
                r('__classPrivateFieldGet', Kl),
                r('__classPrivateFieldSet', Jl);
        });
    });
    var Er = class {
        constructor(t = {}) {
            (this.onPrompt = t.onPrompt ?? window.prompt.bind(window)),
                (this.onPrint = t.onPrint ?? window.console.log.bind(window.console)),
                (this.onClear = t.onClear ?? (() => {}));
        }
        configure(t = {}) {
            (this.onPrompt = t.onPrompt ?? this.onPrompt),
                (this.onPrint = t.onPrint ?? this.onPrint),
                (this.onClear = t.onClear ?? this.onClear);
        }
        readLinePrivate(t, e) {
            let o = this.onPrompt(t);
            return e && this.println(t), o;
        }
        clear() {
            this.onClear();
        }
        print(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to print');
            this.onPrint(t);
        }
        println(t) {
            if (arguments.length === 0) t = '';
            else if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to println');
            this.print(
                t +
                    `
`
            );
        }
        readNumber(t, e, o) {
            let s = 0,
                n = 100,
                i = t,
                a = !1,
                c = 0;
            for (;;) {
                let u = this.readLinePrivate(i, !a);
                if (u === null) return null;
                if (((u = e(u)), !isNaN(u))) return u;
                if (u === null || c > n) return s;
                (i = 'That was not ' + o + '. Please try again. ' + t), (a = !0), c++;
            }
        }
        readLine(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to readLine');
            return this.readLinePrivate(t, !0);
        }
        readBoolean(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to readBoolean');
            return this.readNumber(
                t,
                e =>
                    e === null
                        ? NaN
                        : ((e = e.toLowerCase()),
                          e === 'true' || e === 'yes'
                              ? !0
                              : e === 'false' || e === 'no'
                              ? !1
                              : NaN),
                'a boolean (true/false)'
            );
        }
        readInt(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to readInt');
            return this.readNumber(
                t,
                function (e) {
                    var o = parseInt(e),
                        s = parseFloat(e);
                    return o === s ? o : NaN;
                },
                'an integer'
            );
        }
        readFloat(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to readFloat');
            return this.readNumber(t, parseFloat, 'a float');
        }
    };
    ('use strict');
    var ls = class {
        constructor() {
            this._q = [];
        }
        size() {
            return this._q.length;
        }
        clear() {
            this._q = [];
        }
        enqueue(t) {
            this._q.push(t);
        }
        dequeue() {
            var t = this._q[0];
            return this._q.splice(0, 1), t;
        }
        peek() {
            var t = this._q[0];
            return t;
        }
        hasNext() {
            return this._q.length !== 0;
        }
        isEmpty() {
            return this._q.length === 0;
        }
    };
    var hs = class {
        constructor() {
            this.stack = [];
        }
        size() {
            return this.stack.length;
        }
        clear() {
            this.stack = [];
        }
        push(t) {
            this.stack.push(t);
        }
        pop() {
            var t = this.stack.length,
                e = this.stack[t - 1];
            return this.stack.splice(t - 1, 1), e;
        }
        peek() {
            var t = this.stack.length,
                e = this.stack[t - 1];
            return e;
        }
        hasNext() {
            return this.stack.length !== 0;
        }
        isEmpty() {
            return this.stack.length === 0;
        }
    };
    var yo = class {
            type = 'Thing';
            anchor = { horizontal: 0, vertical: 0 };
            constructor() {
                (this._id = yo.thingID++),
                    (this.alive = !0),
                    (this._x = 0),
                    (this._y = 0),
                    this._height,
                    this._width,
                    (this.color = '#000000'),
                    (this.stroke = '#000000'),
                    (this.lineWidth = 1),
                    (this.filled = !0),
                    (this.hasBorder = !1),
                    (this.focused = !1),
                    (this._rotation = 0),
                    (this._layer = 1),
                    (this._lastCalculatedBoundsID = 0),
                    (this._sortInvalidated = !0),
                    (this._boundsInvalidated = !0),
                    (this._invalidationDependants = []),
                    (this.bounds = null);
            }
            set layer(t) {
                (this._sortInvalidated = !0), (this._layer = t);
            }
            get layer() {
                return this._layer;
            }
            set width(t) {
                (this._width = t), this._invalidateBounds();
            }
            get width() {
                return this._width;
            }
            set height(t) {
                (this._height = t), this._invalidateBounds();
            }
            get height() {
                return this._height;
            }
            set rotation(t) {
                (this._rotation = t), this._invalidateBounds();
            }
            get rotation() {
                return this._rotation;
            }
            getX() {
                return this.x;
            }
            getY() {
                return this.y;
            }
            set x(t) {
                (this._x = t), this._invalidateBounds();
            }
            get x() {
                return this._x;
            }
            set y(t) {
                (this._y = t), this._invalidateBounds();
            }
            get y() {
                return this._y;
            }
            setFilled(t) {
                if (arguments.length !== 1)
                    throw new Error('You should pass exactly 1 argument to `setFilled`.');
                if (typeof t != 'boolean')
                    throw new Error(
                        'Invalid value passed to `setFilled`. Make sure you are passing a boolean value.'
                    );
                this.filled = t;
            }
            isFilled() {
                return this.filled;
            }
            setBorder(t) {
                if (arguments.length !== 1)
                    throw new Error(
                        'You should pass exactly 1 argument to `setBorder(hasBorder)`.'
                    );
                if (typeof t != 'boolean')
                    throw new Error(
                        'Invalid value passed to `setBorder`. Make sure you are passing a boolean value.'
                    );
                this.hasBorder = t;
            }
            hasBorder() {
                return this.hasBorder;
            }
            setOpacity(t) {
                this.opacity = t;
            }
            setPosition(t, e) {
                if (arguments.length !== 2)
                    throw new Error('You should pass exactly 2 arguments to `setPosition(x, y)`.');
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid value for x-coordinate. Make sure you are passing finite numbers to `setPosition(x, y)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                if (typeof e != 'number' || !isFinite(e))
                    throw new TypeError(
                        'Invalid value for y-coordinate. Make sure you are passing finite numbers to `setPosition(x, y)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                (this.x = t), (this.y = e);
            }
            setRotation(t, e) {
                if (arguments.length < 1 || arguments.length > 2)
                    throw new Error(
                        'You should pass 1 or 2 arguments to `setRotation(degrees, angleUnit)`.'
                    );
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid value for degrees. Make sure you are passing finite numbers to `setRotation(degrees, angleUnit)`. Did you perform a calculation on a variable that is not a number?'
                    );
                if ((e || (e = yo.DEGREES), typeof e != 'number' || !isFinite(e)))
                    throw new TypeError(
                        'Invalid value for `angleUnit`. Make sure you are passing finite numbers to `setRotation(degrees, angleUnit)`.'
                    );
                e === yo.DEGREES ? (this._rotation = (t * Math.PI) / 180) : (this._rotation = t);
            }
            rotate(t, e) {
                if (arguments.length < 1 || arguments.length > 2)
                    throw new Error(
                        'You should pass exactly 1 argument to `rotate(degrees, angleUnit)`.'
                    );
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid value for degrees. Make sure you are passing finite numbers to `rotate(degrees, angleUnit)`. Did you perform a calculation on a variable that is not a number?'
                    );
                if ((e || (e = yo.DEGREES), typeof e != 'number' || !isFinite(e)))
                    throw new TypeError(
                        'Invalid value for `angleUnit`. Make sure you are passing finite numbers to `rotate(degrees, angleUnit)`.'
                    );
                e == yo.DEGREES ? (this.rotation += (t * Math.PI) / 180) : (this.rotation += t),
                    this._invalidateBounds();
            }
            setColor(t) {
                if (arguments.length !== 1)
                    throw new Error(
                        'You should pass exactly 1 argument to <span class="code">setColor`'
                    );
                if (t === void 0) throw new TypeError('Invalid color');
                this.color = t;
            }
            getColor() {
                return this.color;
            }
            setBorderColor(t) {
                if (arguments.length !== 1)
                    throw new Error(
                        'You should pass exactly 1 argument to `setBorderColor(color)`.'
                    );
                if (t === void 0) throw new TypeError('Invalid color.');
                (this.stroke = t), (this.hasBorder = !0);
            }
            getBorderColor() {
                return this.stroke;
            }
            setBorderWidth(t) {
                if (arguments.length !== 1)
                    throw new Error(
                        'You should pass exactly 1 argument to `setBorderWidth(width)`.'
                    );
                if (typeof t != 'number' || !isFinite(t))
                    throw new Error(
                        'Invalid value for border width. Make sure you are passing a finite number to `setBorderWidth(width)`.'
                    );
                (this.lineWidth = t), (this.hasBorder = !0);
            }
            getBorderWidth() {
                return this.lineWidth;
            }
            move(t, e) {
                if (arguments.length !== 2)
                    throw new Error('You should pass exactly 2 arguments to `move(dx, dy)`.');
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid number passed for `dx`. Make sure you are passing finite numbers to `move(dx, dy)`.'
                    );
                if (typeof e != 'number' || !isFinite(e))
                    throw new TypeError(
                        'Invalid number passed for `dy`. Make sure you are passing finite numbers to `move(dx, dy)`.'
                    );
                (this.x += t), (this.y += e);
            }
            draw(t, e) {
                t.save(),
                    this.hasBorder &&
                        ((t.strokeStyle = this.stroke.toString()), (t.lineWidth = this.lineWidth)),
                    this.focused && ((t.shadowColor = '#0066ff'), (t.shadowBlur = 20)),
                    this.filled && (t.fillStyle = this.color.toString()),
                    (t.globalAlpha = this.opacity);
                let o = this.width * this.anchor.horizontal,
                    s = this.height * this.anchor.vertical,
                    n = this.x - o,
                    i = this.y - s;
                if (
                    (t.translate(n, i),
                    t.translate(this.width / 2, this.height / 2),
                    t.rotate(this.rotation),
                    t.translate(-this.width / 2, -this.height / 2),
                    e?.(),
                    this.filled && t.fill(),
                    this.hasBorder && t.stroke(),
                    this.debug)
                ) {
                    t.beginPath(),
                        t.arc(o, s, 3, 0, 2 * Math.PI),
                        t.closePath(),
                        (t.fillStyle = 'red'),
                        (t.strokeStyle = 'red'),
                        t.fill();
                    let a = this.getBounds();
                    t.strokeRect(0, 0, a.right - a.left, a.bottom - a.top);
                }
                t.restore();
            }
            focus() {
                this.focused = !0;
            }
            unfocus() {
                this.focused = !1;
            }
            describe() {
                return `A ${this.type} at ${this.x}, ${this.y}. Colored: ${this.color}.`;
            }
            containsPoint(t, e) {
                if (this.rotation) {
                    let o = this.width * this.anchor.horizontal,
                        s = this.height * this.anchor.vertical,
                        n = this.x - o + this.width / 2,
                        i = this.y - s + this.height / 2;
                    [t, e] = Go([t, e], [n, i], -this.rotation);
                }
                return this._containsPoint(t, e);
            }
            setAnchor(t) {
                (this.anchor = t), this._invalidateBounds();
            }
            getAnchor() {
                return this.anchor;
            }
            getBounds() {
                return this._boundsInvalidated && this._updateBounds(), this.bounds;
            }
            _invalidateBounds() {
                (this._boundsInvalidated = !0),
                    this._invalidationDependants.forEach(t => {
                        t._invalidateBounds();
                    });
            }
            _updateBounds() {
                let t = Math.ceil(this.x - this.anchor.horizontal * this.width),
                    e = Math.ceil(this.x + (1 - this.anchor.horizontal) * this.width),
                    o = Math.ceil(this.y - this.anchor.vertical * this.height),
                    s = Math.ceil(this.y + (1 - this.anchor.vertical) * this.height);
                (this.bounds = { left: t, right: e, top: o, bottom: s }),
                    this._lastCalculatedBoundsID++,
                    (this._boundsInvalidated = !1);
            }
        },
        Mr = yo;
    ot(Mr, 'DEGREES', 0), ot(Mr, 'RADIANS', 1), ot(Mr, 'thingID', 0);
    var Go = ([r, t], [e, o], s) => [
            (r - e) * Math.cos(s) - (t - o) * Math.sin(s) + e,
            (r - e) * Math.sin(s) + (t - o) * Math.cos(s) + o,
        ],
        bt = Mr;
    var ps = function (r, t, e, o) {
            return Math.sqrt(Math.pow(r - e, 2) + Math.pow(t - o, 2));
        },
        ui = (r, t, e, o, s) => ((r - t) / (e - t)) * (s - o) + o;
    var Ye = class extends bt {
            type = 'Arc';
            anchor = { vertical: 0.5, horizontal: 0.5 };
            constructor(t, e, o, s) {
                super();
                if (arguments.length !== 4)
                    throw new Error(
                        'You should pass exactly 4 arguments to `new Arc(radius, startAngle, endAngle, angleUnit)`'
                    );
                if (typeof t != 'number' || !isFinite(t) || isNaN(t))
                    throw new TypeError(
                        'Invalid value for `radius`. Make sure you are passing finite numbers to `new Arc(radius, startAngle, endAngle, angleUnit)`'
                    );
                if (typeof e != 'number' || !isFinite(e) || isNaN(e))
                    throw new TypeError(
                        'Invalid value for `startAngle`. Make sure you are passing finite numbers to `new Arc(radius, startAngle, endAngle, angleUnit)`'
                    );
                if (typeof o != 'number' || !isFinite(o) || isNaN(o))
                    throw new TypeError(
                        'Invalid value for `endAngle`. Make sure you are passing finite numbers to `new Arc(radius, startAngle, endAngle, angleUnit)`'
                    );
                if (typeof s != 'number' || !isFinite(s) || isNaN(s) || s > 1 || s < 0)
                    throw new TypeError(
                        'Invalid value for `angleUnit`. Make sure you are passing finite numbers to `new Arc(radius, startAngle, endAngle, angleUnit)`'
                    );
                (this.radius = t),
                    (this.angleUnit = s ?? Ye.RADIANS),
                    (this.counterclockwise = Ye.COUNTER_CLOCKWISE),
                    this.angleUnit == Ye.DEGREES && ((e = Fr(e)), (o = Fr(o))),
                    (this.startAngle = e),
                    (this.endAngle = o);
            }
            get width() {
                return this.radius * 2;
            }
            get height() {
                return this.radius * 2;
            }
            draw(t) {
                super.draw(t, () => {
                    t.translate(this.radius, this.radius),
                        t.beginPath(),
                        t.arc(
                            0,
                            0,
                            this.radius,
                            li(this.startAngle),
                            li(this.endAngle),
                            this.counterclockwise
                        ),
                        t.lineTo(0, 0),
                        t.closePath(),
                        t.translate(-this.radius, -this.radius);
                });
            }
            setStartAngle(t) {
                if (arguments.length !== 1)
                    throw new Error('You should pass exactly 1 argument to `setStartAngle`');
                if (typeof t != 'number' || !isFinite(t))
                    throw new Error(
                        'Invalid value passed to `setStartAngle`. Make sure you are passing a finite number.'
                    );
                this.angleUnit == Ye.DEGREES && (t = Fr(t)), (this.startAngle = t);
            }
            setEndAngle(t) {
                if (arguments.length !== 1)
                    throw new Error('You should pass exactly 1 argument to `setEndAngle`');
                if (typeof t != 'number' || !isFinite(t))
                    throw new Error(
                        'Invalid value passed to `setEndAngle`. Make sure you are passing a finite number.'
                    );
                this.angleUnit == Ye.DEGREES && (t = Fr(t)), (this.endAngle = t);
            }
            getStartAngle() {
                return this.angleUnit == Ye.DEGREES
                    ? Math.round(sn(this.startAngle))
                    : this.startAngle;
            }
            getEndAngle() {
                return this.angleUnit == Ye.DEGREES ? Math.round(sn(this.endAngle)) : this.endAngle;
            }
            setDirection(t) {
                if (arguments.length !== 1)
                    throw new Error('You should pass exactly 1 argument to `setDirection`');
                if (typeof t != 'boolean')
                    throw new Error(
                        'Invalid value passed to `setDirection`. Make sure you are passing a boolean value. `true` for counterclockwise, false for clockwise.'
                    );
                this.counterclockwise = t;
            }
            _containsPoint(t, e) {
                var o = ps(this.x, this.y, t, e);
                if (o > this.radius) return !1;
                let s = t - this.x,
                    n = this.y - e,
                    i = Math.atan(n / s);
                s < 0 ? (i += Math.PI) : n < 0 && (i += 2 * Math.PI);
                var a = i >= this.startAngle && i <= this.endAngle;
                return this.counterclockwise ? a : !a;
            }
        },
        zo = Ye;
    ot(zo, 'COUNTER_CLOCKWISE', !0),
        ot(zo, 'CLOCKWISE', !1),
        ot(zo, 'DEGREES', 0),
        ot(zo, 'RADIANS', 1);
    var li = function (r) {
            return (r = sn(r)), (r = Math.round(r)), (r = (360 - r) % 360), (r = Fr(r)), r;
        },
        Fr = function (r) {
            return (r / 180) * Math.PI;
        },
        sn = function (r) {
            return (r / Math.PI) * 180;
        },
        hi = zo;
    var an = {};
    Ih(an, {
        nextBoolean: () => qh,
        nextColor: () => nn,
        nextFloat: () => Ph,
        nextHex: () => ds,
        nextInt: () => Uo,
        noise: () => Lh,
    });
    var Uo = function (r, t) {
            t === void 0 && ((t = r - 1), (r = 0)), (r = Math.floor(r));
            var e = Math.random();
            return r + Math.floor(e * (t - r + 1));
        },
        Ph = function (r, t) {
            return t === void 0 && ((t = r), (r = 0)), r + (t - r) * Math.random();
        },
        ds = function () {
            var r = Uo(0, 255);
            return r < 16 ? '0' + r.toString(16) : r.toString(16);
        },
        nn = function () {
            var r = ds(),
                t = ds(),
                e = ds();
            return '#' + r + t + e;
        },
        qh = r => (r === void 0 && (r = 0.5), Math.random() < r),
        Ir,
        fs = 4095,
        Vh = (r, t, e) => r * (1 - e) + t * e,
        Lh = r => {
            if (!Ir) {
                Ir = new Array(fs + 1);
                for (let a = 0; a < fs + 1; a++) Ir[a] = Math.random();
            }
            r = Math.abs(r);
            let t = Math.floor(r),
                e = r - t,
                o = e * e * (3 - 2 * e),
                s = t & fs,
                n = (s + 1) & fs;
            return Vh(Ir[s], Ir[n], o);
        };
    var Me = class {
            type = 'Color';
            constructor(t, e, o) {
                (this.r = t), (this.g = e), (this.b = o);
            }
            toString() {
                return Me.createFromRGB(this.r, this.g, this.b);
            }
            static createFromRGB(t, e, o) {
                return Bh(t, e, o);
            }
            static randomRed() {
                var t = Uo(50, 255);
                return Me.createFromRGB(t, 0, 0);
            }
            static randomGreen() {
                var t = Uo(50, 255);
                return Me.createFromRGB(0, t, 0);
            }
            static randomBlue() {
                var t = Uo(50, 255);
                return Me.createFromRGB(0, 0, t);
            }
            static createFromRGBL(t, e, o, s) {
                var n = Me.rgbToHsl(t, e, o);
                s < 0 && (s = 0), s > 1 && (s = 1);
                var i = Me.hslToRgb(n[0], n[1], s);
                return Me.createFromRGB(i[0], i[1], i[2]);
            }
            static rgbToHsl(t, e, o) {
                (t /= 255), (e /= 255), (o /= 255);
                var s = Math.max(t, e, o),
                    n = Math.min(t, e, o),
                    i,
                    a,
                    c = (s + n) / 2;
                if (s == n) i = a = 0;
                else {
                    var u = s - n;
                    switch (((a = c > 0.5 ? u / (2 - s - n) : u / (s + n)), s)) {
                        case t:
                            i = (e - o) / u + (e < o ? 6 : 0);
                            break;
                        case e:
                            i = (o - t) / u + 2;
                            break;
                        case o:
                            i = (t - e) / u + 4;
                            break;
                    }
                    i /= 6;
                }
                return [i, a, c];
            }
            static hslToRgb(t, e, o) {
                var s, n, i;
                if (e === 0) s = n = i = o;
                else {
                    var a = o < 0.5 ? o * (1 + e) : o + e - o * e,
                        c = 2 * o - a;
                    (s = cn(c, a, t + 1 / 3)), (n = cn(c, a, t)), (i = cn(c, a, t - 1 / 3));
                }
                return [s * 255, n * 255, i * 255];
            }
            static average(t, e) {
                function o(f) {
                    return f.toString(16);
                }
                function s(f) {
                    return parseInt(f, 16);
                }
                for (
                    var n = /[\da-z]{2}/gi,
                        i = t.match(n),
                        a = e.match(n),
                        c = '#',
                        u,
                        l,
                        h,
                        p,
                        d = 0;
                    d < i.length;
                    d++
                )
                    (u = s(i[d])),
                        (l = s(a[d])),
                        (h = Math.floor((u + l) >> 1)),
                        (p = o(h)),
                        p.length == 1 && (p = '0' + p),
                        (c += p);
                return c;
            }
            static getColor(t) {
                return Me.constants[t];
            }
        },
        ht = Me;
    ot(ht, 'random', nn),
        ot(ht, 'red', '#FF0000'),
        ot(ht, 'RED', '#FF0000'),
        ot(ht, 'green', '#00FF00'),
        ot(ht, 'GREEN', '#00FF00'),
        ot(ht, 'blue', '#0000FF'),
        ot(ht, 'BLUE', '#0000FF'),
        ot(ht, 'yellow', '#FFFF00'),
        ot(ht, 'YELLOW', '#FFFF00'),
        ot(ht, 'cyan', '#00FFFF'),
        ot(ht, 'CYAN', '#00FFFF'),
        ot(ht, 'orange', '#FFA500'),
        ot(ht, 'ORANGE', '#FFA500'),
        ot(ht, 'white', '#FFFFFF'),
        ot(ht, 'WHITE', '#FFFFFF'),
        ot(ht, 'black', '#000000'),
        ot(ht, 'BLACK', '#000000'),
        ot(ht, 'gray', '#cccccc'),
        ot(ht, 'GRAY', '#cccccc'),
        ot(ht, 'grey', '#cccccc'),
        ot(ht, 'GREY', '#cccccc'),
        ot(ht, 'purple', '#9B30FF'),
        ot(ht, 'PURPLE', '#9B30FF');
    var Wh = (r, t, e) => {
        if (
            ((r = Math.floor(r)),
            (t = Math.floor(t)),
            (e = Math.floor(e)),
            r > 255 || t > 255 || e > 255)
        )
            throw 'Invalid color component';
        return ((r << 16) | (t << 8) | e).toString(16);
    };
    var Bh = (r, t, e) => '#' + ('000000' + Wh(r, t, e)).slice(-6),
        cn = (r, t, e) => (
            e < 0 && (e += 1),
            e > 1 && (e -= 1),
            e < 1 / 6
                ? r + (t - r) * 6 * e
                : e < 1 / 2
                ? t
                : e < 2 / 3
                ? r + (t - r) * (2 / 3 - e) * 6
                : r
        );
    var pi = class extends bt {
            type = 'Circle';
            anchor = { horizontal: 0.5, vertical: 0.5 };
            constructor(t) {
                super();
                if (arguments.length !== 1)
                    throw new Error('You should pass exactly 1 argument to `new Circle(radius)`.');
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'You must pass a finite number to `new Circle(radius)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                (this.radius = Math.max(0, t)), (this.color = ht.black), (this.lineWidth = 3);
            }
            draw(t) {
                super.draw(t, () => {
                    t.translate(this.radius, this.radius),
                        t.beginPath(),
                        t.arc(0, 0, this.radius, 0, Math.PI * 2, !0),
                        t.closePath(),
                        t.translate(-this.radius, -this.radius);
                });
            }
            getRadius() {
                return this.radius;
            }
            get radius() {
                return this._radius;
            }
            getHeight() {
                return this.radius * 2;
            }
            get height() {
                return this.radius * 2;
            }
            getWidth() {
                return this.radius * 2;
            }
            get width() {
                return this.radius * 2;
            }
            setRadius(t) {
                if (arguments.length !== 1)
                    throw new Error('You should pass exactly 1 argument to `setRadius(radius)`.');
                if (typeof t != 'number' || !isFinite(t))
                    throw new Error(
                        'You must pass a finite number to `setRadius(radius)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                this.radius = Math.max(0, t);
            }
            set radius(t) {
                (this._radius = t), super._invalidateBounds();
            }
            _containsPoint(t, e) {
                (t -= this.width * (0.5 - this.anchor.horizontal)),
                    (e -= this.height * (0.5 - this.anchor.vertical));
                var o = this.radius;
                this.hasBorder && (o += this.lineWidth);
                var s = ps(this.x, this.y, t, e);
                return s < o;
            }
        },
        di = pi;
    var ms = 40,
        Yo = class {
            constructor(t = {}) {
                (this.onError = t.onError), (this.timers = {});
            }
            withErrorHandler(t) {
                return (...e) => {
                    try {
                        t?.(...e);
                    } catch (o) {
                        if (typeof this.onError == 'function') this.onError(o);
                        else throw o;
                    }
                };
            }
            setTimer(t, e, o, s) {
                (e = e ?? ms),
                    (s = s ?? t.name),
                    (this.timers[s] = (() => {
                        let n = !0,
                            i = Date.now(),
                            a = () => {
                                if (!n) return;
                                let c = Date.now();
                                c - i > e && (t(o), (i = c)), requestAnimationFrame(a);
                            };
                        return (
                            requestAnimationFrame(a),
                            {
                                stop: () => {
                                    n = !1;
                                },
                            }
                        );
                    })());
            }
            stopTimer(t) {
                let e = typeof t == 'function' ? t.name : t;
                this.timers[e]?.stop(), (this.timers[e] = null);
            }
            stopAllTimers() {
                Object.keys(this.timers).map(t => {
                    console.log(`stopping ${t}`), this.stopTimer(t);
                });
            }
        };
    ('use strict');
    var fi = 150,
        jh = (fi * 3) / 4,
        mi = 'WEBCAM',
        un = class extends bt {
            type = 'WebVideo';
            constructor(t) {
                super();
                if (typeof t != 'string')
                    throw new TypeError(
                        "You must pass a string to `new WebVideo(filename)` that has the video's location."
                    );
                var e = document.createElement('video');
                if (
                    ((this.width = fi),
                    (this.height = jh),
                    (this.isWebCam = t === mi),
                    (this.browserSupportsVideo = !!e.canPlayType),
                    this.browserSupportsVideo)
                ) {
                    if (((this.video = e), !this.isWebCam)) this.video.src = t;
                    else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
                        navigator.mediaDevices
                            .getUserMedia({ video: !0 })
                            .then(o => {
                                (this.video.srcObject = o), this.video.play();
                            })
                            .catch(function (o) {
                                throw new Error('Web camera access was denied: ' + o);
                            });
                    else throw new TypeError('Your browser does not support web camera access');
                    (this.filename = t),
                        (this.video.autoplay = !0),
                        (this.video.loop = !1),
                        (this.video.crossOrigin = 'anonymous');
                }
            }
            draw(t) {
                !this.browserSupportsVideo ||
                    super.draw(t, () => {
                        t.drawImage(this.video, 0, 0, this.width, this.height);
                    });
            }
            _containsPoint(t, e) {
                return this.browserSupportsVideo
                    ? ((t += this.width * this.anchor.horizontal),
                      (e += this.height * this.anchor.vertical),
                      t >= this.x &&
                          t <= this.x + this.width &&
                          e >= this.y &&
                          e <= this.y + this.height)
                    : !1;
            }
            getWidth() {
                return this.width;
            }
            getHeight() {
                return this.height;
            }
            setSize(t, e) {
                (this.width = t), (this.height = e);
            }
            setAutoplay(t) {
                this.browserSupportsVideo && (this.video.autoplay = t);
            }
            setLoop(t) {
                this.browserSupportsVideo && (this.video.loop = t);
            }
            setMuted(t) {
                this.browserSupportsVideo && (this.video.muted = t);
            }
            play() {
                this.browserSupportsVideo && this.video.play();
            }
            pause() {
                this.browserSupportsVideo && this.video.pause();
            }
            stop() {
                this.browserSupportsVideo &&
                    (this.video.pause(),
                    (this.video.currentTime = 0),
                    this.isWebCam &&
                        this.video.srcObject &&
                        this.video.srcObject.getTracks().forEach(function (t) {
                            t.stop();
                        }));
            }
            isPlaying() {
                return this.browserSupportsVideo ? !(this.video.paused || this.video.ended) : !1;
            }
            isMuted() {
                return this.browserSupportsVideo ? this.video.muted : !1;
            }
            onReadyToPlay(t) {
                this.browserSupportsVideo && (this.video.oncanplay = t);
            }
        };
    ot(un, 'WEBCAM', mi);
    var Rr = un;
    var gi = 5,
        ln = 'position: absolute; width: 1px; height: 1px; top: -10px; overflow: hidden;',
        _i = ln + 'display: none;',
        Gh = {},
        zh = 0,
        Pr = [],
        xi = class extends Yo {
            elementPool = [];
            elementPoolSize = 0;
            accessibleDOMElements = [];
            constructor(t = {}) {
                super(t);
                this.resetAllState(),
                    this.setCurrentCanvas(t.canvas),
                    (this.onError = t.onError || void 0),
                    (this.fullscreenMode = !1),
                    (this.fpsInterval = 1e3 / ms),
                    (this.lastDrawTime = Date.now()),
                    (this.userNavigatingWithKeyboard = !1),
                    this.addEventListeners(),
                    (this.shouldUpdate = t.shouldUpdate ?? !0),
                    (Gh[zh++] = this);
            }
            addEventListeners() {
                window.addEventListener(
                    'keydown',
                    e => (
                        Pr.indexOf(e.keyCode) === -1 && Pr.push(e.keyCode),
                        e.key === 'Tab' &&
                            ((this.userNavigatingWithKeyboard = !0),
                            this.showKeyboardNavigationDOMElements()),
                        this.keyDownCallback?.(e),
                        !0
                    )
                ),
                    window.addEventListener('keyup', e => {
                        let o = Pr.indexOf(e.keyCode);
                        o !== -1 && Pr.splice(o, 1), this.keyUpCallback?.(e);
                    });
                let t;
                window.addEventListener('resize', e => {
                    t ||
                        (t = setTimeout(() => {
                            (t = null), this.fullscreenMode && this.setFullscreen?.();
                        }, ms));
                }),
                    window.DeviceOrientationEvent &&
                        window.addEventListener('orientationchange', e => {
                            this.deviceOrientationCallback?.(e);
                        }),
                    window.DeviceMotionEvent &&
                        window.addEventListener('devicemotion', e => {
                            this.deviceMotionCallback?.(e);
                        });
            }
            configure(t = {}) {
                this.onError = t.onError || void 0;
            }
            getElements() {
                return this.elementPool.filter(t => t.alive);
            }
            add(t) {
                (t.alive = !0),
                    (this.elementPool[this.elementPoolSize++] = t),
                    this.createAccessibleDOMElement(t);
            }
            createAccessibleDOMElement(t) {
                let e = document.createElement('button');
                (e.style = this.userNavigatingWithKeyboard ? ln : _i),
                    (e.onfocus = () => {
                        t.focus(),
                            (e.textContent = t.describe?.() ?? 'An unknown graphics element');
                    }),
                    (e.onblur = () => {
                        t.unfocus();
                    }),
                    (e.onkeydown = o => {
                        if (o.code === 'Space' && !o.repeat) {
                            let s = new Event('mousedown');
                            (s.getX = () => t.x), (s.getY = () => t.y), this.mouseDownCallback?.(s);
                        }
                    }),
                    (e.onkeyup = o => {
                        if (o.code === 'Space') {
                            let s = new Event('mouseup');
                            (s.getX = () => t.x), (s.getY = () => t.y), this.mouseUpCallback?.(s);
                        }
                    }),
                    document.body.appendChild(e),
                    this.accessibleDOMElements.push(e);
            }
            exitKeyboardNavigation() {
                (this.userNavigatingWithKeyboard = !1), this.hideKeyboardNavigationDOMElements();
            }
            showKeyboardNavigationDOMElements() {
                this.accessibleDOMElements.forEach(t => (t.style = ln));
            }
            hideKeyboardNavigationDOMElements() {
                this.accessibleDOMElements.forEach(t => (t.style = _i));
            }
            waitForClick() {
                this.clickCount++;
            }
            mouseClickMethod(t) {
                this.clickCallback = this.withErrorHandler(t);
            }
            mouseMoveMethod(t) {
                this.moveCallback = this.withErrorHandler(t);
            }
            mouseDownMethod(t) {
                this.mouseDownCallback = this.withErrorHandler(t);
            }
            mouseUpMethod(t) {
                this.mouseUpCallback = this.withErrorHandler(t);
            }
            mouseDragMethod(t) {
                this.dragCallback = this.withErrorHandler(t);
            }
            keyDownMethod(t) {
                this.keyDownCallback = this.withErrorHandler(t);
            }
            keyUpMethod(t) {
                this.keyUpCallback = this.withErrorHandler(t);
            }
            deviceOrientationMethod(t) {
                this.deviceOrientationCallback = this.withErrorHandler(t);
            }
            deviceMotionMethod(t) {
                this.deviceMotionCallback = this.withErrorHandler(t);
            }
            isKeyPressed(t) {
                return Pr.indexOf(t) !== -1;
            }
            getWidth() {
                let t = this.getCanvas();
                return parseFloat(t.getAttribute('width'));
            }
            getHeight() {
                let t = this.getCanvas();
                return parseFloat(t.getAttribute('height'));
            }
            stopAllTimers() {
                for (let t = 1; t < 99999; t++) window.clearInterval(t);
                super.stopAllTimers(), this.setMainTimer();
            }
            setTimer(t, e, o, s) {
                if (arguments.length < 2)
                    throw new Error(
                        '2 parameters required for `setTimer`, ' +
                            arguments.length +
                            ' found. You must provide a callback function and a number representing the time delay to `setTimer`.'
                    );
                if (typeof t != 'function')
                    throw new TypeError(
                        'Invalid callback function. Make sure you are passing an actual function to `setTimer`.'
                    );
                if (typeof e != 'number' || !isFinite(e))
                    throw new TypeError(
                        'Invalid value for time delay. Make sure you are passing a finite number to `setTimer` for the delay.'
                    );
                this.waitingForClick()
                    ? this.delayedTimers.push({
                          fn: t,
                          time: e,
                          data: o,
                          clicks: this.clickCount,
                          name: s,
                      })
                    : super.setTimer(this.withErrorHandler(t), e, o, s ?? t.name);
            }
            setBackgroundColor(t) {
                this.backgroundColor = t;
            }
            clear(t) {
                var e = t || this.getContext();
                e.clearRect(0, 0, this.getWidth(), this.getHeight());
            }
            getElementAt(t, e) {
                for (let o = this.elementPool.length; o--; )
                    if (this.elementPool[o].alive && this.elementPool[o].containsPoint(t, e))
                        return this.elementPool[o];
                return null;
            }
            getElementsAt(t, e) {
                return this.elementPool.filter(o => o.alive && o.containsPoint(t, e));
            }
            elementExistsWithParameters(t) {
                for (let e = this.elementPool.length; e--; ) {
                    let o = this.elementPool[e],
                        s = Object.entries(t).map(([n, i]) => i === o[n]);
                    if (o.alive && s.every(n => n)) return !0;
                }
                return !1;
            }
            removeAll() {
                this.stopAllVideo(), (this.elementPool = []), (this.elementPoolSize = 0);
            }
            remove(t) {
                t instanceof Rr && t.stop(), (t.alive = !1);
            }
            setSize(t, e) {
                this.fullscreenMode = !1;
                let o = this.getCanvas(),
                    s = document.createElement('canvas');
                (s.width = o.width),
                    (s.height = o.height),
                    s.getContext('2d').drawImage(o, 0, 0),
                    (o.width = t),
                    (o.height = e),
                    (o.style['max-height'] = e),
                    (o.style['max-width'] = t),
                    this.getContext().drawImage(s, 0, 0),
                    s.remove();
            }
            setFullscreen() {
                this.fullscreenMode = !0;
                var t = this.getCanvas();
                (t.width = t.parentElement.offsetWidth - gi),
                    (t.height = t.parentElement.offsetHeight - gi);
            }
            resetAllTimers() {
                for (var t in this.timers) clearInterval(this.timers[t]);
            }
            stopAllVideo() {
                for (var t = this.elementPool.length; t--; )
                    this.elementPool[t] instanceof Rr && this.elementPool[t].stop();
            }
            resetAllState() {
                (this.backgroundColor = null),
                    (this.elementPool = []),
                    this.accessibleDOMElements.forEach(t => t.remove),
                    (this.accessibleDOMElements = []),
                    (this.clickCallback = null),
                    (this.moveCallback = null),
                    (this.mouseDownCallback = null),
                    (this.mouseUpCallback = null),
                    (this.dragCallback = null),
                    (this.keyDownCallback = null),
                    (this.keyUpCallback = null),
                    (this.deviceOrientationCallback = null),
                    (this.deviceMotionCallback = null),
                    (this.timers = {}),
                    (this.timersList = []),
                    (this.clickCount = 0),
                    (this.delayedTimers = []),
                    (this.fullscreenMode = !1);
            }
            fullReset() {
                this.stopAllVideo(),
                    this.resetAllTimers(),
                    this.resetAllState(),
                    this.setMainTimer();
            }
            canvasExists() {
                return this.getCanvas() !== null;
            }
            getCanvas() {
                return this.currentCanvas;
            }
            setCurrentCanvas(t) {
                let e;
                t
                    ? (e = document.querySelector(t))
                    : (e = document.getElementsByTagName('canvas')[0]),
                    e === null &&
                        ((e = document.createElement('canvas')), document.body.appendChild(e)),
                    (this.currentCanvas = e),
                    this.fullReset(),
                    this.setup();
            }
            drawBackground() {
                if (this.backgroundColor) {
                    var t = this.getContext();
                    (t.fillStyle = this.backgroundColor),
                        t.beginPath(),
                        t.rect(0, 0, this.getWidth(), this.getHeight()),
                        t.closePath(),
                        t.fill();
                }
            }
            getContext() {
                return this.getCanvas()?.getContext?.('2d');
            }
            redraw() {
                this.clear(), this.drawBackground();
                let t,
                    e,
                    o = this.getContext(),
                    s = 0;
                for (let n = 0; n < this.elementPoolSize; n++)
                    (t = this.elementPool[n]),
                        t._sortInvalidated && ((e = !0), (t._sortInvalidated = !1)),
                        t.alive ? t.draw(o) : ((e = !0), s++);
                e &&
                    ((this.elementPoolSize -= s),
                    this.elementPool.sort((n, i) => i.alive - n.alive || n.layer - i.layer));
            }
            setMainTimer() {
                (this.shouldUpdate = !0), this.update();
            }
            update() {
                this.shouldUpdate && requestAnimationFrame(this.update.bind(this)),
                    (this.now = Date.now());
                let t = this.now - this.lastDrawTime;
                t > this.fpsInterval &&
                    ((this.lastDrawTime = this.now - (t % this.fpsInterval)), this.redraw());
            }
            waitingForClick() {
                return this.clickCount !== 0;
            }
            canvasHasInstance(t) {
                let e;
                for (let o = 0; o < allGraphicsInstances.length; o++)
                    if (
                        ((e = allGraphicsInstances[o]),
                        e.instanceId !== this.instanceId && e.getCanvas() === t)
                    )
                        return e.instanceId;
                return null;
            }
            setup() {
                var t = this.getCanvas();
                t.onclick = o => {
                    if (this.waitingForClick()) {
                        this.clickCount--;
                        for (var s = 0; s < this.delayedTimers.length; s++) {
                            var n = this.delayedTimers[s];
                            n.clicks--,
                                n.clicks === 0 &&
                                    this.setTimer(this.withErrorHandler(n.fn), n.time, n.data);
                        }
                        return;
                    }
                    this.clickCallback && this.clickCallback(o);
                };
                var e = !1;
                (t.onmousemove = this.withErrorHandler(o => {
                    this.userNavigatingWithKeyboard && this.exitKeyboardNavigation(),
                        this.moveCallback && this.moveCallback(o),
                        e && this.dragCallback && this.dragCallback(o);
                })),
                    (t.onmousedown = o => {
                        this.userNavigatingWithKeyboard && this.exitKeyboardNavigation(),
                            (e = !0),
                            this.mouseDownCallback && this.mouseDownCallback(o);
                    }),
                    (t.onmouseup = o => {
                        this.userNavigatingWithKeyboard && this.exitKeyboardNavigation(),
                            (e = !1),
                            this.mouseUpCallback && this.mouseUpCallback(o);
                    }),
                    (t.ontouchmove = o => {
                        this.userNavigatingWithKeyboard && this.exitKeyboardNavigation(),
                            o.preventDefault(),
                            this.dragCallback
                                ? this.dragCallback(o)
                                : this.moveCallback && this.moveCallback(o);
                    }),
                    (t.ontouchstart = o => {
                        if (
                            (this.userNavigatingWithKeyboard && this.exitKeyboardNavigation(),
                            o.preventDefault(),
                            this.mouseDownCallback
                                ? this.mouseDownCallback(o)
                                : this.clickCallback && this.clickCallback(o),
                            this.waitingForClick())
                        ) {
                            this.clickCount--;
                            for (var s = 0; s < this.delayedTimers.length; s++) {
                                var n = this.delayedTimers[s];
                                n.clicks--, n.clicks === 0 && this.setTimer(n.fn, n.time, n.data);
                            }
                            return;
                        }
                    }),
                    (t.ontouchend = o => {
                        this.userNavigatingWithKeyboard && this.exitKeyboardNavigation(),
                            o.preventDefault(),
                            this.mouseUpCallback && this.mouseUpCallback(o);
                    });
            }
        },
        gs = r => {
            let t = r.target,
                e = t.getBoundingClientRect();
            return {
                x: Math.round(((r.clientX - e.left) * t.width) / t.clientWidth),
                y: Math.round(((r.clientY - e.top) * t.height) / t.clientHeight),
            };
        };
    MouseEvent.prototype.getX = function () {
        return gs(this).x;
    };
    MouseEvent.prototype.getY = function () {
        return gs(this).y;
    };
    TouchEvent.prototype.getX = function () {
        return gs(this.touches[0]).x;
    };
    TouchEvent.prototype.getY = function () {
        return gs(this.touches[0]).y;
    };
    var hn = xi;
    var Ft = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        ENTER: 13,
        SHIFT: 16,
        SPACE: 32,
        BACKSPACE: 8,
        TAB: 9,
        CTRL: 17,
        ALT: 18,
        CAPS_LOCK: 20,
        LEFT_COMMAND: 91,
        LEFT_WINDOW: 91,
        RIGHT_WINDOW: 92,
        RIGHT_COMMAND: 93,
        SELECT: 93,
    };
    Ft.nonEditingKeys = [
        Ft.LEFT,
        Ft.RIGHT,
        Ft.UP,
        Ft.DOWN,
        Ft.CTRL,
        Ft.SHIFT,
        Ft.ALT,
        Ft.CAPS_LOCK,
        Ft.LEFT_COMMAND,
        Ft.RIGHT_COMMAND,
        Ft.SELECT,
        Ft.LEFT_WINDOW,
        Ft.RIGHT_WINDOW,
    ];
    Ft.digit = function (r) {
        return (r = r % 10), r + 48;
    };
    Ft.letter = function (r) {
        return r.length !== 1 ? -1 : r.toUpperCase().charCodeAt(0);
    };
    Ft.isEditingKey = function (r) {
        return Ft.nonEditingKeys.indexOf(r) === -1;
    };
    var yi = Ft;
    var _s = class extends bt {
        type = 'Line';
        constructor(t, e, o, s) {
            super();
            if (arguments.length !== 4)
                throw new Error(
                    'You should pass exactly 4 arguments to `new Line(x1, y1, x2, y2)`.'
                );
            if (
                typeof t != 'number' ||
                typeof e != 'number' ||
                typeof o != 'number' ||
                typeof s != 'number'
            )
                throw new TypeError(
                    'You must pass 4 numbers to `new Line(x1, y1, x2, y2)`. Make sure each parameter you are passing is a number.'
                );
            if (!isFinite(t) || !isFinite(e) || !isFinite(o) || !isFinite(s))
                throw new TypeError(
                    'One or more of the values you passed to `new Line(x1, y1, x2, y2)` is an illegal number. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            (this.x1 = t),
                (this.y1 = e),
                (this.x2 = o),
                (this.y2 = s),
                (this.width = o - t),
                (this.height = s - e),
                (this.lineWidth = 2),
                (this.hasBorder = !0);
        }
        setColor(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to `setColor(color)`.');
            if (t === void 0) throw new TypeError('Invalid color');
            this.stroke = t;
        }
        getColor() {
            return this.stroke;
        }
        draw(t) {
            super.draw(t, () => {
                let e = this.x1,
                    o = this.x2,
                    s = this.y1,
                    n = this.y2,
                    i = (o - e) / 2,
                    a = (n - s) / 2;
                t.beginPath(), t.moveTo(0, 0), t.lineTo(o - e, n - s), t.closePath();
            });
        }
        containsPoint(t, e) {
            let o = (this.x1 <= t && t <= this.x2) || (this.x2 <= t && t <= this.x1),
                s = (this.y1 <= e && e <= this.y2) || (this.y2 <= e && e <= this.y1);
            if (this.x1 == this.x2) return this.x1 == t && s;
            {
                let n = (this.y2 - this.y1) / (this.x2 - this.x1);
                return Math.abs(n * (t - this.x1) - (e - this.y1)) <= this.lineWidth && o && s;
            }
        }
        getWidth() {
            return this.width;
        }
        getHeight() {
            return this.height;
        }
        setLineWidth(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to `setLineWidth`');
            if (typeof t != 'number' || !isFinite(t))
                throw new TypeError(
                    'You must pass a finite number to `setLineWidth(width)`. Did you perform a calculation on a variable that is not a number?'
                );
            this.lineWidth = t;
        }
        setStartpoint(t, e) {
            if (arguments.length !== 2)
                throw new Error('You should pass exactly 2 arguments to `setStartpoint(x, y)`.');
            if (typeof t != 'number' || !isFinite(t))
                throw new TypeError(
                    'Invalid value for x-coordinate. Make sure you are passing finite numbers to `setStartpoint(x, y)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            if (typeof e != 'number' || !isFinite(e))
                throw new TypeError(
                    'Invalid value for y-coordinate. Make sure you are passing finite numbers to `setStartpoint(x, y)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            this.setPosition(t, e);
        }
        setPosition(t, e) {
            if (arguments.length !== 2)
                throw new Error('You should pass exactly 2 arguments to `setPosition(x, y)`.');
            if (typeof t != 'number' || !isFinite(t))
                throw new TypeError(
                    'Invalid value for x-coordinate. Make sure you are passing finite numbers to `setPosition(x, y)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            if (typeof e != 'number' || !isFinite(e))
                throw new TypeError(
                    'Invalid value for y-coordinate. Make sure you are passing finite numbers to `setPosition(x, y)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            (this.x1 = t), (this.y1 = e);
        }
        setEndpoint(t, e) {
            if (arguments.length !== 2)
                throw new Error('You should pass exactly 2 arguments to `setEndpoint(x, y)`.');
            if (typeof t != 'number' || !isFinite(t))
                throw new TypeError(
                    'Invalid value for x-coordinate. Make sure you are passing finite numbers to `setEndpoint(x, y)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            if (typeof e != 'number' || !isFinite(e))
                throw new TypeError(
                    'Invalid value for y-coordinate. Make sure you are passing finite numbers to `setEndpoint(x, y)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            (this.x2 = t), (this.y2 = e);
        }
        move(t, e) {
            if (arguments.length !== 2)
                throw new Error('You should pass exactly 2 arguments to `move(dx, dy)`.');
            if (typeof t != 'number' || !isFinite(t))
                throw new TypeError(
                    'Invalid number passed for `dx`. Make sure you are passing finite numbers to `move(dx, dy)`.'
                );
            if (typeof e != 'number' || !isFinite(e))
                throw new TypeError(
                    'Invalid number passed for `dy`. Make sure you are passing finite numbers to `move(dx, dy)`.'
                );
            (this.x1 += t), (this.y1 += e), (this.x2 += t), (this.y2 += e);
        }
        getX() {
            return this.x1;
        }
        get x() {
            return this.x1;
        }
        getY() {
            return this.y1;
        }
        get y() {
            return this.y1;
        }
        getStartX() {
            return this.x1;
        }
        getStartY() {
            return this.y1;
        }
        getEndX() {
            return this.x2;
        }
        getEndY() {
            return this.y2;
        }
    };
    var xs = class extends bt {
        type = 'Oval';
        anchor = { vertical: 0.5, horizontal: 0.5 };
        constructor(t, e) {
            super();
            if (arguments.length !== 2)
                throw new Error(
                    'You should pass exactly 2 arguments to `new Oval(width, height)`.'
                );
            if (typeof t != 'number' || !isFinite(t))
                throw new TypeError(
                    'Invalid value for `width`. Make sure you are passing finite numbers to `new Oval(width, height)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            if (typeof e != 'number' || !isFinite(e))
                throw new TypeError(
                    'Invalid value for `height`. Make sure you are passing finite numbers to `new Oval(width, height)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            (this.width = Math.max(0, t)), (this.height = Math.max(0, e));
        }
        draw(t) {
            super.draw(t, () => {
                t.translate(this.width / 2, this.height / 2),
                    t.beginPath(),
                    t.ellipse(0, 0, this.width / 2, this.height / 2, 2 * Math.PI, 0, 2 * Math.PI),
                    t.closePath(),
                    t.translate(-this.width / 2, -this.height / 2);
            });
        }
        getHeight() {
            return this.height;
        }
        getWidth() {
            return this.width;
        }
        setWidth(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to `setWidth(width)`.');
            if (typeof t != 'number' || !isFinite(t))
                throw new TypeError(
                    'You must pass a finite number to `setWidth(width)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            this.width = Math.max(0, t);
        }
        setHeight(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to `setHeight(height)`.');
            if (typeof t != 'number' || !isFinite(t))
                throw new TypeError(
                    'You must pass a finite number to `setHeight(height)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                );
            this.height = Math.max(0, t);
        }
        _containsPoint(t, e) {
            (t -= this.width * (0.5 - this.anchor.horizontal)),
                (e -= this.height * (0.5 - this.anchor.vertical));
            var o = Math.pow(this.width / 2, 2),
                s = Math.pow(this.height / 2, 2),
                n = Math.pow(t - this.x, 2),
                i = Math.pow(e - this.y, 2),
                a = n / o + i / s;
            return a <= 1;
        }
    };
    var vi = class extends bt {
            type = 'Polygon';
            constructor() {
                super();
                if (arguments.length !== 0)
                    throw new Error('You should pass exactly 0 arguments to `new Polygon()`');
                (this.points = []), (this.width = 0), (this.height = 0);
            }
            draw(t) {
                this.points.length !== 0 &&
                    super.draw(t, () => {
                        t.save(), t.translate(-this.x, -this.y), t.beginPath();
                        let e = this.points[0],
                            o;
                        t.moveTo(e.x, e.y);
                        for (let s = 1; s < this.points.length; s++)
                            (o = this.points[s]), t.lineTo(o.x, o.y);
                        t.closePath(), t.restore();
                    });
            }
            _containsPoint(t, e) {
                (t += this.width * this.anchor.horizontal),
                    (e += this.height * this.anchor.vertical);
                let o = -1,
                    s,
                    n,
                    i,
                    a;
                for (let c = 0; c < this.points.length; c++) {
                    (s = this.points[c].x),
                        (i = this.points[c].y),
                        (n = this.points[(c + 1) % this.points.length].x),
                        (a = this.points[(c + 1) % this.points.length].y);
                    let u = (e - i) * (n - s) - (t - s) * (a - i) <= 0;
                    if (o < 0) o = u;
                    else if (o !== u) return !1;
                }
                return !0;
            }
            getWidth() {
                return this.width;
            }
            getHeight() {
                return this.height;
            }
            addPoint(t, e) {
                if (arguments.length !== 2)
                    throw new Error('You should pass exactly 2 arguments to `addPoint(x, y)`');
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid value for x-coordinate. Make sure you are passing finite numbers to `addPoint(x, y)`.'
                    );
                if (typeof e != 'number' || !isFinite(e))
                    throw new TypeError(
                        'Invalid value for y-coordinate. Make sure you are passing finite numbers to `addPoint(x, y)`.'
                    );
                this.points.push({ x: t, y: e });
                for (let o = 0; o < this.points.length; o++)
                    Math.abs(t - this.points[o].x) > this.width &&
                        (this.width = Math.abs(t - this.points[o].x)),
                        Math.abs(e - this.points[o].y) > this.height &&
                            (this.height = Math.abs(e - this.points[o].y));
            }
            move(t, e) {
                if (arguments.length !== 2)
                    throw new Error('You should pass exactly 2 arguments to `move(dx, dy).`');
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid number passed for `dx`. Make sure you are passing finite numbers to `move(dx, dy)`.'
                    );
                if (typeof e != 'number' || !isFinite(e))
                    throw new TypeError(
                        'Invalid number passed for `dy`. Make sure you are passing finite numbers to `move(dx, dy)`.'
                    );
                for (let o = 0; o < this.points.length; o++)
                    (this.points[o].x += t), (this.points[o].y += e);
                (this.x += t), (this.y += e);
            }
            setPosition(t, e) {
                let o = t - this.x,
                    s = e - this.y;
                this.move(o, s);
            }
        },
        wi = vi;
    var bi = class extends bt {
            type = 'Rectangle';
            constructor(t, e) {
                super();
                if (arguments.length !== 2)
                    throw new Error(
                        'You should pass exactly 2 arguments to `new Rectangle(width, height)`.'
                    );
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid value for `width`. Make sure you are passing finite numbers to `new Rectangle(width, height)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                if (typeof e != 'number' || !isFinite(e))
                    throw new TypeError(
                        'Invalid value for `height`. Make sure you are passing finite numbers to `new Rectangle(width, height)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                (this.width = Math.max(0, t)), (this.height = Math.max(0, e));
            }
            draw(t) {
                super.draw(t, () => {
                    t.beginPath(), t.rect(0, 0, this.width, this.height), t.closePath();
                });
            }
            setSize(t, e) {
                if (arguments.length !== 2)
                    throw new Error(
                        'You should pass exactly 2 arguments to `setSize(width, height)`.'
                    );
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid value for `width`. Make sure you are passing finite numbers to `setSize(width, height)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                if (typeof e != 'number' || !isFinite(e))
                    throw new TypeError(
                        'Invalid value for `height`. Make sure you are passing finite numbers to `setSize(width, height)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                (this.width = Math.max(0, t)), (this.height = Math.max(0, e));
            }
            setWidth(t) {
                if (arguments.length !== 1)
                    throw new Error('You should pass exactly 1 argument to `setWidth(width)`');
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid value for `width`. Make sure you are passing finite numbers to `setWidth(width)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                this.width = Math.max(0, t);
            }
            setHeight(t) {
                if (arguments.length !== 1)
                    throw new Error('You should pass exactly 1 argument to `setHeight(height)`');
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(
                        'Invalid value for `height`. Make sure you are passing finite numbers to `setHeight(height)`. Did you forget the parentheses in `getWidth()` or `getHeight()`? Or did you perform a calculation on a variable that is not a number?'
                    );
                this.height = Math.max(0, t);
            }
            _containsPoint(t, e) {
                return (
                    (t += this.width * this.anchor.horizontal),
                    (e += this.height * this.anchor.vertical),
                    t >= this.x &&
                        t <= this.x + this.width &&
                        e >= this.y &&
                        e <= this.y + this.height
                );
            }
            getWidth() {
                return this.width;
            }
            getHeight() {
                return this.height;
            }
        },
        Ti = bi;
    var pn = class extends bt {
        type = 'Text';
        anchor = { horizontal: 0, vertical: 1 };
        constructor(t, e = '20pt Arial') {
            super();
            if (arguments.length < 1)
                throw new Error(
                    'You should pass at least one argument to `new Text(label, font)`. `label` is a required parameter.'
                );
            if (typeof t != 'string' && typeof t != 'number')
                throw new TypeError(
                    'Invalid value for `label`. You passed a value of type ' +
                        typeof t +
                        ' but a string or number is required.'
                );
            if (typeof e != 'string')
                throw new TypeError(
                    'Invalid value for `font`. You passed a value of type ' +
                        typeof t +
                        ' but a string is required.'
                );
            (this.label = t), (this.font = e), this.resetDimensions();
        }
        resetDimensions() {
            let e = document.createElement('canvas').getContext('2d');
            (e.font = this.font),
                (this.width = e.measureText(this.label).width),
                (this.height = e.measureText('m').width * 1.2);
        }
        draw(t) {
            this.resetDimensions(),
                super.draw(t, () => {
                    t.translate(0, this.height),
                        t.beginPath(),
                        (t.font = this.font),
                        t.fillText(this.label, 0, 0),
                        t.closePath(),
                        t.translate(0, -this.height);
                });
        }
        describe() {
            return super.describe() + this.label;
        }
        setFont(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to `setFont`');
            if (typeof t != 'string')
                throw new TypeError(
                    'Invalid value passed to `setFont`. You passed a value of type ' +
                        typeof t +
                        ', but a string is required.'
                );
            (this.font = t), this.resetDimensions();
        }
        setLabel(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to `setLabel`');
            if (typeof t != 'string' && typeof t != 'number')
                throw new TypeError(
                    'Invalid value passed to `setLabel`. You passed a value of type ' +
                        typeof t +
                        ', but a string or number is required.'
                );
            this.label = t;
        }
        setText(t) {
            if (arguments.length !== 1)
                throw new Error('You should pass exactly 1 argument to `setText`');
            if (typeof t != 'string' && typeof t != 'number')
                throw new TypeError(
                    'Invalid value passed to `setText`. You passed a value of type ' +
                        typeof t +
                        ', but a string or number is required.'
                );
            this.label = t;
        }
        getLabel() {
            return this.label;
        }
        getText() {
            return this.label;
        }
        getWidth() {
            return this.width;
        }
        getHeight() {
            return this.height;
        }
        _containsPoint(t, e) {
            return (
                (t += this.width * this.anchor.horizontal),
                (e -= this.height * (1 - this.anchor.vertical)),
                t >= this.x && t <= this.x + this.width && e <= this.y && e >= this.y - this.height
            );
        }
    };
    ot(pn, 'defaultContext', null);
    var Ai = pn;
    var ys = -1,
        qr = 0,
        Si = 4,
        dn = 0,
        fn = 1,
        mn = 2,
        gn = 3,
        Ci = class extends bt {
            type = 'WebImage';
            constructor(t) {
                super();
                if (typeof t != 'string')
                    throw new TypeError(
                        `You must pass a string to \`new WebImage(filename)\` that has the image's URL. Received type ${typeof t}`
                    );
                this.setImage(t), (this._hiddenCanvasOutOfSync = !1), (this.imageLoaded = !1);
            }
            loaded(t) {
                this.imageLoaded && t(), (this.loadfn = t);
            }
            setImage(t) {
                if (typeof t != 'string')
                    throw new TypeError(
                        `You must pass a string to \`setImage(filename)\` that has the image's URL. Received type ${typeof t}`
                    );
                (this._hiddenCanvas = document.createElement('canvas')),
                    (this._hiddenCanvas.width = 1),
                    (this._hiddenCanvas.height = 1),
                    (this.image = new Image()),
                    (this.image.crossOrigin = !0),
                    (this.image.src = t),
                    (this.filename = t),
                    (this.width = null),
                    (this.height = null),
                    (this.data = qr),
                    (this.image.onload = () => {
                        (this.imageLoaded = !0),
                            this.checkDimensions(),
                            this.loadPixelData(),
                            this.loadfn && this.loadfn();
                    });
            }
            checkDimensions() {
                (this.width === null || this.height === null) &&
                    ((this.width = this.image.width), (this.height = this.image.height));
            }
            draw(t) {
                this.data !== qr &&
                    (this._hiddenCanvasOutOfSync && this.updateHiddenCanvas(),
                    super.draw(t, () => {
                        t.drawImage(
                            this._hiddenCanvas,
                            0,
                            0,
                            (this.width * this.width) / this.data.width,
                            (this.height * this.height) / this.data.height
                        );
                    }));
            }
            loadPixelData() {
                if (this.data === qr) {
                    (this._hiddenCanvas.width = this.width),
                        (this._hiddenCanvas.height = this.height);
                    let t = this._hiddenCanvas.getContext('2d');
                    t.drawImage(this.image, 0, 0, this.width, this.height),
                        (this.data = t.getImageData(0, 0, this.width, this.height)),
                        (this._hiddenCanvasOutOfSync = !1);
                }
                return this.data;
            }
            _containsPoint(t, e) {
                return (
                    (t += this.width * this.anchor.horizontal),
                    (e += this.height * this.anchor.vertical),
                    t >= this.x &&
                        t <= this.x + this.width &&
                        e >= this.y &&
                        e <= this.y + this.height
                );
            }
            getWidth() {
                return this.width;
            }
            getHeight() {
                return this.height;
            }
            setSize(t, e) {
                if (arguments.length !== 2)
                    throw new Error(
                        'You should pass exactly 2 arguments to `setSize(width, height)`.'
                    );
                if (typeof t != 'number' || !isFinite(t))
                    throw new TypeError(`Invalid value for \`width\`. Received type ${typeof t}`);
                if (typeof e != 'number' || !isFinite(e))
                    throw new TypeError(`Invalid value for \`height\`. Received type ${typeof e}`);
                (this.width = Math.max(0, t)),
                    (this.height = Math.max(0, e)),
                    (this._hiddenCanvasOutOfSync = !0);
            }
            getPixel(t, e) {
                if (this.data === qr || t > this.width || t < 0 || e > this.height || e < 0)
                    return [ys, ys, ys, ys];
                {
                    let o = Si * (e * this.width + t);
                    return [
                        this.data.data[o + dn],
                        this.data.data[o + fn],
                        this.data.data[o + mn],
                        this.data.data[o + gn],
                    ];
                }
            }
            getRed(t, e) {
                return this.getPixel(t, e)[dn];
            }
            getGreen(t, e) {
                return this.getPixel(t, e)[fn];
            }
            getBlue(t, e) {
                return this.getPixel(t, e)[mn];
            }
            getAlpha(t, e) {
                return this.getPixel(t, e)[gn];
            }
            setPixel(t, e, o, s) {
                if (this.data !== qr && !(t < 0 || e < 0 || t > this.width || e > this.height)) {
                    let n = Si * (e * this.width + t);
                    (this.data.data[n + o] = s), (this._hiddenCanvasOutOfSync = !0);
                }
            }
            setRed(t, e, o) {
                this.setPixel(t, e, dn, o);
            }
            setGreen(t, e, o) {
                this.setPixel(t, e, fn, o);
            }
            setBlue(t, e, o) {
                this.setPixel(t, e, mn, o);
            }
            setAlpha(t, e, o) {
                this.setPixel(t, e, gn, o);
            }
            setImageData(t) {
                (this.image = null),
                    (this.data = t),
                    (this.width = t.width),
                    (this.height = t.height),
                    (this._hiddenCanvasOutOfSync = !0);
            }
            updateHiddenCanvas() {
                (this._hiddenCanvas.width = Math.max(this._hiddenCanvas.width, this.width)),
                    (this._hiddenCanvas.height = Math.max(this._hiddenCanvas.height, this.height)),
                    this._hiddenCanvas.getContext('2d').putImageData(this.data, 0, 0),
                    (this._hiddenCanvasOutOfSync = !1);
            }
        },
        ki = Ci;
    var Uh = Audio,
        vs = class {
            constructor(t) {
                let e = new Uh(t);
                return (e.crossOrigin = 'anonymous'), e;
            }
        };
    var ws = () => {
        let r =
            window.AudioContext ||
            window.webkitAudioContext ||
            window.mozAudioContext ||
            window.oAudioContext ||
            window.msAudioContext;
        if (r)
            try {
                return new r();
            } catch {
                return (
                    console.error(
                        'Too many AudioContexts are in use. Please close all browser windows and retry.'
                    ),
                    0
                );
            }
        else
            return (
                console.error(
                    'Web Audio is not supported in this browser. Please use the most up to date version of Chrome, Firefox, or Safari.'
                ),
                0
            );
    };
    var bs = class extends Yo {
        constructor(t = {}) {
            super(t);
        }
        cleanup() {
            (this.audioChangeCallback = null), this.audioContext?.close();
        }
        getAudioContext() {
            return this.audioContext
                ? this.audioContext
                : ((this.audioContext = ws()), this.audioContext);
        }
        audioChangeMethod(t, e) {
            let o = this.getAudioContext();
            if (!o) return;
            let s = o.createAnalyser();
            s.fftSize = 128;
            let n = o.createMediaElementSource(t);
            (n.crossOrigin = 'anonymous'), n.connect(s);
            let i = o.createGain();
            n.connect(i), i.connect(o.destination);
            let a = s.frequencyBinCount,
                c = new Uint8Array(a),
                u = this.withErrorHandler(e);
            this.setTimer(() => {
                s.getByteFrequencyData(c), u(c);
            });
        }
    };
    var Vr = '14.7.77';
    var re = rn(_n());
    var Li = () => new DOMException('', 'AbortError');
    var Wi =
        r =>
        (t, e, [o, s, n], i) => {
            r(t[s], [e, o, n], a => a[0] === e && a[1] === o, i);
        };
    var Bi = r => (t, e, o) => {
        let s = [];
        for (let n = 0; n < o.numberOfInputs; n += 1) s.push(new Set());
        r.set(t, {
            activeInputs: s,
            outputs: new Set(),
            passiveInputs: new WeakMap(),
            renderer: e,
        });
    };
    var ji = r => (t, e) => {
        r.set(t, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: e });
    };
    var Fe = new WeakSet(),
        As = new WeakMap(),
        Ho = new WeakMap(),
        Ss = new WeakMap(),
        Hr = new WeakMap(),
        Xo = new WeakMap(),
        Cs = new WeakMap(),
        Xr = new WeakMap(),
        Qr = new WeakMap(),
        Zr = new WeakMap();
    var Gi = {
            construct() {
                return Gi;
            },
        },
        zi = r => {
            try {
                let t = new Proxy(r, Gi);
                new t();
            } catch {
                return !1;
            }
            return !0;
        };
    var Ui =
            /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,
        xn = (r, t) => {
            let e = [],
                o = r.replace(/^[\s]+/, ''),
                s = o.match(Ui);
            for (; s !== null; ) {
                let n = s[1].slice(1, -1),
                    i = s[0].replace(/([\s]+)?;?$/, '').replace(n, new URL(n, t).toString());
                e.push(i), (o = o.slice(s[0].length).replace(/^[\s]+/, '')), (s = o.match(Ui));
            }
            return [e.join(';'), o];
        };
    var Yi = r => {
            if (r !== void 0 && !Array.isArray(r))
                throw new TypeError(
                    'The parameterDescriptors property of given value for processorCtor is not an array.'
                );
        },
        Hi = r => {
            if (!zi(r))
                throw new TypeError('The given value for processorCtor should be a constructor.');
            if (r.prototype === null || typeof r.prototype != 'object')
                throw new TypeError('The given value for processorCtor should have a prototype.');
        },
        Xi = (r, t, e, o, s, n, i, a, c, u, l, h, p) => {
            let d = 0;
            return (f, m, _ = { credentials: 'omit' }) => {
                let y = l.get(f);
                if (y !== void 0 && y.has(m)) return Promise.resolve();
                let w = u.get(f);
                if (w !== void 0) {
                    let x = w.get(m);
                    if (x !== void 0) return x;
                }
                let O = n(f),
                    k =
                        O.audioWorklet === void 0
                            ? s(m)
                                  .then(([x, v]) => {
                                      let [b, T] = xn(x, v),
                                          F = `${b};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${T}
})})(window,'_AWGS')`;
                                      return e(F);
                                  })
                                  .then(() => {
                                      let x = p._AWGS.pop();
                                      if (x === void 0) throw new SyntaxError();
                                      o(O.currentTime, O.sampleRate, () =>
                                          x(
                                              class {},
                                              void 0,
                                              (v, b) => {
                                                  if (v.trim() === '') throw t();
                                                  let T = Qr.get(O);
                                                  if (T !== void 0) {
                                                      if (T.has(v)) throw t();
                                                      Hi(b),
                                                          Yi(b.parameterDescriptors),
                                                          T.set(v, b);
                                                  } else
                                                      Hi(b),
                                                          Yi(b.parameterDescriptors),
                                                          Qr.set(O, new Map([[v, b]]));
                                              },
                                              O.sampleRate,
                                              void 0,
                                              void 0
                                          )
                                      );
                                  })
                            : Promise.all([s(m), Promise.resolve(r(h, h))]).then(([[x, v], b]) => {
                                  let T = d + 1;
                                  d = T;
                                  let [F, E] = xn(x, v),
                                      q = `${F};((AudioWorkletProcessor,registerProcessor)=>{${E}
})(${
                                          b
                                              ? 'AudioWorkletProcessor'
                                              : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}'
                                      },(n,p)=>registerProcessor(n,class extends p{${
                                          b
                                              ? ''
                                              : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));'
                                      }process(i,o,p){${
                                          b
                                              ? ''
                                              : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));'
                                      }return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${T}',class extends AudioWorkletProcessor{process(){return !1}})`,
                                      Z = new Blob([q], {
                                          type: 'application/javascript; charset=utf-8',
                                      }),
                                      G = URL.createObjectURL(Z);
                                  return O.audioWorklet
                                      .addModule(G, _)
                                      .then(() => {
                                          if (a(O)) return O;
                                          let Y = i(O);
                                          return Y.audioWorklet.addModule(G, _).then(() => Y);
                                      })
                                      .then(Y => {
                                          if (c === null) throw new SyntaxError();
                                          try {
                                              new c(Y, `__sac${T}`);
                                          } catch {
                                              throw new SyntaxError();
                                          }
                                      })
                                      .finally(() => URL.revokeObjectURL(G));
                              });
                return (
                    w === void 0 ? u.set(f, new Map([[m, k]])) : w.set(m, k),
                    k
                        .then(() => {
                            let x = l.get(f);
                            x === void 0 ? l.set(f, new Set([m])) : x.add(m);
                        })
                        .finally(() => {
                            let x = u.get(f);
                            x !== void 0 && x.delete(m);
                        }),
                    k
                );
            };
        };
    var Ot = (r, t) => {
        let e = r.get(t);
        if (e === void 0) throw new Error('A value with the given key could not be found.');
        return e;
    };
    var no = (r, t) => {
        let e = Array.from(r).filter(t);
        if (e.length > 1) throw Error('More than one element was found.');
        if (e.length === 0) throw Error('No element was found.');
        let [o] = e;
        return r.delete(o), o;
    };
    var ks = (r, t, e, o) => {
        let s = Ot(r, t),
            n = no(s, i => i[0] === e && i[1] === o);
        return s.size === 0 && r.delete(t), n;
    };
    var Ie = r => Ot(Cs, r);
    var ye = r => {
        if (Fe.has(r)) throw new Error('The AudioNode is already stored.');
        Fe.add(r), Ie(r).forEach(t => t(!0));
    };
    var Ns = r => 'port' in r;
    var Re = r => {
        if (!Fe.has(r)) throw new Error('The AudioNode is not stored.');
        Fe.delete(r), Ie(r).forEach(t => t(!1));
    };
    var $r = (r, t) => {
        !Ns(r) && t.every(e => e.size === 0) && Re(r);
    };
    var Qi = (r, t, e, o, s, n, i, a, c, u, l, h, p) => {
        let d = new WeakMap();
        return (f, m, _, y, w) => {
            let { activeInputs: O, passiveInputs: k } = n(m),
                { outputs: x } = n(f),
                v = a(f),
                b = T => {
                    let F = c(m),
                        E = c(f);
                    if (T) {
                        let D = ks(k, f, _, y);
                        r(O, f, D, !1), !w && !h(f) && e(E, F, _, y), p(m) && ye(m);
                    } else {
                        let D = o(O, f, _, y);
                        t(k, y, D, !1), !w && !h(f) && s(E, F, _, y);
                        let N = i(m);
                        if (N === 0) l(m) && $r(m, O);
                        else {
                            let W = d.get(m);
                            W !== void 0 && clearTimeout(W),
                                d.set(
                                    m,
                                    setTimeout(() => {
                                        l(m) && $r(m, O);
                                    }, N * 1e3)
                                );
                        }
                    }
                };
            return u(x, [m, _, y], T => T[0] === m && T[1] === _ && T[2] === y, !0)
                ? (v.add(b), l(f) ? r(O, f, [_, y, b], !0) : t(k, y, [f, _, b], !0), !0)
                : !1;
        };
    };
    var Zi =
        r =>
        (t, e, [o, s, n], i) => {
            let a = t.get(o);
            a === void 0
                ? t.set(o, new Set([[s, e, n]]))
                : r(a, [s, e, n], c => c[0] === s && c[1] === e, i);
        };
    var $i = r => (t, e) => {
        let o = r(t, {
            channelCount: 1,
            channelCountMode: 'explicit',
            channelInterpretation: 'discrete',
            gain: 0,
        });
        e.connect(o).connect(t.destination);
        let s = () => {
            e.removeEventListener('ended', s), e.disconnect(o), o.disconnect();
        };
        e.addEventListener('ended', s);
    };
    var Ki = r => (t, e) => {
        r(t).add(e);
    };
    var sp = {
            channelCount: 2,
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fftSize: 2048,
            maxDecibels: -30,
            minDecibels: -100,
            smoothingTimeConstant: 0.8,
        },
        Ji = (r, t, e, o, s, n) =>
            class extends r {
                constructor(a, c) {
                    let u = s(a),
                        l = { ...sp, ...c },
                        h = o(u, l),
                        p = n(u) ? t() : null;
                    super(a, !1, h, p);
                    this._nativeAnalyserNode = h;
                }
                get fftSize() {
                    return this._nativeAnalyserNode.fftSize;
                }
                set fftSize(a) {
                    this._nativeAnalyserNode.fftSize = a;
                }
                get frequencyBinCount() {
                    return this._nativeAnalyserNode.frequencyBinCount;
                }
                get maxDecibels() {
                    return this._nativeAnalyserNode.maxDecibels;
                }
                set maxDecibels(a) {
                    let c = this._nativeAnalyserNode.maxDecibels;
                    if (
                        ((this._nativeAnalyserNode.maxDecibels = a),
                        !(a > this._nativeAnalyserNode.minDecibels))
                    )
                        throw ((this._nativeAnalyserNode.maxDecibels = c), e());
                }
                get minDecibels() {
                    return this._nativeAnalyserNode.minDecibels;
                }
                set minDecibels(a) {
                    let c = this._nativeAnalyserNode.minDecibels;
                    if (
                        ((this._nativeAnalyserNode.minDecibels = a),
                        !(this._nativeAnalyserNode.maxDecibels > a))
                    )
                        throw ((this._nativeAnalyserNode.minDecibels = c), e());
                }
                get smoothingTimeConstant() {
                    return this._nativeAnalyserNode.smoothingTimeConstant;
                }
                set smoothingTimeConstant(a) {
                    this._nativeAnalyserNode.smoothingTimeConstant = a;
                }
                getByteFrequencyData(a) {
                    this._nativeAnalyserNode.getByteFrequencyData(a);
                }
                getByteTimeDomainData(a) {
                    this._nativeAnalyserNode.getByteTimeDomainData(a);
                }
                getFloatFrequencyData(a) {
                    this._nativeAnalyserNode.getFloatFrequencyData(a);
                }
                getFloatTimeDomainData(a) {
                    this._nativeAnalyserNode.getFloatTimeDomainData(a);
                }
            };
    var nt = (r, t) => r.context === t;
    var ta = (r, t, e) => () => {
        let o = new WeakMap(),
            s = async (n, i) => {
                let a = t(n);
                if (!nt(a, i)) {
                    let u = {
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        fftSize: a.fftSize,
                        maxDecibels: a.maxDecibels,
                        minDecibels: a.minDecibels,
                        smoothingTimeConstant: a.smoothingTimeConstant,
                    };
                    a = r(i, u);
                }
                return o.set(i, a), await e(n, i, a), a;
            };
        return {
            render(n, i) {
                let a = o.get(i);
                return a !== void 0 ? Promise.resolve(a) : s(n, i);
            },
        };
    };
    var Qo = r => {
        try {
            r.copyToChannel(new Float32Array(1), 0, -1);
        } catch {
            return !1;
        }
        return !0;
    };
    var he = () => new DOMException('', 'IndexSizeError');
    var Zo = r => {
        r.getChannelData = (t => e => {
            try {
                return t.call(r, e);
            } catch (o) {
                throw o.code === 12 ? he() : o;
            }
        })(r.getChannelData);
    };
    var np = { numberOfChannels: 1 },
        ea = (r, t, e, o, s, n, i, a) => {
            let c = null;
            return class oa {
                constructor(l) {
                    if (s === null)
                        throw new Error('Missing the native OfflineAudioContext constructor.');
                    let { length: h, numberOfChannels: p, sampleRate: d } = { ...np, ...l };
                    c === null && (c = new s(1, 1, 44100));
                    let f =
                        o !== null && t(n, n)
                            ? new o({ length: h, numberOfChannels: p, sampleRate: d })
                            : c.createBuffer(p, h, d);
                    if (f.numberOfChannels === 0) throw e();
                    return (
                        typeof f.copyFromChannel != 'function'
                            ? (i(f), Zo(f))
                            : t(Qo, () => Qo(f)) || a(f),
                        r.add(f),
                        f
                    );
                }
                static [Symbol.hasInstance](l) {
                    return (
                        (l !== null &&
                            typeof l == 'object' &&
                            Object.getPrototypeOf(l) === oa.prototype) ||
                        r.has(l)
                    );
                }
            };
        };
    var St = -34028234663852886e22,
        Tt = -St;
    var Kt = r => Fe.has(r);
    var ip = {
            buffer: null,
            channelCount: 2,
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            loop: !1,
            loopEnd: 0,
            loopStart: 0,
            playbackRate: 1,
        },
        ra = (r, t, e, o, s, n, i, a) =>
            class extends r {
                constructor(u, l) {
                    let h = n(u),
                        p = { ...ip, ...l },
                        d = s(h, p),
                        f = i(h),
                        m = f ? t() : null;
                    super(u, !1, d, m);
                    (this._audioBufferSourceNodeRenderer = m),
                        (this._isBufferNullified = !1),
                        (this._isBufferSet = p.buffer !== null),
                        (this._nativeAudioBufferSourceNode = d),
                        (this._onended = null),
                        (this._playbackRate = e(this, f, d.playbackRate, Tt, St));
                }
                get buffer() {
                    return this._isBufferNullified
                        ? null
                        : this._nativeAudioBufferSourceNode.buffer;
                }
                set buffer(u) {
                    if (((this._nativeAudioBufferSourceNode.buffer = u), u !== null)) {
                        if (this._isBufferSet) throw o();
                        this._isBufferSet = !0;
                    }
                }
                get loop() {
                    return this._nativeAudioBufferSourceNode.loop;
                }
                set loop(u) {
                    this._nativeAudioBufferSourceNode.loop = u;
                }
                get loopEnd() {
                    return this._nativeAudioBufferSourceNode.loopEnd;
                }
                set loopEnd(u) {
                    this._nativeAudioBufferSourceNode.loopEnd = u;
                }
                get loopStart() {
                    return this._nativeAudioBufferSourceNode.loopStart;
                }
                set loopStart(u) {
                    this._nativeAudioBufferSourceNode.loopStart = u;
                }
                get onended() {
                    return this._onended;
                }
                set onended(u) {
                    let l = typeof u == 'function' ? a(this, u) : null;
                    this._nativeAudioBufferSourceNode.onended = l;
                    let h = this._nativeAudioBufferSourceNode.onended;
                    this._onended = h !== null && h === l ? u : h;
                }
                get playbackRate() {
                    return this._playbackRate;
                }
                start(u = 0, l = 0, h) {
                    if (
                        (this._nativeAudioBufferSourceNode.start(u, l, h),
                        this._audioBufferSourceNodeRenderer !== null &&
                            (this._audioBufferSourceNodeRenderer.start =
                                h === void 0 ? [u, l] : [u, l, h]),
                        this.context.state !== 'closed')
                    ) {
                        ye(this);
                        let p = () => {
                            this._nativeAudioBufferSourceNode.removeEventListener('ended', p),
                                Kt(this) && Re(this);
                        };
                        this._nativeAudioBufferSourceNode.addEventListener('ended', p);
                    }
                }
                stop(u = 0) {
                    this._nativeAudioBufferSourceNode.stop(u),
                        this._audioBufferSourceNodeRenderer !== null &&
                            (this._audioBufferSourceNodeRenderer.stop = u);
                }
            };
    var sa = (r, t, e, o, s) => () => {
        let n = new WeakMap(),
            i = null,
            a = null,
            c = async (u, l) => {
                let h = e(u),
                    p = nt(h, l);
                if (!p) {
                    let d = {
                        buffer: h.buffer,
                        channelCount: h.channelCount,
                        channelCountMode: h.channelCountMode,
                        channelInterpretation: h.channelInterpretation,
                        loop: h.loop,
                        loopEnd: h.loopEnd,
                        loopStart: h.loopStart,
                        playbackRate: h.playbackRate.value,
                    };
                    (h = t(l, d)), i !== null && h.start(...i), a !== null && h.stop(a);
                }
                return (
                    n.set(l, h),
                    p
                        ? await r(l, u.playbackRate, h.playbackRate)
                        : await o(l, u.playbackRate, h.playbackRate),
                    await s(u, l, h),
                    h
                );
            };
        return {
            set start(u) {
                i = u;
            },
            set stop(u) {
                a = u;
            },
            render(u, l) {
                let h = n.get(l);
                return h !== void 0 ? Promise.resolve(h) : c(u, l);
            },
        };
    };
    var na = r => 'playbackRate' in r;
    var ia = r => 'frequency' in r && 'gain' in r;
    var aa = r => 'offset' in r;
    var ca = r => !('frequency' in r) && 'gain' in r;
    var ua = r => 'detune' in r && 'frequency' in r;
    var la = r => 'pan' in r;
    var It = r => Ot(As, r);
    var io = r => Ot(Ss, r);
    var Os = (r, t) => {
        let { activeInputs: e } = It(r);
        e.forEach(s =>
            s.forEach(([n]) => {
                t.includes(r) || Os(n, [...t, r]);
            })
        );
        let o = na(r)
            ? [r.playbackRate]
            : Ns(r)
            ? Array.from(r.parameters.values())
            : ia(r)
            ? [r.Q, r.detune, r.frequency, r.gain]
            : aa(r)
            ? [r.offset]
            : ca(r)
            ? [r.gain]
            : ua(r)
            ? [r.detune, r.frequency]
            : la(r)
            ? [r.pan]
            : [];
        for (let s of o) {
            let n = io(s);
            n !== void 0 && n.activeInputs.forEach(([i]) => Os(i, t));
        }
        Kt(r) && Re(r);
    };
    var ao = r => {
        Os(r.destination, []);
    };
    var Ds = r =>
        r === void 0 ||
        typeof r == 'number' ||
        (typeof r == 'string' && (r === 'balanced' || r === 'interactive' || r === 'playback'));
    var ha = (r, t, e, o, s, n, i, a, c) =>
        class extends r {
            constructor(l = {}) {
                if (c === null) throw new Error('Missing the native AudioContext constructor.');
                let h;
                try {
                    h = new c(l);
                } catch (f) {
                    throw f.code === 12 && f.message === 'sampleRate is not in range' ? e() : f;
                }
                if (h === null) throw o();
                if (!Ds(l.latencyHint))
                    throw new TypeError(
                        `The provided value '${l.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`
                    );
                if (l.sampleRate !== void 0 && h.sampleRate !== l.sampleRate) throw e();
                super(h, 2);
                let { latencyHint: p } = l,
                    { sampleRate: d } = h;
                if (
                    ((this._baseLatency =
                        typeof h.baseLatency == 'number'
                            ? h.baseLatency
                            : p === 'balanced'
                            ? 512 / d
                            : p === 'interactive' || p === void 0
                            ? 256 / d
                            : p === 'playback'
                            ? 1024 / d
                            : (Math.max(2, Math.min(128, Math.round((p * d) / 128))) * 128) / d),
                    (this._nativeAudioContext = h),
                    c.name === 'webkitAudioContext'
                        ? ((this._nativeGainNode = h.createGain()),
                          (this._nativeOscillatorNode = h.createOscillator()),
                          (this._nativeGainNode.gain.value = 1e-37),
                          this._nativeOscillatorNode
                              .connect(this._nativeGainNode)
                              .connect(h.destination),
                          this._nativeOscillatorNode.start())
                        : ((this._nativeGainNode = null), (this._nativeOscillatorNode = null)),
                    (this._state = null),
                    h.state === 'running')
                ) {
                    this._state = 'suspended';
                    let f = () => {
                        this._state === 'suspended' && (this._state = null),
                            h.removeEventListener('statechange', f);
                    };
                    h.addEventListener('statechange', f);
                }
            }
            get baseLatency() {
                return this._baseLatency;
            }
            get state() {
                return this._state !== null ? this._state : this._nativeAudioContext.state;
            }
            close() {
                return this.state === 'closed'
                    ? this._nativeAudioContext.close().then(() => {
                          throw t();
                      })
                    : (this._state === 'suspended' && (this._state = null),
                      this._nativeAudioContext.close().then(() => {
                          this._nativeGainNode !== null &&
                              this._nativeOscillatorNode !== null &&
                              (this._nativeOscillatorNode.stop(),
                              this._nativeGainNode.disconnect(),
                              this._nativeOscillatorNode.disconnect()),
                              ao(this);
                      }));
            }
            createMediaElementSource(l) {
                return new s(this, { mediaElement: l });
            }
            createMediaStreamDestination() {
                return new n(this);
            }
            createMediaStreamSource(l) {
                return new i(this, { mediaStream: l });
            }
            createMediaStreamTrackSource(l) {
                return new a(this, { mediaStreamTrack: l });
            }
            resume() {
                return this._state === 'suspended'
                    ? new Promise((l, h) => {
                          let p = () => {
                              this._nativeAudioContext.removeEventListener('statechange', p),
                                  this._nativeAudioContext.state === 'running'
                                      ? l()
                                      : this.resume().then(l, h);
                          };
                          this._nativeAudioContext.addEventListener('statechange', p);
                      })
                    : this._nativeAudioContext.resume().catch(l => {
                          throw l === void 0 || l.code === 15 ? t() : l;
                      });
            }
            suspend() {
                return this._nativeAudioContext.suspend().catch(l => {
                    throw l === void 0 ? t() : l;
                });
            }
        };
    var pa = (r, t, e, o, s, n, i, a) =>
        class extends r {
            constructor(u, l) {
                let h = n(u),
                    p = i(h),
                    d = s(h, l, p),
                    f = p ? t(a) : null;
                super(u, !1, d, f);
                (this._isNodeOfNativeOfflineAudioContext = p),
                    (this._nativeAudioDestinationNode = d);
            }
            get channelCount() {
                return this._nativeAudioDestinationNode.channelCount;
            }
            set channelCount(u) {
                if (this._isNodeOfNativeOfflineAudioContext) throw o();
                if (u > this._nativeAudioDestinationNode.maxChannelCount) throw e();
                this._nativeAudioDestinationNode.channelCount = u;
            }
            get channelCountMode() {
                return this._nativeAudioDestinationNode.channelCountMode;
            }
            set channelCountMode(u) {
                if (this._isNodeOfNativeOfflineAudioContext) throw o();
                this._nativeAudioDestinationNode.channelCountMode = u;
            }
            get maxChannelCount() {
                return this._nativeAudioDestinationNode.maxChannelCount;
            }
        };
    var da = r => {
        let t = new WeakMap(),
            e = async (o, s) => {
                let n = s.destination;
                return t.set(s, n), await r(o, s, n), n;
            };
        return {
            render(o, s) {
                let n = t.get(s);
                return n !== void 0 ? Promise.resolve(n) : e(o, s);
            },
        };
    };
    var fa = (r, t, e, o, s, n, i, a) => (c, u) => {
        let l = u.listener,
            h = () => {
                let x = new Float32Array(1),
                    v = t(u, {
                        channelCount: 1,
                        channelCountMode: 'explicit',
                        channelInterpretation: 'speakers',
                        numberOfInputs: 9,
                    }),
                    b = i(u),
                    T = !1,
                    F = [0, 0, -1, 0, 1, 0],
                    E = [0, 0, 0],
                    D = () => {
                        if (T) return;
                        T = !0;
                        let Z = o(u, 256, 9, 0);
                        (Z.onaudioprocess = ({ inputBuffer: G }) => {
                            let Y = [
                                n(G, x, 0),
                                n(G, x, 1),
                                n(G, x, 2),
                                n(G, x, 3),
                                n(G, x, 4),
                                n(G, x, 5),
                            ];
                            Y.some((C, I) => C !== F[I]) && (l.setOrientation(...Y), (F = Y));
                            let V = [n(G, x, 6), n(G, x, 7), n(G, x, 8)];
                            V.some((C, I) => C !== E[I]) && (l.setPosition(...V), (E = V));
                        }),
                            v.connect(Z);
                    },
                    N = Z => G => {
                        G !== F[Z] && ((F[Z] = G), l.setOrientation(...F));
                    },
                    W = Z => G => {
                        G !== E[Z] && ((E[Z] = G), l.setPosition(...E));
                    },
                    q = (Z, G, Y) => {
                        let V = e(u, {
                            channelCount: 1,
                            channelCountMode: 'explicit',
                            channelInterpretation: 'discrete',
                            offset: G,
                        });
                        V.connect(v, 0, Z),
                            V.start(),
                            Object.defineProperty(V.offset, 'defaultValue', {
                                get() {
                                    return G;
                                },
                            });
                        let C = r({ context: c }, b, V.offset, Tt, St);
                        return (
                            a(
                                C,
                                'value',
                                I => () => I.call(C),
                                I => A => {
                                    try {
                                        I.call(C, A);
                                    } catch (L) {
                                        if (L.code !== 9) throw L;
                                    }
                                    D(), b && Y(A);
                                }
                            ),
                            (C.cancelAndHoldAtTime = (I =>
                                b
                                    ? () => {
                                          throw s();
                                      }
                                    : (...A) => {
                                          let L = I.apply(C, A);
                                          return D(), L;
                                      })(C.cancelAndHoldAtTime)),
                            (C.cancelScheduledValues = (I =>
                                b
                                    ? () => {
                                          throw s();
                                      }
                                    : (...A) => {
                                          let L = I.apply(C, A);
                                          return D(), L;
                                      })(C.cancelScheduledValues)),
                            (C.exponentialRampToValueAtTime = (I =>
                                b
                                    ? () => {
                                          throw s();
                                      }
                                    : (...A) => {
                                          let L = I.apply(C, A);
                                          return D(), L;
                                      })(C.exponentialRampToValueAtTime)),
                            (C.linearRampToValueAtTime = (I =>
                                b
                                    ? () => {
                                          throw s();
                                      }
                                    : (...A) => {
                                          let L = I.apply(C, A);
                                          return D(), L;
                                      })(C.linearRampToValueAtTime)),
                            (C.setTargetAtTime = (I =>
                                b
                                    ? () => {
                                          throw s();
                                      }
                                    : (...A) => {
                                          let L = I.apply(C, A);
                                          return D(), L;
                                      })(C.setTargetAtTime)),
                            (C.setValueAtTime = (I =>
                                b
                                    ? () => {
                                          throw s();
                                      }
                                    : (...A) => {
                                          let L = I.apply(C, A);
                                          return D(), L;
                                      })(C.setValueAtTime)),
                            (C.setValueCurveAtTime = (I =>
                                b
                                    ? () => {
                                          throw s();
                                      }
                                    : (...A) => {
                                          let L = I.apply(C, A);
                                          return D(), L;
                                      })(C.setValueCurveAtTime)),
                            C
                        );
                    };
                return {
                    forwardX: q(0, 0, N(0)),
                    forwardY: q(1, 0, N(1)),
                    forwardZ: q(2, -1, N(2)),
                    positionX: q(6, 0, W(0)),
                    positionY: q(7, 0, W(1)),
                    positionZ: q(8, 0, W(2)),
                    upX: q(3, 0, N(3)),
                    upY: q(4, 1, N(4)),
                    upZ: q(5, 0, N(5)),
                };
            },
            {
                forwardX: p,
                forwardY: d,
                forwardZ: f,
                positionX: m,
                positionY: _,
                positionZ: y,
                upX: w,
                upY: O,
                upZ: k,
            } = l.forwardX === void 0 ? h() : l;
        return {
            get forwardX() {
                return p;
            },
            get forwardY() {
                return d;
            },
            get forwardZ() {
                return f;
            },
            get positionX() {
                return m;
            },
            get positionY() {
                return _;
            },
            get positionZ() {
                return y;
            },
            get upX() {
                return w;
            },
            get upY() {
                return O;
            },
            get upZ() {
                return k;
            },
        };
    };
    var vo = r => 'context' in r;
    var co = r => vo(r[0]);
    var ve = (r, t, e, o) => {
        for (let s of r)
            if (e(s)) {
                if (o) return !1;
                throw Error('The set contains at least one similar element.');
            }
        return r.add(t), !0;
    };
    var yn = (r, t, [e, o], s) => {
        ve(r, [t, e, o], n => n[0] === t && n[1] === e, s);
    };
    var vn = (r, [t, e, o], s) => {
        let n = r.get(t);
        n === void 0 ? r.set(t, new Set([[e, o]])) : ve(n, [e, o], i => i[0] === e, s);
    };
    var pe = r => 'inputs' in r;
    var $o = (r, t, e, o) => {
        if (pe(t)) {
            let s = t.inputs[o];
            return r.connect(s, e, 0), [s, e, 0];
        }
        return r.connect(t, e, o), [t, e, o];
    };
    var wn = (r, t, e) => {
        for (let o of r) if (o[0] === t && o[1] === e) return r.delete(o), o;
        return null;
    };
    var ma = (r, t, e) => no(r, o => o[0] === t && o[1] === e);
    var bn = (r, t) => {
        if (!Ie(r).delete(t)) throw new Error('Missing the expected event listener.');
    };
    var Tn = (r, t, e) => {
        let o = Ot(r, t),
            s = no(o, n => n[0] === e);
        return o.size === 0 && r.delete(t), s;
    };
    var Ko = (r, t, e, o) => {
        pe(t) ? r.disconnect(t.inputs[o], e, 0) : r.disconnect(t, e, o);
    };
    var dt = r => Ot(Ho, r);
    var wo = r => Ot(Hr, r);
    var He = r => Xr.has(r);
    var Jo = r => !Fe.has(r);
    var An = (r, t) =>
        new Promise(e => {
            if (t !== null) e(!0);
            else {
                let o = r.createScriptProcessor(256, 1, 1),
                    s = r.createGain(),
                    n = r.createBuffer(1, 2, 44100),
                    i = n.getChannelData(0);
                (i[0] = 1), (i[1] = 1);
                let a = r.createBufferSource();
                (a.buffer = n),
                    (a.loop = !0),
                    a.connect(o).connect(r.destination),
                    a.connect(s),
                    a.disconnect(s),
                    (o.onaudioprocess = c => {
                        let u = c.inputBuffer.getChannelData(0);
                        Array.prototype.some.call(u, l => l === 1) ? e(!0) : e(!1),
                            a.stop(),
                            (o.onaudioprocess = null),
                            a.disconnect(o),
                            o.disconnect(r.destination);
                    }),
                    a.start();
            }
        });
    var Es = (r, t) => {
        let e = new Map();
        for (let o of r)
            for (let s of o) {
                let n = e.get(s);
                e.set(s, n === void 0 ? 1 : n + 1);
            }
        e.forEach((o, s) => t(s, o));
    };
    var bo = r => 'context' in r;
    var ga = r => {
        let t = new Map();
        (r.connect = (
            e =>
            (o, s = 0, n = 0) => {
                let i = bo(o) ? e(o, s, n) : e(o, s),
                    a = t.get(o);
                return (
                    a === void 0
                        ? t.set(o, [{ input: n, output: s }])
                        : a.every(c => c.input !== n || c.output !== s) &&
                          a.push({ input: n, output: s }),
                    i
                );
            }
        )(r.connect.bind(r))),
            (r.disconnect = (e => (o, s, n) => {
                if ((e.apply(r), o === void 0)) t.clear();
                else if (typeof o == 'number')
                    for (let [i, a] of t) {
                        let c = a.filter(u => u.output !== o);
                        c.length === 0 ? t.delete(i) : t.set(i, c);
                    }
                else if (t.has(o))
                    if (s === void 0) t.delete(o);
                    else {
                        let i = t.get(o);
                        if (i !== void 0) {
                            let a = i.filter(
                                c => c.output !== s && (c.input !== n || n === void 0)
                            );
                            a.length === 0 ? t.delete(o) : t.set(o, a);
                        }
                    }
                for (let [i, a] of t)
                    a.forEach(c => {
                        bo(i) ? r.connect(i, c.output, c.input) : r.connect(i, c.output);
                    });
            })(r.disconnect));
    };
    var ap = (r, t, e, o) => {
            let { activeInputs: s, passiveInputs: n } = io(t),
                { outputs: i } = It(r),
                a = Ie(r),
                c = u => {
                    let l = dt(r),
                        h = wo(t);
                    if (u) {
                        let p = Tn(n, r, e);
                        yn(s, r, p, !1), !o && !He(r) && l.connect(h, e);
                    } else {
                        let p = ma(s, r, e);
                        vn(n, p, !1), !o && !He(r) && l.disconnect(h, e);
                    }
                };
            return ve(i, [t, e], u => u[0] === t && u[1] === e, !0)
                ? (a.add(c), Kt(r) ? yn(s, r, [e, c], !0) : vn(n, [r, e, c], !0), !0)
                : !1;
        },
        cp = (r, t, e, o) => {
            let { activeInputs: s, passiveInputs: n } = It(t),
                i = wn(s[o], r, e);
            return i === null ? [ks(n, r, e, o)[2], !1] : [i[2], !0];
        },
        up = (r, t, e) => {
            let { activeInputs: o, passiveInputs: s } = io(t),
                n = wn(o, r, e);
            return n === null ? [Tn(s, r, e)[1], !1] : [n[2], !0];
        },
        Sn = (r, t, e, o, s) => {
            let [n, i] = cp(r, e, o, s);
            if ((n !== null && (bn(r, n), i && !t && !He(r) && Ko(dt(r), dt(e), o, s)), Kt(e))) {
                let { activeInputs: a } = It(e);
                $r(e, a);
            }
        },
        Cn = (r, t, e, o) => {
            let [s, n] = up(r, e, o);
            s !== null && (bn(r, s), n && !t && !He(r) && dt(r).disconnect(wo(e), o));
        },
        lp = (r, t) => {
            let e = It(r),
                o = [];
            for (let s of e.outputs) co(s) ? Sn(r, t, ...s) : Cn(r, t, ...s), o.push(s[0]);
            return e.outputs.clear(), o;
        },
        hp = (r, t, e) => {
            let o = It(r),
                s = [];
            for (let n of o.outputs)
                n[1] === e &&
                    (co(n) ? Sn(r, t, ...n) : Cn(r, t, ...n), s.push(n[0]), o.outputs.delete(n));
            return s;
        },
        pp = (r, t, e, o, s) => {
            let n = It(r);
            return Array.from(n.outputs)
                .filter(
                    i => i[0] === e && (o === void 0 || i[1] === o) && (s === void 0 || i[2] === s)
                )
                .map(i => (co(i) ? Sn(r, t, ...i) : Cn(r, t, ...i), n.outputs.delete(i), i[0]));
        },
        _a = (r, t, e, o, s, n, i, a, c, u, l, h, p, d, f, m) =>
            class extends u {
                constructor(y, w, O, k) {
                    super(O);
                    (this._context = y), (this._nativeAudioNode = O);
                    let x = l(y);
                    h(x) && e(An, () => An(x, m)) !== !0 && ga(O),
                        Ho.set(this, O),
                        Cs.set(this, new Set()),
                        y.state !== 'closed' && w && ye(this),
                        r(this, k, O);
                }
                get channelCount() {
                    return this._nativeAudioNode.channelCount;
                }
                set channelCount(y) {
                    this._nativeAudioNode.channelCount = y;
                }
                get channelCountMode() {
                    return this._nativeAudioNode.channelCountMode;
                }
                set channelCountMode(y) {
                    this._nativeAudioNode.channelCountMode = y;
                }
                get channelInterpretation() {
                    return this._nativeAudioNode.channelInterpretation;
                }
                set channelInterpretation(y) {
                    this._nativeAudioNode.channelInterpretation = y;
                }
                get context() {
                    return this._context;
                }
                get numberOfInputs() {
                    return this._nativeAudioNode.numberOfInputs;
                }
                get numberOfOutputs() {
                    return this._nativeAudioNode.numberOfOutputs;
                }
                connect(y, w = 0, O = 0) {
                    if (w < 0 || w >= this._nativeAudioNode.numberOfOutputs) throw s();
                    let k = l(this._context),
                        x = f(k);
                    if (p(y) || d(y)) throw n();
                    if (vo(y)) {
                        let T = dt(y);
                        try {
                            let E = $o(this._nativeAudioNode, T, w, O),
                                D = Jo(this);
                            (x || D) && this._nativeAudioNode.disconnect(...E),
                                this.context.state !== 'closed' && !D && Jo(y) && ye(y);
                        } catch (E) {
                            throw E.code === 12 ? n() : E;
                        }
                        if (t(this, y, w, O, x)) {
                            let E = c([this], y);
                            Es(E, o(x));
                        }
                        return y;
                    }
                    let v = wo(y);
                    if (v.name === 'playbackRate' && v.maxValue === 1024) throw i();
                    try {
                        this._nativeAudioNode.connect(v, w),
                            (x || Jo(this)) && this._nativeAudioNode.disconnect(v, w);
                    } catch (T) {
                        throw T.code === 12 ? n() : T;
                    }
                    if (ap(this, y, w, x)) {
                        let T = c([this], y);
                        Es(T, o(x));
                    }
                }
                disconnect(y, w, O) {
                    let k,
                        x = l(this._context),
                        v = f(x);
                    if (y === void 0) k = lp(this, v);
                    else if (typeof y == 'number') {
                        if (y < 0 || y >= this.numberOfOutputs) throw s();
                        k = hp(this, v, y);
                    } else {
                        if (
                            (w !== void 0 && (w < 0 || w >= this.numberOfOutputs)) ||
                            (vo(y) && O !== void 0 && (O < 0 || O >= y.numberOfInputs))
                        )
                            throw s();
                        if (((k = pp(this, v, y, w, O)), k.length === 0)) throw n();
                    }
                    for (let b of k) {
                        let T = c([this], b);
                        Es(T, a);
                    }
                }
            };
    var xa = rn(_n()),
        ya =
            (r, t, e, o, s, n, i, a, c, u, l, h, p) =>
            (d, f, m, _ = null, y = null) => {
                let w = new xa.AutomationEventList(m.defaultValue),
                    O = f ? o(w) : null,
                    k = {
                        get defaultValue() {
                            return m.defaultValue;
                        },
                        get maxValue() {
                            return _ === null ? m.maxValue : _;
                        },
                        get minValue() {
                            return y === null ? m.minValue : y;
                        },
                        get value() {
                            return m.value;
                        },
                        set value(x) {
                            (m.value = x), k.setValueAtTime(x, d.context.currentTime);
                        },
                        cancelAndHoldAtTime(x) {
                            if (typeof m.cancelAndHoldAtTime == 'function')
                                O === null && w.flush(d.context.currentTime),
                                    w.add(s(x)),
                                    m.cancelAndHoldAtTime(x);
                            else {
                                let v = Array.from(w).pop();
                                O === null && w.flush(d.context.currentTime), w.add(s(x));
                                let b = Array.from(w).pop();
                                m.cancelScheduledValues(x),
                                    v !== b &&
                                        b !== void 0 &&
                                        (b.type === 'exponentialRampToValue'
                                            ? m.exponentialRampToValueAtTime(b.value, b.endTime)
                                            : b.type === 'linearRampToValue'
                                            ? m.linearRampToValueAtTime(b.value, b.endTime)
                                            : b.type === 'setValue'
                                            ? m.setValueAtTime(b.value, b.startTime)
                                            : b.type === 'setValueCurve' &&
                                              m.setValueCurveAtTime(
                                                  b.values,
                                                  b.startTime,
                                                  b.duration
                                              ));
                            }
                            return k;
                        },
                        cancelScheduledValues(x) {
                            return (
                                O === null && w.flush(d.context.currentTime),
                                w.add(n(x)),
                                m.cancelScheduledValues(x),
                                k
                            );
                        },
                        exponentialRampToValueAtTime(x, v) {
                            if (x === 0) throw new RangeError();
                            if (!Number.isFinite(v) || v < 0) throw new RangeError();
                            return (
                                O === null && w.flush(d.context.currentTime),
                                w.add(i(x, v)),
                                m.exponentialRampToValueAtTime(x, v),
                                k
                            );
                        },
                        linearRampToValueAtTime(x, v) {
                            return (
                                O === null && w.flush(d.context.currentTime),
                                w.add(a(x, v)),
                                m.linearRampToValueAtTime(x, v),
                                k
                            );
                        },
                        setTargetAtTime(x, v, b) {
                            return (
                                O === null && w.flush(d.context.currentTime),
                                w.add(c(x, v, b)),
                                m.setTargetAtTime(x, v, b),
                                k
                            );
                        },
                        setValueAtTime(x, v) {
                            return (
                                O === null && w.flush(d.context.currentTime),
                                w.add(u(x, v)),
                                m.setValueAtTime(x, v),
                                k
                            );
                        },
                        setValueCurveAtTime(x, v, b) {
                            let T = x instanceof Float32Array ? x : new Float32Array(x);
                            if (h !== null && h.name === 'webkitAudioContext') {
                                let F = v + b,
                                    E = d.context.sampleRate,
                                    D = Math.ceil(v * E),
                                    N = Math.floor(F * E),
                                    W = N - D,
                                    q = new Float32Array(W);
                                for (let G = 0; G < W; G += 1) {
                                    let Y = ((T.length - 1) / b) * ((D + G) / E - v),
                                        V = Math.floor(Y),
                                        C = Math.ceil(Y);
                                    q[G] =
                                        V === C
                                            ? T[V]
                                            : (1 - (Y - V)) * T[V] + (1 - (C - Y)) * T[C];
                                }
                                O === null && w.flush(d.context.currentTime),
                                    w.add(l(q, v, b)),
                                    m.setValueCurveAtTime(q, v, b);
                                let Z = N / E;
                                Z < F && p(k, q[q.length - 1], Z), p(k, T[T.length - 1], F);
                            } else
                                O === null && w.flush(d.context.currentTime),
                                    w.add(l(T, v, b)),
                                    m.setValueCurveAtTime(T, v, b);
                            return k;
                        },
                    };
                return e.set(k, m), t.set(k, d), r(k, O), k;
            };
    var va = r => ({
        replay(t) {
            for (let e of r)
                if (e.type === 'exponentialRampToValue') {
                    let { endTime: o, value: s } = e;
                    t.exponentialRampToValueAtTime(s, o);
                } else if (e.type === 'linearRampToValue') {
                    let { endTime: o, value: s } = e;
                    t.linearRampToValueAtTime(s, o);
                } else if (e.type === 'setTarget') {
                    let { startTime: o, target: s, timeConstant: n } = e;
                    t.setTargetAtTime(s, o, n);
                } else if (e.type === 'setValue') {
                    let { startTime: o, value: s } = e;
                    t.setValueAtTime(s, o);
                } else if (e.type === 'setValueCurve') {
                    let { duration: o, startTime: s, values: n } = e;
                    t.setValueCurveAtTime(n, s, o);
                } else throw new Error("Can't apply an unknown automation.");
        },
    });
    var Kr = class {
        constructor(t) {
            this._map = new Map(t);
        }
        get size() {
            return this._map.size;
        }
        entries() {
            return this._map.entries();
        }
        forEach(t, e = null) {
            return this._map.forEach((o, s) => t.call(e, o, s, this));
        }
        get(t) {
            return this._map.get(t);
        }
        has(t) {
            return this._map.has(t);
        }
        keys() {
            return this._map.keys();
        }
        values() {
            return this._map.values();
        }
    };
    var dp = {
            channelCount: 2,
            channelCountMode: 'explicit',
            channelInterpretation: 'speakers',
            numberOfInputs: 1,
            numberOfOutputs: 1,
            parameterData: {},
            processorOptions: {},
        },
        wa = (r, t, e, o, s, n, i, a, c, u, l, h, p, d) =>
            class extends t {
                constructor(m, _, y) {
                    var w;
                    let O = a(m),
                        k = c(O),
                        x = l({ ...dp, ...y });
                    p(x);
                    let v = Qr.get(O),
                        b = v == null ? void 0 : v.get(_),
                        T =
                            k || O.state !== 'closed'
                                ? O
                                : (w = i(O)) !== null && w !== void 0
                                ? w
                                : O,
                        F = s(T, k ? null : m.baseLatency, u, _, b, x),
                        E = k ? o(_, x, b) : null;
                    super(m, !0, F, E);
                    let D = [];
                    F.parameters.forEach((W, q) => {
                        let Z = e(this, k, W);
                        D.push([q, Z]);
                    }),
                        (this._nativeAudioWorkletNode = F),
                        (this._onprocessorerror = null),
                        (this._parameters = new Kr(D)),
                        k && r(O, this);
                    let { activeInputs: N } = n(this);
                    h(F, N);
                }
                get onprocessorerror() {
                    return this._onprocessorerror;
                }
                set onprocessorerror(m) {
                    let _ = typeof m == 'function' ? d(this, m) : null;
                    this._nativeAudioWorkletNode.onprocessorerror = _;
                    let y = this._nativeAudioWorkletNode.onprocessorerror;
                    this._onprocessorerror = y !== null && y === _ ? m : y;
                }
                get parameters() {
                    return this._parameters === null
                        ? this._nativeAudioWorkletNode.parameters
                        : this._parameters;
                }
                get port() {
                    return this._nativeAudioWorkletNode.port;
                }
            };
    function tr(r, t, e, o, s) {
        if (typeof r.copyFromChannel == 'function')
            t[e].byteLength === 0 && (t[e] = new Float32Array(128)), r.copyFromChannel(t[e], o, s);
        else {
            let n = r.getChannelData(o);
            if (t[e].byteLength === 0) t[e] = n.slice(s, s + 128);
            else {
                let i = new Float32Array(n.buffer, s * Float32Array.BYTES_PER_ELEMENT, 128);
                t[e].set(i);
            }
        }
    }
    var Ms = (r, t, e, o, s) => {
        typeof r.copyToChannel == 'function'
            ? t[e].byteLength !== 0 && r.copyToChannel(t[e], o, s)
            : t[e].byteLength !== 0 && r.getChannelData(o).set(t[e], s);
    };
    var er = (r, t) => {
        let e = [];
        for (let o = 0; o < r; o += 1) {
            let s = [],
                n = typeof t == 'number' ? t : t[o];
            for (let i = 0; i < n; i += 1) s.push(new Float32Array(128));
            e.push(s);
        }
        return e;
    };
    var ba = (r, t) => {
        let e = Ot(Zr, r),
            o = dt(t);
        return Ot(e, o);
    };
    var fp = async (r, t, e, o, s, n, i) => {
            let a = t === null ? Math.ceil(r.context.length / 128) * 128 : t.length,
                c = o.channelCount * o.numberOfInputs,
                u = s.reduce((_, y) => _ + y, 0),
                l = u === 0 ? null : e.createBuffer(u, a, e.sampleRate);
            if (n === void 0) throw new Error('Missing the processor constructor.');
            let h = It(r),
                p = await ba(e, r),
                d = er(o.numberOfInputs, o.channelCount),
                f = er(o.numberOfOutputs, s),
                m = Array.from(r.parameters.keys()).reduce(
                    (_, y) => ({ ..._, [y]: new Float32Array(128) }),
                    {}
                );
            for (let _ = 0; _ < a; _ += 128) {
                if (o.numberOfInputs > 0 && t !== null)
                    for (let y = 0; y < o.numberOfInputs; y += 1)
                        for (let w = 0; w < o.channelCount; w += 1) tr(t, d[y], w, w, _);
                n.parameterDescriptors !== void 0 &&
                    t !== null &&
                    n.parameterDescriptors.forEach(({ name: y }, w) => {
                        tr(t, m, y, c + w, _);
                    });
                for (let y = 0; y < o.numberOfInputs; y += 1)
                    for (let w = 0; w < s[y]; w += 1)
                        f[y][w].byteLength === 0 && (f[y][w] = new Float32Array(128));
                try {
                    let y = d.map((O, k) => (h.activeInputs[k].size === 0 ? [] : O)),
                        w = i(_ / e.sampleRate, e.sampleRate, () => p.process(y, f, m));
                    if (l !== null)
                        for (let O = 0, k = 0; O < o.numberOfOutputs; O += 1) {
                            for (let x = 0; x < s[O]; x += 1) Ms(l, f[O], x, k + x, _);
                            k += s[O];
                        }
                    if (!w) break;
                } catch (y) {
                    r.dispatchEvent(
                        new ErrorEvent('processorerror', {
                            colno: y.colno,
                            filename: y.filename,
                            lineno: y.lineno,
                            message: y.message,
                        })
                    );
                    break;
                }
            }
            return l;
        },
        Ta = (r, t, e, o, s, n, i, a, c, u, l, h, p, d, f, m) => (_, y, w) => {
            let O = new WeakMap(),
                k = null,
                x = async (v, b) => {
                    let T = l(v),
                        F = null,
                        E = nt(T, b),
                        D = Array.isArray(y.outputChannelCount)
                            ? y.outputChannelCount
                            : Array.from(y.outputChannelCount);
                    if (h === null) {
                        let N = D.reduce((G, Y) => G + Y, 0),
                            W = s(b, {
                                channelCount: Math.max(1, N),
                                channelCountMode: 'explicit',
                                channelInterpretation: 'discrete',
                                numberOfOutputs: Math.max(1, N),
                            }),
                            q = [];
                        for (let G = 0; G < v.numberOfOutputs; G += 1)
                            q.push(
                                o(b, {
                                    channelCount: 1,
                                    channelCountMode: 'explicit',
                                    channelInterpretation: 'speakers',
                                    numberOfInputs: D[G],
                                })
                            );
                        let Z = i(b, {
                            channelCount: y.channelCount,
                            channelCountMode: y.channelCountMode,
                            channelInterpretation: y.channelInterpretation,
                            gain: 1,
                        });
                        (Z.connect = t.bind(null, q)),
                            (Z.disconnect = c.bind(null, q)),
                            (F = [W, q, Z]);
                    } else E || (T = new h(b, _));
                    if ((O.set(b, F === null ? T : F[2]), F !== null)) {
                        if (k === null) {
                            if (w === void 0) throw new Error('Missing the processor constructor.');
                            if (p === null)
                                throw new Error(
                                    'Missing the native OfflineAudioContext constructor.'
                                );
                            let Y = v.channelCount * v.numberOfInputs,
                                V =
                                    w.parameterDescriptors === void 0
                                        ? 0
                                        : w.parameterDescriptors.length,
                                C = Y + V;
                            k = fp(
                                v,
                                C === 0
                                    ? null
                                    : await (async () => {
                                          let A = new p(
                                                  C,
                                                  Math.ceil(v.context.length / 128) * 128,
                                                  b.sampleRate
                                              ),
                                              L = [],
                                              U = [];
                                          for (let lt = 0; lt < y.numberOfInputs; lt += 1)
                                              L.push(
                                                  i(A, {
                                                      channelCount: y.channelCount,
                                                      channelCountMode: y.channelCountMode,
                                                      channelInterpretation:
                                                          y.channelInterpretation,
                                                      gain: 1,
                                                  })
                                              ),
                                                  U.push(
                                                      s(A, {
                                                          channelCount: y.channelCount,
                                                          channelCountMode: 'explicit',
                                                          channelInterpretation: 'discrete',
                                                          numberOfOutputs: y.channelCount,
                                                      })
                                                  );
                                          let J = await Promise.all(
                                                  Array.from(v.parameters.values()).map(
                                                      async lt => {
                                                          let At = n(A, {
                                                              channelCount: 1,
                                                              channelCountMode: 'explicit',
                                                              channelInterpretation: 'discrete',
                                                              offset: lt.value,
                                                          });
                                                          return await d(A, lt, At.offset), At;
                                                      }
                                                  )
                                              ),
                                              R = o(A, {
                                                  channelCount: 1,
                                                  channelCountMode: 'explicit',
                                                  channelInterpretation: 'speakers',
                                                  numberOfInputs: Math.max(1, Y + V),
                                              });
                                          for (let lt = 0; lt < y.numberOfInputs; lt += 1) {
                                              L[lt].connect(U[lt]);
                                              for (let At = 0; At < y.channelCount; At += 1)
                                                  U[lt].connect(R, At, lt * y.channelCount + At);
                                          }
                                          for (let [lt, At] of J.entries())
                                              At.connect(R, 0, Y + lt), At.start(0);
                                          return (
                                              R.connect(A.destination),
                                              await Promise.all(L.map(lt => f(v, A, lt))),
                                              m(A)
                                          );
                                      })(),
                                b,
                                y,
                                D,
                                w,
                                u
                            );
                        }
                        let N = await k,
                            W = e(b, {
                                buffer: null,
                                channelCount: 2,
                                channelCountMode: 'max',
                                channelInterpretation: 'speakers',
                                loop: !1,
                                loopEnd: 0,
                                loopStart: 0,
                                playbackRate: 1,
                            }),
                            [q, Z, G] = F;
                        N !== null && ((W.buffer = N), W.start(0)), W.connect(q);
                        for (let Y = 0, V = 0; Y < v.numberOfOutputs; Y += 1) {
                            let C = Z[Y];
                            for (let I = 0; I < D[Y]; I += 1) q.connect(C, V + I, I);
                            V += D[Y];
                        }
                        return G;
                    }
                    if (E)
                        for (let [N, W] of v.parameters.entries())
                            await r(b, W, T.parameters.get(N));
                    else
                        for (let [N, W] of v.parameters.entries())
                            await d(b, W, T.parameters.get(N));
                    return await f(v, b, T), T;
                };
            return {
                render(v, b) {
                    a(b, v);
                    let T = O.get(b);
                    return T !== void 0 ? Promise.resolve(T) : x(v, b);
                },
            };
        };
    var Aa = (r, t, e, o, s, n, i, a, c, u, l, h, p, d, f, m, _, y, w, O) =>
        class extends f {
            constructor(x, v) {
                super(x, v);
                (this._nativeContext = x),
                    (this._audioWorklet =
                        r === void 0 ? void 0 : { addModule: (b, T) => r(this, b, T) });
            }
            get audioWorklet() {
                return this._audioWorklet;
            }
            createAnalyser() {
                return new t(this);
            }
            createBiquadFilter() {
                return new s(this);
            }
            createBuffer(x, v, b) {
                return new e({ length: v, numberOfChannels: x, sampleRate: b });
            }
            createBufferSource() {
                return new o(this);
            }
            createChannelMerger(x = 6) {
                return new n(this, { numberOfInputs: x });
            }
            createChannelSplitter(x = 6) {
                return new i(this, { numberOfOutputs: x });
            }
            createConstantSource() {
                return new a(this);
            }
            createConvolver() {
                return new c(this);
            }
            createDelay(x = 1) {
                return new l(this, { maxDelayTime: x });
            }
            createDynamicsCompressor() {
                return new h(this);
            }
            createGain() {
                return new p(this);
            }
            createIIRFilter(x, v) {
                return new d(this, { feedback: v, feedforward: x });
            }
            createOscillator() {
                return new m(this);
            }
            createPanner() {
                return new _(this);
            }
            createPeriodicWave(x, v, b = { disableNormalization: !1 }) {
                return new y(this, { ...b, imag: v, real: x });
            }
            createStereoPanner() {
                return new w(this);
            }
            createWaveShaper() {
                return new O(this);
            }
            decodeAudioData(x, v, b) {
                return u(this._nativeContext, x).then(
                    T => (typeof v == 'function' && v(T), T),
                    T => {
                        throw (typeof b == 'function' && b(T), T);
                    }
                );
            }
        };
    var mp = {
            Q: 1,
            channelCount: 2,
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            detune: 0,
            frequency: 350,
            gain: 0,
            type: 'lowpass',
        },
        Sa = (r, t, e, o, s, n, i, a) =>
            class extends r {
                constructor(u, l) {
                    let h = n(u),
                        p = { ...mp, ...l },
                        d = s(h, p),
                        f = i(h),
                        m = f ? e() : null;
                    super(u, !1, d, m);
                    (this._Q = t(this, f, d.Q, Tt, St)),
                        (this._detune = t(
                            this,
                            f,
                            d.detune,
                            1200 * Math.log2(Tt),
                            -1200 * Math.log2(Tt)
                        )),
                        (this._frequency = t(this, f, d.frequency, u.sampleRate / 2, 0)),
                        (this._gain = t(this, f, d.gain, 40 * Math.log10(Tt), St)),
                        (this._nativeBiquadFilterNode = d),
                        a(this, 1);
                }
                get detune() {
                    return this._detune;
                }
                get frequency() {
                    return this._frequency;
                }
                get gain() {
                    return this._gain;
                }
                get Q() {
                    return this._Q;
                }
                get type() {
                    return this._nativeBiquadFilterNode.type;
                }
                set type(u) {
                    this._nativeBiquadFilterNode.type = u;
                }
                getFrequencyResponse(u, l, h) {
                    try {
                        this._nativeBiquadFilterNode.getFrequencyResponse(u, l, h);
                    } catch (p) {
                        throw p.code === 11 ? o() : p;
                    }
                    if (u.length !== l.length || l.length !== h.length) throw o();
                }
            };
    var Ca = (r, t, e, o, s) => () => {
        let n = new WeakMap(),
            i = async (a, c) => {
                let u = e(a),
                    l = nt(u, c);
                if (!l) {
                    let h = {
                        Q: u.Q.value,
                        channelCount: u.channelCount,
                        channelCountMode: u.channelCountMode,
                        channelInterpretation: u.channelInterpretation,
                        detune: u.detune.value,
                        frequency: u.frequency.value,
                        gain: u.gain.value,
                        type: u.type,
                    };
                    u = t(c, h);
                }
                return (
                    n.set(c, u),
                    l
                        ? (await r(c, a.Q, u.Q),
                          await r(c, a.detune, u.detune),
                          await r(c, a.frequency, u.frequency),
                          await r(c, a.gain, u.gain))
                        : (await o(c, a.Q, u.Q),
                          await o(c, a.detune, u.detune),
                          await o(c, a.frequency, u.frequency),
                          await o(c, a.gain, u.gain)),
                    await s(a, c, u),
                    u
                );
            };
        return {
            render(a, c) {
                let u = n.get(c);
                return u !== void 0 ? Promise.resolve(u) : i(a, c);
            },
        };
    };
    var ka = (r, t) => (e, o) => {
        let s = t.get(e);
        if (s !== void 0) return s;
        let n = r.get(e);
        if (n !== void 0) return n;
        try {
            let i = o();
            return i instanceof Promise
                ? (r.set(e, i), i.catch(() => !1).then(a => (r.delete(e), t.set(e, a), a)))
                : (t.set(e, i), i);
        } catch {
            return t.set(e, !1), !1;
        }
    };
    var gp = {
            channelCount: 1,
            channelCountMode: 'explicit',
            channelInterpretation: 'speakers',
            numberOfInputs: 6,
        },
        Na = (r, t, e, o, s) =>
            class extends r {
                constructor(i, a) {
                    let c = o(i),
                        u = { ...gp, ...a },
                        l = e(c, u),
                        h = s(c) ? t() : null;
                    super(i, !1, l, h);
                }
            };
    var Oa = (r, t, e) => () => {
        let o = new WeakMap(),
            s = async (n, i) => {
                let a = t(n);
                if (!nt(a, i)) {
                    let u = {
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        numberOfInputs: a.numberOfInputs,
                    };
                    a = r(i, u);
                }
                return o.set(i, a), await e(n, i, a), a;
            };
        return {
            render(n, i) {
                let a = o.get(i);
                return a !== void 0 ? Promise.resolve(a) : s(n, i);
            },
        };
    };
    var _p = {
            channelCount: 6,
            channelCountMode: 'explicit',
            channelInterpretation: 'discrete',
            numberOfOutputs: 6,
        },
        Da = (r, t, e, o, s, n) =>
            class extends r {
                constructor(a, c) {
                    let u = o(a),
                        l = n({ ..._p, ...c }),
                        h = e(u, l),
                        p = s(u) ? t() : null;
                    super(a, !1, h, p);
                }
            };
    var Ea = (r, t, e) => () => {
        let o = new WeakMap(),
            s = async (n, i) => {
                let a = t(n);
                if (!nt(a, i)) {
                    let u = {
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        numberOfOutputs: a.numberOfOutputs,
                    };
                    a = r(i, u);
                }
                return o.set(i, a), await e(n, i, a), a;
            };
        return {
            render(n, i) {
                let a = o.get(i);
                return a !== void 0 ? Promise.resolve(a) : s(n, i);
            },
        };
    };
    var Ma = r => (t, e, o) => r(e, t, o);
    var Fa =
        r =>
        (t, e, o = 0, s = 0) => {
            let n = t[o];
            if (n === void 0) throw r();
            return bo(e) ? n.connect(e, 0, s) : n.connect(e, 0);
        };
    var Ia = r => (t, e) => {
        let o = r(t, {
                buffer: null,
                channelCount: 2,
                channelCountMode: 'max',
                channelInterpretation: 'speakers',
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                playbackRate: 1,
            }),
            s = t.createBuffer(1, 2, 44100);
        return (
            (o.buffer = s),
            (o.loop = !0),
            o.connect(e),
            o.start(),
            () => {
                o.stop(), o.disconnect(e);
            }
        );
    };
    var xp = {
            channelCount: 2,
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            offset: 1,
        },
        Ra = (r, t, e, o, s, n, i) =>
            class extends r {
                constructor(c, u) {
                    let l = s(c),
                        h = { ...xp, ...u },
                        p = o(l, h),
                        d = n(l),
                        f = d ? e() : null;
                    super(c, !1, p, f);
                    (this._constantSourceNodeRenderer = f),
                        (this._nativeConstantSourceNode = p),
                        (this._offset = t(this, d, p.offset, Tt, St)),
                        (this._onended = null);
                }
                get offset() {
                    return this._offset;
                }
                get onended() {
                    return this._onended;
                }
                set onended(c) {
                    let u = typeof c == 'function' ? i(this, c) : null;
                    this._nativeConstantSourceNode.onended = u;
                    let l = this._nativeConstantSourceNode.onended;
                    this._onended = l !== null && l === u ? c : l;
                }
                start(c = 0) {
                    if (
                        (this._nativeConstantSourceNode.start(c),
                        this._constantSourceNodeRenderer !== null &&
                            (this._constantSourceNodeRenderer.start = c),
                        this.context.state !== 'closed')
                    ) {
                        ye(this);
                        let u = () => {
                            this._nativeConstantSourceNode.removeEventListener('ended', u),
                                Kt(this) && Re(this);
                        };
                        this._nativeConstantSourceNode.addEventListener('ended', u);
                    }
                }
                stop(c = 0) {
                    this._nativeConstantSourceNode.stop(c),
                        this._constantSourceNodeRenderer !== null &&
                            (this._constantSourceNodeRenderer.stop = c);
                }
            };
    var Pa = (r, t, e, o, s) => () => {
        let n = new WeakMap(),
            i = null,
            a = null,
            c = async (u, l) => {
                let h = e(u),
                    p = nt(h, l);
                if (!p) {
                    let d = {
                        channelCount: h.channelCount,
                        channelCountMode: h.channelCountMode,
                        channelInterpretation: h.channelInterpretation,
                        offset: h.offset.value,
                    };
                    (h = t(l, d)), i !== null && h.start(i), a !== null && h.stop(a);
                }
                return (
                    n.set(l, h),
                    p ? await r(l, u.offset, h.offset) : await o(l, u.offset, h.offset),
                    await s(u, l, h),
                    h
                );
            };
        return {
            set start(u) {
                i = u;
            },
            set stop(u) {
                a = u;
            },
            render(u, l) {
                let h = n.get(l);
                return h !== void 0 ? Promise.resolve(h) : c(u, l);
            },
        };
    };
    var qa = r => t => (r[0] = t), r[0];
    var yp = {
            buffer: null,
            channelCount: 2,
            channelCountMode: 'clamped-max',
            channelInterpretation: 'speakers',
            disableNormalization: !1,
        },
        Va = (r, t, e, o, s, n) =>
            class extends r {
                constructor(a, c) {
                    let u = o(a),
                        l = { ...yp, ...c },
                        h = e(u, l),
                        d = s(u) ? t() : null;
                    super(a, !1, h, d);
                    (this._isBufferNullified = !1),
                        (this._nativeConvolverNode = h),
                        l.buffer !== null && n(this, l.buffer.duration);
                }
                get buffer() {
                    return this._isBufferNullified ? null : this._nativeConvolverNode.buffer;
                }
                set buffer(a) {
                    if (
                        ((this._nativeConvolverNode.buffer = a),
                        a === null && this._nativeConvolverNode.buffer !== null)
                    ) {
                        let c = this._nativeConvolverNode.context;
                        (this._nativeConvolverNode.buffer = c.createBuffer(1, 1, 44100)),
                            (this._isBufferNullified = !0),
                            n(this, 0);
                    } else
                        (this._isBufferNullified = !1),
                            n(
                                this,
                                this._nativeConvolverNode.buffer === null
                                    ? 0
                                    : this._nativeConvolverNode.buffer.duration
                            );
                }
                get normalize() {
                    return this._nativeConvolverNode.normalize;
                }
                set normalize(a) {
                    this._nativeConvolverNode.normalize = a;
                }
            };
    var La = (r, t, e) => () => {
        let o = new WeakMap(),
            s = async (n, i) => {
                let a = t(n);
                if (!nt(a, i)) {
                    let u = {
                        buffer: a.buffer,
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        disableNormalization: !a.normalize,
                    };
                    a = r(i, u);
                }
                return o.set(i, a), pe(a) ? await e(n, i, a.inputs[0]) : await e(n, i, a), a;
            };
        return {
            render(n, i) {
                let a = o.get(i);
                return a !== void 0 ? Promise.resolve(a) : s(n, i);
            },
        };
    };
    var Wa = (r, t) => (e, o, s) => {
        if (t === null) throw new Error('Missing the native OfflineAudioContext constructor.');
        try {
            return new t(e, o, s);
        } catch (n) {
            throw n.name === 'SyntaxError' ? r() : n;
        }
    };
    var Ba = () => new DOMException('', 'DataCloneError');
    var kn = r => {
        let { port1: t, port2: e } = new MessageChannel();
        return new Promise(o => {
            let s = () => {
                (e.onmessage = null), t.close(), e.close(), o();
            };
            e.onmessage = () => s();
            try {
                t.postMessage(r, [r]);
            } finally {
                s();
            }
        });
    };
    var ja = (r, t, e, o, s, n, i, a, c, u, l) => (h, p) => {
        let d = i(h) ? h : n(h);
        if (s.has(p)) {
            let f = e();
            return Promise.reject(f);
        }
        try {
            s.add(p);
        } catch {}
        return t(c, () => c(d))
            ? d
                  .decodeAudioData(p)
                  .then(f => (kn(p).catch(() => {}), t(a, () => a(f)) || l(f), r.add(f), f))
            : new Promise((f, m) => {
                  let _ = async () => {
                          try {
                              await kn(p);
                          } catch {}
                      },
                      y = w => {
                          m(w), _();
                      };
                  try {
                      d.decodeAudioData(
                          p,
                          w => {
                              typeof w.copyFromChannel != 'function' && (u(w), Zo(w)),
                                  r.add(w),
                                  _().then(() => f(w));
                          },
                          w => {
                              y(w === null ? o() : w);
                          }
                      );
                  } catch (w) {
                      y(w);
                  }
              });
    };
    var Ga = (r, t, e, o, s, n, i, a) => (c, u) => {
        let l = t.get(c);
        if (l === void 0) throw new Error('Missing the expected cycle count.');
        let h = n(c.context),
            p = a(h);
        if (l === u) {
            if ((t.delete(c), !p && i(c))) {
                let d = o(c),
                    { outputs: f } = e(c);
                for (let m of f)
                    if (co(m)) {
                        let _ = o(m[0]);
                        r(d, _, m[1], m[2]);
                    } else {
                        let _ = s(m[0]);
                        d.connect(_, m[1]);
                    }
            }
        } else t.set(c, l - u);
    };
    var vp = {
            channelCount: 2,
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            delayTime: 0,
            maxDelayTime: 1,
        },
        za = (r, t, e, o, s, n, i) =>
            class extends r {
                constructor(c, u) {
                    let l = s(c),
                        h = { ...vp, ...u },
                        p = o(l, h),
                        d = n(l),
                        f = d ? e(h.maxDelayTime) : null;
                    super(c, !1, p, f);
                    (this._delayTime = t(this, d, p.delayTime)), i(this, h.maxDelayTime);
                }
                get delayTime() {
                    return this._delayTime;
                }
            };
    var Ua = (r, t, e, o, s) => n => {
        let i = new WeakMap(),
            a = async (c, u) => {
                let l = e(c),
                    h = nt(l, u);
                if (!h) {
                    let p = {
                        channelCount: l.channelCount,
                        channelCountMode: l.channelCountMode,
                        channelInterpretation: l.channelInterpretation,
                        delayTime: l.delayTime.value,
                        maxDelayTime: n,
                    };
                    l = t(u, p);
                }
                return (
                    i.set(u, l),
                    h ? await r(u, c.delayTime, l.delayTime) : await o(u, c.delayTime, l.delayTime),
                    await s(c, u, l),
                    l
                );
            };
        return {
            render(c, u) {
                let l = i.get(u);
                return l !== void 0 ? Promise.resolve(l) : a(c, u);
            },
        };
    };
    var Ya = r => (t, e, o, s) => r(t[s], n => n[0] === e && n[1] === o);
    var Ha = r => (t, e) => {
        r(t).delete(e);
    };
    var Xa = r => 'delayTime' in r;
    var Qa = (r, t, e) =>
        function o(s, n) {
            let i = vo(n) ? n : e(r, n);
            if (Xa(i)) return [];
            if (s[0] === i) return [s];
            if (s.includes(i)) return [];
            let { outputs: a } = t(i);
            return Array.from(a)
                .map(c => o([...s, i], c[0]))
                .reduce((c, u) => c.concat(u), []);
        };
    var Fs = (r, t, e) => {
            let o = t[e];
            if (o === void 0) throw r();
            return o;
        },
        Za =
            r =>
            (t, e = void 0, o = void 0, s = 0) =>
                e === void 0
                    ? t.forEach(n => n.disconnect())
                    : typeof e == 'number'
                    ? Fs(r, t, e).disconnect()
                    : bo(e)
                    ? o === void 0
                        ? t.forEach(n => n.disconnect(e))
                        : s === void 0
                        ? Fs(r, t, o).disconnect(e, 0)
                        : Fs(r, t, o).disconnect(e, 0, s)
                    : o === void 0
                    ? t.forEach(n => n.disconnect(e))
                    : Fs(r, t, o).disconnect(e, 0);
    var wp = {
            attack: 0.003,
            channelCount: 2,
            channelCountMode: 'clamped-max',
            channelInterpretation: 'speakers',
            knee: 30,
            ratio: 12,
            release: 0.25,
            threshold: -24,
        },
        $a = (r, t, e, o, s, n, i, a) =>
            class extends r {
                constructor(u, l) {
                    let h = n(u),
                        p = { ...wp, ...l },
                        d = o(h, p),
                        f = i(h),
                        m = f ? e() : null;
                    super(u, !1, d, m);
                    (this._attack = t(this, f, d.attack)),
                        (this._knee = t(this, f, d.knee)),
                        (this._nativeDynamicsCompressorNode = d),
                        (this._ratio = t(this, f, d.ratio)),
                        (this._release = t(this, f, d.release)),
                        (this._threshold = t(this, f, d.threshold)),
                        a(this, 0.006);
                }
                get attack() {
                    return this._attack;
                }
                get channelCount() {
                    return this._nativeDynamicsCompressorNode.channelCount;
                }
                set channelCount(u) {
                    let l = this._nativeDynamicsCompressorNode.channelCount;
                    if (((this._nativeDynamicsCompressorNode.channelCount = u), u > 2))
                        throw ((this._nativeDynamicsCompressorNode.channelCount = l), s());
                }
                get channelCountMode() {
                    return this._nativeDynamicsCompressorNode.channelCountMode;
                }
                set channelCountMode(u) {
                    let l = this._nativeDynamicsCompressorNode.channelCountMode;
                    if (((this._nativeDynamicsCompressorNode.channelCountMode = u), u === 'max'))
                        throw ((this._nativeDynamicsCompressorNode.channelCountMode = l), s());
                }
                get knee() {
                    return this._knee;
                }
                get ratio() {
                    return this._ratio;
                }
                get reduction() {
                    return typeof this._nativeDynamicsCompressorNode.reduction.value == 'number'
                        ? this._nativeDynamicsCompressorNode.reduction.value
                        : this._nativeDynamicsCompressorNode.reduction;
                }
                get release() {
                    return this._release;
                }
                get threshold() {
                    return this._threshold;
                }
            };
    var Ka = (r, t, e, o, s) => () => {
        let n = new WeakMap(),
            i = async (a, c) => {
                let u = e(a),
                    l = nt(u, c);
                if (!l) {
                    let h = {
                        attack: u.attack.value,
                        channelCount: u.channelCount,
                        channelCountMode: u.channelCountMode,
                        channelInterpretation: u.channelInterpretation,
                        knee: u.knee.value,
                        ratio: u.ratio.value,
                        release: u.release.value,
                        threshold: u.threshold.value,
                    };
                    u = t(c, h);
                }
                return (
                    n.set(c, u),
                    l
                        ? (await r(c, a.attack, u.attack),
                          await r(c, a.knee, u.knee),
                          await r(c, a.ratio, u.ratio),
                          await r(c, a.release, u.release),
                          await r(c, a.threshold, u.threshold))
                        : (await o(c, a.attack, u.attack),
                          await o(c, a.knee, u.knee),
                          await o(c, a.ratio, u.ratio),
                          await o(c, a.release, u.release),
                          await o(c, a.threshold, u.threshold)),
                    await s(a, c, u),
                    u
                );
            };
        return {
            render(a, c) {
                let u = n.get(c);
                return u !== void 0 ? Promise.resolve(u) : i(a, c);
            },
        };
    };
    var Ja = () => new DOMException('', 'EncodingError');
    var tc = r => t =>
        new Promise((e, o) => {
            if (r === null) {
                o(new SyntaxError());
                return;
            }
            let s = r.document.head;
            if (s === null) o(new SyntaxError());
            else {
                let n = r.document.createElement('script'),
                    i = new Blob([t], { type: 'application/javascript' }),
                    a = URL.createObjectURL(i),
                    c = r.onerror,
                    u = () => {
                        (r.onerror = c), URL.revokeObjectURL(a);
                    };
                (r.onerror = (l, h, p, d, f) => {
                    if (h === a || (h === r.location.href && p === 1 && d === 1))
                        return u(), o(f), !1;
                    if (c !== null) return c(l, h, p, d, f);
                }),
                    (n.onerror = () => {
                        u(), o(new SyntaxError());
                    }),
                    (n.onload = () => {
                        u(), e();
                    }),
                    (n.src = a),
                    (n.type = 'module'),
                    s.appendChild(n);
            }
        });
    var ec = r =>
        class {
            constructor(e) {
                (this._nativeEventTarget = e), (this._listeners = new WeakMap());
            }
            addEventListener(e, o, s) {
                if (o !== null) {
                    let n = this._listeners.get(o);
                    n === void 0 &&
                        ((n = r(this, o)), typeof o == 'function' && this._listeners.set(o, n)),
                        this._nativeEventTarget.addEventListener(e, n, s);
                }
            }
            dispatchEvent(e) {
                return this._nativeEventTarget.dispatchEvent(e);
            }
            removeEventListener(e, o, s) {
                let n = o === null ? void 0 : this._listeners.get(o);
                this._nativeEventTarget.removeEventListener(e, n === void 0 ? null : n, s);
            }
        };
    var oc = r => (t, e, o) => {
        Object.defineProperties(r, {
            currentFrame: {
                configurable: !0,
                get() {
                    return Math.round(t * e);
                },
            },
            currentTime: {
                configurable: !0,
                get() {
                    return t;
                },
            },
        });
        try {
            return o();
        } finally {
            r !== null && (delete r.currentFrame, delete r.currentTime);
        }
    };
    var rc = r => async t => {
        try {
            let e = await fetch(t);
            if (e.ok) return [await e.text(), e.url];
        } catch {}
        throw r();
    };
    var bp = {
            channelCount: 2,
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            gain: 1,
        },
        sc = (r, t, e, o, s, n) =>
            class extends r {
                constructor(a, c) {
                    let u = s(a),
                        l = { ...bp, ...c },
                        h = o(u, l),
                        p = n(u),
                        d = p ? e() : null;
                    super(a, !1, h, d);
                    this._gain = t(this, p, h.gain, Tt, St);
                }
                get gain() {
                    return this._gain;
                }
            };
    var nc = (r, t, e, o, s) => () => {
        let n = new WeakMap(),
            i = async (a, c) => {
                let u = e(a),
                    l = nt(u, c);
                if (!l) {
                    let h = {
                        channelCount: u.channelCount,
                        channelCountMode: u.channelCountMode,
                        channelInterpretation: u.channelInterpretation,
                        gain: u.gain.value,
                    };
                    u = t(c, h);
                }
                return (
                    n.set(c, u),
                    l ? await r(c, a.gain, u.gain) : await o(c, a.gain, u.gain),
                    await s(a, c, u),
                    u
                );
            };
        return {
            render(a, c) {
                let u = n.get(c);
                return u !== void 0 ? Promise.resolve(u) : i(a, c);
            },
        };
    };
    var ic = (r, t) => e => t(r, e);
    var ac = r => t => {
        let e = r(t);
        if (e.renderer === null)
            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');
        return e.renderer;
    };
    var cc = r => t => {
        var e;
        return (e = r.get(t)) !== null && e !== void 0 ? e : 0;
    };
    var uc = r => t => {
        let e = r(t);
        if (e.renderer === null)
            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');
        return e.renderer;
    };
    var lc = r => t => r.get(t);
    var gt = () => new DOMException('', 'InvalidStateError');
    var hc = r => t => {
        let e = r.get(t);
        if (e === void 0) throw gt();
        return e;
    };
    var pc = (r, t) => e => {
        let o = r.get(e);
        if (o !== void 0) return o;
        if (t === null) throw new Error('Missing the native OfflineAudioContext constructor.');
        return (o = new t(1, 1, 44100)), r.set(e, o), o;
    };
    var dc = r => t => {
        let e = r.get(t);
        if (e === void 0) throw new Error('The context has no set of AudioWorkletNodes.');
        return e;
    };
    var or = () => new DOMException('', 'InvalidAccessError');
    var fc = r => {
        r.getFrequencyResponse = (t => (e, o, s) => {
            if (e.length !== o.length || o.length !== s.length) throw or();
            return t.call(r, e, o, s);
        })(r.getFrequencyResponse);
    };
    var Tp = { channelCount: 2, channelCountMode: 'max', channelInterpretation: 'speakers' },
        mc = (r, t, e, o, s, n) =>
            class extends r {
                constructor(a, c) {
                    let u = o(a),
                        l = s(u),
                        h = { ...Tp, ...c },
                        p = t(u, l ? null : a.baseLatency, h),
                        d = l ? e(h.feedback, h.feedforward) : null;
                    super(a, !1, p, d);
                    fc(p), (this._nativeIIRFilterNode = p), n(this, 1);
                }
                getFrequencyResponse(a, c, u) {
                    return this._nativeIIRFilterNode.getFrequencyResponse(a, c, u);
                }
            };
    var Is = (r, t, e, o, s, n, i, a, c, u, l) => {
        let h = u.length,
            p = a;
        for (let d = 0; d < h; d += 1) {
            let f = e[0] * u[d];
            for (let m = 1; m < s; m += 1) {
                let _ = (p - m) & (c - 1);
                (f += e[m] * n[_]), (f -= r[m] * i[_]);
            }
            for (let m = s; m < o; m += 1) f += e[m] * n[(p - m) & (c - 1)];
            for (let m = s; m < t; m += 1) f -= r[m] * i[(p - m) & (c - 1)];
            (n[p] = u[d]), (i[p] = f), (p = (p + 1) & (c - 1)), (l[d] = f);
        }
        return p;
    };
    var Ap = (r, t, e, o) => {
            let s = e instanceof Float64Array ? e : new Float64Array(e),
                n = o instanceof Float64Array ? o : new Float64Array(o),
                i = s.length,
                a = n.length,
                c = Math.min(i, a);
            if (s[0] !== 1) {
                for (let f = 0; f < i; f += 1) n[f] /= s[0];
                for (let f = 1; f < a; f += 1) s[f] /= s[0];
            }
            let u = 32,
                l = new Float32Array(u),
                h = new Float32Array(u),
                p = t.createBuffer(r.numberOfChannels, r.length, r.sampleRate),
                d = r.numberOfChannels;
            for (let f = 0; f < d; f += 1) {
                let m = r.getChannelData(f),
                    _ = p.getChannelData(f);
                l.fill(0), h.fill(0), Is(s, i, n, a, c, l, h, 0, u, m, _);
            }
            return p;
        },
        gc = (r, t, e, o, s) => (n, i) => {
            let a = new WeakMap(),
                c = null,
                u = async (l, h) => {
                    let p = null,
                        d = t(l),
                        f = nt(d, h);
                    if (
                        (h.createIIRFilter === void 0
                            ? (p = r(h, {
                                  buffer: null,
                                  channelCount: 2,
                                  channelCountMode: 'max',
                                  channelInterpretation: 'speakers',
                                  loop: !1,
                                  loopEnd: 0,
                                  loopStart: 0,
                                  playbackRate: 1,
                              }))
                            : f || (d = h.createIIRFilter(i, n)),
                        a.set(h, p === null ? d : p),
                        p !== null)
                    ) {
                        if (c === null) {
                            if (e === null)
                                throw new Error(
                                    'Missing the native OfflineAudioContext constructor.'
                                );
                            let _ = new e(
                                l.context.destination.channelCount,
                                l.context.length,
                                h.sampleRate
                            );
                            c = (async () => {
                                await o(l, _, _.destination);
                                let y = await s(_);
                                return Ap(y, h, n, i);
                            })();
                        }
                        let m = await c;
                        return (p.buffer = m), p.start(0), p;
                    }
                    return await o(l, h, d), d;
                };
            return {
                render(l, h) {
                    let p = a.get(h);
                    return p !== void 0 ? Promise.resolve(p) : u(l, h);
                },
            };
        };
    var _c = (r, t, e, o, s, n) => i => (a, c) => {
        let u = r.get(a);
        if (u === void 0) {
            if (!i && n(a)) {
                let l = o(a),
                    { outputs: h } = e(a);
                for (let p of h)
                    if (co(p)) {
                        let d = o(p[0]);
                        t(l, d, p[1], p[2]);
                    } else {
                        let d = s(p[0]);
                        l.disconnect(d, p[1]);
                    }
            }
            r.set(a, c);
        } else r.set(a, u + c);
    };
    var xc = (r, t) => e => {
        let o = r.get(e);
        return t(o) || t(e);
    };
    var yc = (r, t) => e => r.has(e) || t(e);
    var vc = (r, t) => e => r.has(e) || t(e);
    var wc = (r, t) => e => {
        let o = r.get(e);
        return t(o) || t(e);
    };
    var bc = r => t => r !== null && t instanceof r;
    var Tc = r => t => r !== null && typeof r.AudioNode == 'function' && t instanceof r.AudioNode;
    var Ac = r => t => r !== null && typeof r.AudioParam == 'function' && t instanceof r.AudioParam;
    var Sc = (r, t) => e => r(e) || t(e);
    var Cc = r => t => r !== null && t instanceof r;
    var kc = r => r !== null && r.isSecureContext;
    var Nc = (r, t, e, o) =>
        class extends r {
            constructor(n, i) {
                let a = e(n),
                    c = t(a, i);
                if (o(a)) throw TypeError();
                super(n, !0, c, null);
                this._nativeMediaElementAudioSourceNode = c;
            }
            get mediaElement() {
                return this._nativeMediaElementAudioSourceNode.mediaElement;
            }
        };
    var Sp = { channelCount: 2, channelCountMode: 'explicit', channelInterpretation: 'speakers' },
        Oc = (r, t, e, o) =>
            class extends r {
                constructor(n, i) {
                    let a = e(n);
                    if (o(a)) throw new TypeError();
                    let c = { ...Sp, ...i },
                        u = t(a, c);
                    super(n, !1, u, null);
                    this._nativeMediaStreamAudioDestinationNode = u;
                }
                get stream() {
                    return this._nativeMediaStreamAudioDestinationNode.stream;
                }
            };
    var Dc = (r, t, e, o) =>
        class extends r {
            constructor(n, i) {
                let a = e(n),
                    c = t(a, i);
                if (o(a)) throw new TypeError();
                super(n, !0, c, null);
                this._nativeMediaStreamAudioSourceNode = c;
            }
            get mediaStream() {
                return this._nativeMediaStreamAudioSourceNode.mediaStream;
            }
        };
    var Ec = (r, t, e) =>
        class extends r {
            constructor(s, n) {
                let i = e(s),
                    a = t(i, n);
                super(s, !0, a, null);
            }
        };
    var Mc = (r, t, e, o, s) =>
        class extends o {
            constructor(i = {}) {
                if (s === null) throw new Error('Missing the native AudioContext constructor.');
                let a;
                try {
                    a = new s(i);
                } catch (l) {
                    throw l.code === 12 && l.message === 'sampleRate is not in range' ? t() : l;
                }
                if (a === null) throw e();
                if (!Ds(i.latencyHint))
                    throw new TypeError(
                        `The provided value '${i.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`
                    );
                if (i.sampleRate !== void 0 && a.sampleRate !== i.sampleRate) throw t();
                super(a, 2);
                let { latencyHint: c } = i,
                    { sampleRate: u } = a;
                if (
                    ((this._baseLatency =
                        typeof a.baseLatency == 'number'
                            ? a.baseLatency
                            : c === 'balanced'
                            ? 512 / u
                            : c === 'interactive' || c === void 0
                            ? 256 / u
                            : c === 'playback'
                            ? 1024 / u
                            : (Math.max(2, Math.min(128, Math.round((c * u) / 128))) * 128) / u),
                    (this._nativeAudioContext = a),
                    s.name === 'webkitAudioContext'
                        ? ((this._nativeGainNode = a.createGain()),
                          (this._nativeOscillatorNode = a.createOscillator()),
                          (this._nativeGainNode.gain.value = 1e-37),
                          this._nativeOscillatorNode
                              .connect(this._nativeGainNode)
                              .connect(a.destination),
                          this._nativeOscillatorNode.start())
                        : ((this._nativeGainNode = null), (this._nativeOscillatorNode = null)),
                    (this._state = null),
                    a.state === 'running')
                ) {
                    this._state = 'suspended';
                    let l = () => {
                        this._state === 'suspended' && (this._state = null),
                            a.removeEventListener('statechange', l);
                    };
                    a.addEventListener('statechange', l);
                }
            }
            get baseLatency() {
                return this._baseLatency;
            }
            get state() {
                return this._state !== null ? this._state : this._nativeAudioContext.state;
            }
            close() {
                return this.state === 'closed'
                    ? this._nativeAudioContext.close().then(() => {
                          throw r();
                      })
                    : (this._state === 'suspended' && (this._state = null),
                      this._nativeAudioContext.close().then(() => {
                          this._nativeGainNode !== null &&
                              this._nativeOscillatorNode !== null &&
                              (this._nativeOscillatorNode.stop(),
                              this._nativeGainNode.disconnect(),
                              this._nativeOscillatorNode.disconnect()),
                              ao(this);
                      }));
            }
            resume() {
                return this._state === 'suspended'
                    ? new Promise((i, a) => {
                          let c = () => {
                              this._nativeAudioContext.removeEventListener('statechange', c),
                                  this._nativeAudioContext.state === 'running'
                                      ? i()
                                      : this.resume().then(i, a);
                          };
                          this._nativeAudioContext.addEventListener('statechange', c);
                      })
                    : this._nativeAudioContext.resume().catch(i => {
                          throw i === void 0 || i.code === 15 ? r() : i;
                      });
            }
            suspend() {
                return this._nativeAudioContext.suspend().catch(i => {
                    throw i === void 0 ? r() : i;
                });
            }
        };
    var Fc = (r, t, e, o, s, n) =>
        class extends e {
            constructor(a, c) {
                super(a);
                (this._nativeContext = a),
                    Xo.set(this, a),
                    o(a) && s.set(a, new Set()),
                    (this._destination = new r(this, c)),
                    (this._listener = t(this, a)),
                    (this._onstatechange = null);
            }
            get currentTime() {
                return this._nativeContext.currentTime;
            }
            get destination() {
                return this._destination;
            }
            get listener() {
                return this._listener;
            }
            get onstatechange() {
                return this._onstatechange;
            }
            set onstatechange(a) {
                let c = typeof a == 'function' ? n(this, a) : null;
                this._nativeContext.onstatechange = c;
                let u = this._nativeContext.onstatechange;
                this._onstatechange = u !== null && u === c ? a : u;
            }
            get sampleRate() {
                return this._nativeContext.sampleRate;
            }
            get state() {
                return this._nativeContext.state;
            }
        };
    var we = r => {
        let t = new Uint32Array([
            1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060,
            4, 0,
        ]);
        try {
            let e = r.decodeAudioData(t.buffer, () => {});
            return e === void 0 ? !1 : (e.catch(() => {}), !0);
        } catch {}
        return !1;
    };
    var Cp = { numberOfChannels: 1 },
        Ic = (r, t, e, o, s) =>
            class extends o {
                constructor(i) {
                    let { length: a, numberOfChannels: c, sampleRate: u } = { ...Cp, ...i },
                        l = e(c, a, u);
                    r(we, () => we(l)) ||
                        l.addEventListener(
                            'statechange',
                            (() => {
                                let h = 0,
                                    p = d => {
                                        this._state === 'running' &&
                                            (h > 0
                                                ? (l.removeEventListener('statechange', p),
                                                  d.stopImmediatePropagation(),
                                                  this._waitForThePromiseToSettle(d))
                                                : (h += 1));
                                    };
                                return p;
                            })()
                        );
                    super(l, c);
                    (this._length = a), (this._nativeOfflineAudioContext = l), (this._state = null);
                }
                get length() {
                    return this._nativeOfflineAudioContext.length === void 0
                        ? this._length
                        : this._nativeOfflineAudioContext.length;
                }
                get state() {
                    return this._state === null
                        ? this._nativeOfflineAudioContext.state
                        : this._state;
                }
                startRendering() {
                    return this._state === 'running'
                        ? Promise.reject(t())
                        : ((this._state = 'running'),
                          s(this.destination, this._nativeOfflineAudioContext).finally(() => {
                              (this._state = null), ao(this);
                          }));
                }
                _waitForThePromiseToSettle(i) {
                    this._state === null
                        ? this._nativeOfflineAudioContext.dispatchEvent(i)
                        : setTimeout(() => this._waitForThePromiseToSettle(i));
                }
            };
    var Rc = (r, t) => (e, o, s) => {
        let n = new Set();
        return (
            (e.connect = (
                i =>
                (a, c = 0, u = 0) => {
                    let l = n.size === 0;
                    if (t(a))
                        return (
                            i.call(e, a, c, u),
                            r(n, [a, c, u], h => h[0] === a && h[1] === c && h[2] === u, !0),
                            l && o(),
                            a
                        );
                    i.call(e, a, c), r(n, [a, c], h => h[0] === a && h[1] === c, !0), l && o();
                }
            )(e.connect)),
            (e.disconnect = (i => (a, c, u) => {
                let l = n.size > 0;
                if (a === void 0) i.apply(e), n.clear();
                else if (typeof a == 'number') {
                    i.call(e, a);
                    for (let p of n) p[1] === a && n.delete(p);
                } else {
                    t(a) ? i.call(e, a, c, u) : i.call(e, a, c);
                    for (let p of n)
                        p[0] === a &&
                            (c === void 0 || p[1] === c) &&
                            (u === void 0 || p[2] === u) &&
                            n.delete(p);
                }
                let h = n.size === 0;
                l && h && s();
            })(e.disconnect)),
            e
        );
    };
    var it = (r, t, e) => {
        let o = t[e];
        o !== void 0 && o !== r[e] && (r[e] = o);
    };
    var rt = (r, t) => {
        it(r, t, 'channelCount'), it(r, t, 'channelCountMode'), it(r, t, 'channelInterpretation');
    };
    var Nn = r => typeof r.getFloatTimeDomainData == 'function';
    var Pc = r => {
        r.getFloatTimeDomainData = t => {
            let e = new Uint8Array(t.length);
            r.getByteTimeDomainData(e);
            let o = Math.max(e.length, r.fftSize);
            for (let s = 0; s < o; s += 1) t[s] = (e[s] - 128) * 0.0078125;
            return t;
        };
    };
    var qc = (r, t) => (e, o) => {
        let s = e.createAnalyser();
        if ((rt(s, o), !(o.maxDecibels > o.minDecibels))) throw t();
        return (
            it(s, o, 'fftSize'),
            it(s, o, 'maxDecibels'),
            it(s, o, 'minDecibels'),
            it(s, o, 'smoothingTimeConstant'),
            r(Nn, () => Nn(s)) || Pc(s),
            s
        );
    };
    var Vc = r => (r === null ? null : r.hasOwnProperty('AudioBuffer') ? r.AudioBuffer : null);
    var ut = (r, t, e) => {
        let o = t[e];
        o !== void 0 && o !== r[e].value && (r[e].value = o);
    };
    var Lc = r => {
        r.start = (t => {
            let e = !1;
            return (o = 0, s = 0, n) => {
                if (e) throw gt();
                t.call(r, o, s, n), (e = !0);
            };
        })(r.start);
    };
    var rr = r => {
        r.start = (
            t =>
            (e = 0, o = 0, s) => {
                if ((typeof s == 'number' && s < 0) || o < 0 || e < 0)
                    throw new RangeError("The parameters can't be negative.");
                t.call(r, e, o, s);
            }
        )(r.start);
    };
    var sr = r => {
        r.stop = (
            t =>
            (e = 0) => {
                if (e < 0) throw new RangeError("The parameter can't be negative.");
                t.call(r, e);
            }
        )(r.stop);
    };
    var Wc = (r, t, e, o, s, n, i, a, c, u, l) => (h, p) => {
        let d = h.createBufferSource();
        return (
            rt(d, p),
            ut(d, p, 'playbackRate'),
            it(d, p, 'buffer'),
            it(d, p, 'loop'),
            it(d, p, 'loopEnd'),
            it(d, p, 'loopStart'),
            t(e, () => e(h)) || Lc(d),
            t(o, () => o(h)) || c(d),
            t(s, () => s(h)) || u(d, h),
            t(n, () => n(h)) || rr(d),
            t(i, () => i(h)) || l(d, h),
            t(a, () => a(h)) || sr(d),
            r(h, d),
            d
        );
    };
    var Bc = r =>
        r === null
            ? null
            : r.hasOwnProperty('AudioContext')
            ? r.AudioContext
            : r.hasOwnProperty('webkitAudioContext')
            ? r.webkitAudioContext
            : null;
    var jc = (r, t) => (e, o, s) => {
        let n = e.destination;
        if (n.channelCount !== o)
            try {
                n.channelCount = o;
            } catch {}
        s && n.channelCountMode !== 'explicit' && (n.channelCountMode = 'explicit'),
            n.maxChannelCount === 0 && Object.defineProperty(n, 'maxChannelCount', { value: o });
        let i = r(e, {
            channelCount: o,
            channelCountMode: n.channelCountMode,
            channelInterpretation: n.channelInterpretation,
            gain: 1,
        });
        return (
            t(
                i,
                'channelCount',
                a => () => a.call(i),
                a => c => {
                    a.call(i, c);
                    try {
                        n.channelCount = c;
                    } catch (u) {
                        if (c > n.maxChannelCount) throw u;
                    }
                }
            ),
            t(
                i,
                'channelCountMode',
                a => () => a.call(i),
                a => c => {
                    a.call(i, c), (n.channelCountMode = c);
                }
            ),
            t(
                i,
                'channelInterpretation',
                a => () => a.call(i),
                a => c => {
                    a.call(i, c), (n.channelInterpretation = c);
                }
            ),
            Object.defineProperty(i, 'maxChannelCount', { get: () => n.maxChannelCount }),
            i.connect(n),
            i
        );
    };
    var Gc = r =>
        r === null ? null : r.hasOwnProperty('AudioWorkletNode') ? r.AudioWorkletNode : null;
    var zc = r => {
        let { port1: t } = new MessageChannel();
        try {
            t.postMessage(r);
        } finally {
            t.close();
        }
    };
    var Uc = (r, t, e, o, s) => (n, i, a, c, u, l) => {
        if (a !== null)
            try {
                let h = new a(n, c, l),
                    p = new Map(),
                    d = null;
                if (
                    (Object.defineProperties(h, {
                        channelCount: {
                            get: () => l.channelCount,
                            set: () => {
                                throw r();
                            },
                        },
                        channelCountMode: {
                            get: () => 'explicit',
                            set: () => {
                                throw r();
                            },
                        },
                        onprocessorerror: {
                            get: () => d,
                            set: f => {
                                typeof d == 'function' &&
                                    h.removeEventListener('processorerror', d),
                                    (d = typeof f == 'function' ? f : null),
                                    typeof d == 'function' &&
                                        h.addEventListener('processorerror', d);
                            },
                        },
                    }),
                    (h.addEventListener = (
                        f =>
                        (...m) => {
                            if (m[0] === 'processorerror') {
                                let _ =
                                    typeof m[1] == 'function'
                                        ? m[1]
                                        : typeof m[1] == 'object' &&
                                          m[1] !== null &&
                                          typeof m[1].handleEvent == 'function'
                                        ? m[1].handleEvent
                                        : null;
                                if (_ !== null) {
                                    let y = p.get(m[1]);
                                    y !== void 0
                                        ? (m[1] = y)
                                        : ((m[1] = w => {
                                              w.type === 'error'
                                                  ? (Object.defineProperties(w, {
                                                        type: { value: 'processorerror' },
                                                    }),
                                                    _(w))
                                                  : _(new ErrorEvent(m[0], { ...w }));
                                          }),
                                          p.set(_, m[1]));
                                }
                            }
                            return f.call(h, 'error', m[1], m[2]), f.call(h, ...m);
                        }
                    )(h.addEventListener)),
                    (h.removeEventListener = (
                        f =>
                        (...m) => {
                            if (m[0] === 'processorerror') {
                                let _ = p.get(m[1]);
                                _ !== void 0 && (p.delete(m[1]), (m[1] = _));
                            }
                            return f.call(h, 'error', m[1], m[2]), f.call(h, m[0], m[1], m[2]);
                        }
                    )(h.removeEventListener)),
                    l.numberOfOutputs !== 0)
                ) {
                    let f = e(n, {
                        channelCount: 1,
                        channelCountMode: 'explicit',
                        channelInterpretation: 'discrete',
                        gain: 0,
                    });
                    return (
                        h.connect(f).connect(n.destination),
                        s(
                            h,
                            () => f.disconnect(),
                            () => f.connect(n.destination)
                        )
                    );
                }
                return h;
            } catch (h) {
                throw h.code === 11 ? o() : h;
            }
        if (u === void 0) throw o();
        return zc(l), t(n, i, u, l);
    };
    var Rs = (r, t) =>
        r === null
            ? 512
            : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(r * t)))));
    var Yc = r =>
        new Promise((t, e) => {
            let { port1: o, port2: s } = new MessageChannel();
            (o.onmessage = ({ data: n }) => {
                o.close(), s.close(), t(n);
            }),
                (o.onmessageerror = ({ data: n }) => {
                    o.close(), s.close(), e(n);
                }),
                s.postMessage(r);
        });
    var Hc = async (r, t) => {
        let e = await Yc(t);
        return new r(e);
    };
    var Xc = (r, t, e, o) => {
        let s = Zr.get(r);
        s === void 0 && ((s = new WeakMap()), Zr.set(r, s));
        let n = Hc(e, o);
        return s.set(t, n), n;
    };
    var Qc = (r, t, e, o, s, n, i, a, c, u, l, h, p) => (d, f, m, _) => {
        if (_.numberOfInputs === 0 && _.numberOfOutputs === 0) throw c();
        let y = Array.isArray(_.outputChannelCount)
            ? _.outputChannelCount
            : Array.from(_.outputChannelCount);
        if (y.some(B => B < 1)) throw c();
        if (y.length !== _.numberOfOutputs) throw t();
        if (_.channelCountMode !== 'explicit') throw c();
        let w = _.channelCount * _.numberOfInputs,
            O = y.reduce((B, K) => B + K, 0),
            k = m.parameterDescriptors === void 0 ? 0 : m.parameterDescriptors.length;
        if (w + k > 6 || O > 6) throw c();
        let x = new MessageChannel(),
            v = [],
            b = [];
        for (let B = 0; B < _.numberOfInputs; B += 1)
            v.push(
                i(d, {
                    channelCount: _.channelCount,
                    channelCountMode: _.channelCountMode,
                    channelInterpretation: _.channelInterpretation,
                    gain: 1,
                })
            ),
                b.push(
                    s(d, {
                        channelCount: _.channelCount,
                        channelCountMode: 'explicit',
                        channelInterpretation: 'discrete',
                        numberOfOutputs: _.channelCount,
                    })
                );
        let T = [];
        if (m.parameterDescriptors !== void 0)
            for (let {
                defaultValue: B,
                maxValue: K,
                minValue: Mt,
                name: xt,
            } of m.parameterDescriptors) {
                let ct = n(d, {
                    channelCount: 1,
                    channelCountMode: 'explicit',
                    channelInterpretation: 'discrete',
                    offset:
                        _.parameterData[xt] !== void 0 ? _.parameterData[xt] : B === void 0 ? 0 : B,
                });
                Object.defineProperties(ct.offset, {
                    defaultValue: { get: () => (B === void 0 ? 0 : B) },
                    maxValue: { get: () => (K === void 0 ? Tt : K) },
                    minValue: { get: () => (Mt === void 0 ? St : Mt) },
                }),
                    T.push(ct);
            }
        let F = o(d, {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'speakers',
                numberOfInputs: Math.max(1, w + k),
            }),
            E = Rs(f, d.sampleRate),
            D = a(d, E, w + k, Math.max(1, O)),
            N = s(d, {
                channelCount: Math.max(1, O),
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                numberOfOutputs: Math.max(1, O),
            }),
            W = [];
        for (let B = 0; B < _.numberOfOutputs; B += 1)
            W.push(
                o(d, {
                    channelCount: 1,
                    channelCountMode: 'explicit',
                    channelInterpretation: 'speakers',
                    numberOfInputs: y[B],
                })
            );
        for (let B = 0; B < _.numberOfInputs; B += 1) {
            v[B].connect(b[B]);
            for (let K = 0; K < _.channelCount; K += 1) b[B].connect(F, K, B * _.channelCount + K);
        }
        let q = new Kr(
            m.parameterDescriptors === void 0
                ? []
                : m.parameterDescriptors.map(({ name: B }, K) => {
                      let Mt = T[K];
                      return Mt.connect(F, 0, w + K), Mt.start(0), [B, Mt.offset];
                  })
        );
        F.connect(D);
        let Z = _.channelInterpretation,
            G = null,
            Y = _.numberOfOutputs === 0 ? [D] : W,
            V = {
                get bufferSize() {
                    return E;
                },
                get channelCount() {
                    return _.channelCount;
                },
                set channelCount(B) {
                    throw e();
                },
                get channelCountMode() {
                    return _.channelCountMode;
                },
                set channelCountMode(B) {
                    throw e();
                },
                get channelInterpretation() {
                    return Z;
                },
                set channelInterpretation(B) {
                    for (let K of v) K.channelInterpretation = B;
                    Z = B;
                },
                get context() {
                    return D.context;
                },
                get inputs() {
                    return v;
                },
                get numberOfInputs() {
                    return _.numberOfInputs;
                },
                get numberOfOutputs() {
                    return _.numberOfOutputs;
                },
                get onprocessorerror() {
                    return G;
                },
                set onprocessorerror(B) {
                    typeof G == 'function' && V.removeEventListener('processorerror', G),
                        (G = typeof B == 'function' ? B : null),
                        typeof G == 'function' && V.addEventListener('processorerror', G);
                },
                get parameters() {
                    return q;
                },
                get port() {
                    return x.port2;
                },
                addEventListener(...B) {
                    return D.addEventListener(B[0], B[1], B[2]);
                },
                connect: r.bind(null, Y),
                disconnect: u.bind(null, Y),
                dispatchEvent(...B) {
                    return D.dispatchEvent(B[0]);
                },
                removeEventListener(...B) {
                    return D.removeEventListener(B[0], B[1], B[2]);
                },
            },
            C = new Map();
        (x.port1.addEventListener = (
            B =>
            (...K) => {
                if (K[0] === 'message') {
                    let Mt =
                        typeof K[1] == 'function'
                            ? K[1]
                            : typeof K[1] == 'object' &&
                              K[1] !== null &&
                              typeof K[1].handleEvent == 'function'
                            ? K[1].handleEvent
                            : null;
                    if (Mt !== null) {
                        let xt = C.get(K[1]);
                        xt !== void 0
                            ? (K[1] = xt)
                            : ((K[1] = ct => {
                                  l(d.currentTime, d.sampleRate, () => Mt(ct));
                              }),
                              C.set(Mt, K[1]));
                    }
                }
                return B.call(x.port1, K[0], K[1], K[2]);
            }
        )(x.port1.addEventListener)),
            (x.port1.removeEventListener = (
                B =>
                (...K) => {
                    if (K[0] === 'message') {
                        let Mt = C.get(K[1]);
                        Mt !== void 0 && (C.delete(K[1]), (K[1] = Mt));
                    }
                    return B.call(x.port1, K[0], K[1], K[2]);
                }
            )(x.port1.removeEventListener));
        let I = null;
        Object.defineProperty(x.port1, 'onmessage', {
            get: () => I,
            set: B => {
                typeof I == 'function' && x.port1.removeEventListener('message', I),
                    (I = typeof B == 'function' ? B : null),
                    typeof I == 'function' &&
                        (x.port1.addEventListener('message', I), x.port1.start());
            },
        }),
            (m.prototype.port = x.port1);
        let A = null;
        Xc(d, V, m, _).then(B => (A = B));
        let U = er(_.numberOfInputs, _.channelCount),
            J = er(_.numberOfOutputs, y),
            R =
                m.parameterDescriptors === void 0
                    ? []
                    : m.parameterDescriptors.reduce(
                          (B, { name: K }) => ({ ...B, [K]: new Float32Array(128) }),
                          {}
                      ),
            lt = !0,
            At = () => {
                _.numberOfOutputs > 0 && D.disconnect(N);
                for (let B = 0, K = 0; B < _.numberOfOutputs; B += 1) {
                    let Mt = W[B];
                    for (let xt = 0; xt < y[B]; xt += 1) N.disconnect(Mt, K + xt, xt);
                    K += y[B];
                }
            },
            H = new Map();
        D.onaudioprocess = ({ inputBuffer: B, outputBuffer: K }) => {
            if (A !== null) {
                let Mt = h(V);
                for (let xt = 0; xt < E; xt += 128) {
                    for (let ct = 0; ct < _.numberOfInputs; ct += 1)
                        for (let wt = 0; wt < _.channelCount; wt += 1) tr(B, U[ct], wt, wt, xt);
                    m.parameterDescriptors !== void 0 &&
                        m.parameterDescriptors.forEach(({ name: ct }, wt) => {
                            tr(B, R, ct, w + wt, xt);
                        });
                    for (let ct = 0; ct < _.numberOfInputs; ct += 1)
                        for (let wt = 0; wt < y[ct]; wt += 1)
                            J[ct][wt].byteLength === 0 && (J[ct][wt] = new Float32Array(128));
                    try {
                        let ct = U.map((le, so) => {
                            if (Mt[so].size > 0) return H.set(so, E / 128), le;
                            let on = H.get(so);
                            return on === void 0
                                ? []
                                : (le.every(Ch => Ch.every(kh => kh === 0)) &&
                                      (on === 1 ? H.delete(so) : H.set(so, on - 1)),
                                  le);
                        });
                        lt = l(d.currentTime + xt / d.sampleRate, d.sampleRate, () =>
                            A.process(ct, J, R)
                        );
                        for (let le = 0, so = 0; le < _.numberOfOutputs; le += 1) {
                            for (let Or = 0; Or < y[le]; Or += 1) Ms(K, J[le], Or, so + Or, xt);
                            so += y[le];
                        }
                    } catch (ct) {
                        (lt = !1),
                            V.dispatchEvent(
                                new ErrorEvent('processorerror', {
                                    colno: ct.colno,
                                    filename: ct.filename,
                                    lineno: ct.lineno,
                                    message: ct.message,
                                })
                            );
                    }
                    if (!lt) {
                        for (let ct = 0; ct < _.numberOfInputs; ct += 1) {
                            v[ct].disconnect(b[ct]);
                            for (let wt = 0; wt < _.channelCount; wt += 1)
                                b[xt].disconnect(F, wt, ct * _.channelCount + wt);
                        }
                        if (m.parameterDescriptors !== void 0) {
                            let ct = m.parameterDescriptors.length;
                            for (let wt = 0; wt < ct; wt += 1) {
                                let le = T[wt];
                                le.disconnect(F, 0, w + wt), le.stop();
                            }
                        }
                        F.disconnect(D), (D.onaudioprocess = null), _e ? At() : xe();
                        break;
                    }
                }
            }
        };
        let _e = !1,
            $t = i(d, {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                gain: 0,
            }),
            oe = () => D.connect($t).connect(d.destination),
            xe = () => {
                D.disconnect($t), $t.disconnect();
            },
            De = () => {
                if (lt) {
                    xe(), _.numberOfOutputs > 0 && D.connect(N);
                    for (let B = 0, K = 0; B < _.numberOfOutputs; B += 1) {
                        let Mt = W[B];
                        for (let xt = 0; xt < y[B]; xt += 1) N.connect(Mt, K + xt, xt);
                        K += y[B];
                    }
                }
                _e = !0;
            },
            en = () => {
                lt && (oe(), At()), (_e = !1);
            };
        return oe(), p(V, De, en);
    };
    var On = (r, t) => {
        let e = r.createBiquadFilter();
        return (
            rt(e, t),
            ut(e, t, 'Q'),
            ut(e, t, 'detune'),
            ut(e, t, 'frequency'),
            ut(e, t, 'gain'),
            it(e, t, 'type'),
            e
        );
    };
    var Zc = (r, t) => (e, o) => {
        let s = e.createChannelMerger(o.numberOfInputs);
        return r !== null && r.name === 'webkitAudioContext' && t(e, s), rt(s, o), s;
    };
    var $c = r => {
        let t = r.numberOfOutputs;
        Object.defineProperty(r, 'channelCount', {
            get: () => t,
            set: e => {
                if (e !== t) throw gt();
            },
        }),
            Object.defineProperty(r, 'channelCountMode', {
                get: () => 'explicit',
                set: e => {
                    if (e !== 'explicit') throw gt();
                },
            }),
            Object.defineProperty(r, 'channelInterpretation', {
                get: () => 'discrete',
                set: e => {
                    if (e !== 'discrete') throw gt();
                },
            });
    };
    var nr = (r, t) => {
        let e = r.createChannelSplitter(t.numberOfOutputs);
        return rt(e, t), $c(e), e;
    };
    var Kc = (r, t, e, o, s) => (n, i) => {
        if (n.createConstantSource === void 0) return e(n, i);
        let a = n.createConstantSource();
        return (
            rt(a, i),
            ut(a, i, 'offset'),
            t(o, () => o(n)) || rr(a),
            t(s, () => s(n)) || sr(a),
            r(n, a),
            a
        );
    };
    var de = (r, t) => ((r.connect = t.connect.bind(t)), (r.disconnect = t.disconnect.bind(t)), r);
    var Jc =
        (r, t, e, o) =>
        (s, { offset: n, ...i }) => {
            let a = s.createBuffer(1, 2, 44100),
                c = t(s, {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: 'max',
                    channelInterpretation: 'speakers',
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1,
                }),
                u = e(s, { ...i, gain: n }),
                l = a.getChannelData(0);
            (l[0] = 1), (l[1] = 1), (c.buffer = a), (c.loop = !0);
            let h = {
                    get bufferSize() {},
                    get channelCount() {
                        return u.channelCount;
                    },
                    set channelCount(f) {
                        u.channelCount = f;
                    },
                    get channelCountMode() {
                        return u.channelCountMode;
                    },
                    set channelCountMode(f) {
                        u.channelCountMode = f;
                    },
                    get channelInterpretation() {
                        return u.channelInterpretation;
                    },
                    set channelInterpretation(f) {
                        u.channelInterpretation = f;
                    },
                    get context() {
                        return u.context;
                    },
                    get inputs() {
                        return [];
                    },
                    get numberOfInputs() {
                        return c.numberOfInputs;
                    },
                    get numberOfOutputs() {
                        return u.numberOfOutputs;
                    },
                    get offset() {
                        return u.gain;
                    },
                    get onended() {
                        return c.onended;
                    },
                    set onended(f) {
                        c.onended = f;
                    },
                    addEventListener(...f) {
                        return c.addEventListener(f[0], f[1], f[2]);
                    },
                    dispatchEvent(...f) {
                        return c.dispatchEvent(f[0]);
                    },
                    removeEventListener(...f) {
                        return c.removeEventListener(f[0], f[1], f[2]);
                    },
                    start(f = 0) {
                        c.start.call(c, f);
                    },
                    stop(f = 0) {
                        c.stop.call(c, f);
                    },
                },
                p = () => c.connect(u),
                d = () => c.disconnect(u);
            return r(s, c), o(de(h, u), p, d);
        };
    var tu = (r, t) => (e, o) => {
        let s = e.createConvolver();
        if (
            (rt(s, o),
            o.disableNormalization === s.normalize && (s.normalize = !o.disableNormalization),
            it(s, o, 'buffer'),
            o.channelCount > 2 ||
                (t(
                    s,
                    'channelCount',
                    n => () => n.call(s),
                    n => i => {
                        if (i > 2) throw r();
                        return n.call(s, i);
                    }
                ),
                o.channelCountMode === 'max'))
        )
            throw r();
        return (
            t(
                s,
                'channelCountMode',
                n => () => n.call(s),
                n => i => {
                    if (i === 'max') throw r();
                    return n.call(s, i);
                }
            ),
            s
        );
    };
    var Dn = (r, t) => {
        let e = r.createDelay(t.maxDelayTime);
        return rt(e, t), ut(e, t, 'delayTime'), e;
    };
    var eu = r => (t, e) => {
        let o = t.createDynamicsCompressor();
        if ((rt(o, e), e.channelCount > 2 || e.channelCountMode === 'max')) throw r();
        return (
            ut(o, e, 'attack'),
            ut(o, e, 'knee'),
            ut(o, e, 'ratio'),
            ut(o, e, 'release'),
            ut(o, e, 'threshold'),
            o
        );
    };
    var Jt = (r, t) => {
        let e = r.createGain();
        return rt(e, t), ut(e, t, 'gain'), e;
    };
    var ou = r => (t, e, o) => {
        if (t.createIIRFilter === void 0) return r(t, e, o);
        let s = t.createIIRFilter(o.feedforward, o.feedback);
        return rt(s, o), s;
    };
    function kp(r, t) {
        let e = t[0] * t[0] + t[1] * t[1];
        return [(r[0] * t[0] + r[1] * t[1]) / e, (r[1] * t[0] - r[0] * t[1]) / e];
    }
    function Np(r, t) {
        return [r[0] * t[0] - r[1] * t[1], r[0] * t[1] + r[1] * t[0]];
    }
    function ru(r, t) {
        let e = [0, 0];
        for (let o = r.length - 1; o >= 0; o -= 1) (e = Np(e, t)), (e[0] += r[o]);
        return e;
    }
    var su =
        (r, t, e, o) =>
        (
            s,
            n,
            {
                channelCount: i,
                channelCountMode: a,
                channelInterpretation: c,
                feedback: u,
                feedforward: l,
            }
        ) => {
            let h = Rs(n, s.sampleRate),
                p = u instanceof Float64Array ? u : new Float64Array(u),
                d = l instanceof Float64Array ? l : new Float64Array(l),
                f = p.length,
                m = d.length,
                _ = Math.min(f, m);
            if (f === 0 || f > 20) throw o();
            if (p[0] === 0) throw t();
            if (m === 0 || m > 20) throw o();
            if (d[0] === 0) throw t();
            if (p[0] !== 1) {
                for (let T = 0; T < m; T += 1) d[T] /= p[0];
                for (let T = 1; T < f; T += 1) p[T] /= p[0];
            }
            let y = e(s, h, i, i);
            (y.channelCount = i), (y.channelCountMode = a), (y.channelInterpretation = c);
            let w = 32,
                O = [],
                k = [],
                x = [];
            for (let T = 0; T < i; T += 1) {
                O.push(0);
                let F = new Float32Array(w),
                    E = new Float32Array(w);
                F.fill(0), E.fill(0), k.push(F), x.push(E);
            }
            y.onaudioprocess = T => {
                let F = T.inputBuffer,
                    E = T.outputBuffer,
                    D = F.numberOfChannels;
                for (let N = 0; N < D; N += 1) {
                    let W = F.getChannelData(N),
                        q = E.getChannelData(N);
                    O[N] = Is(p, f, d, m, _, k[N], x[N], O[N], w, W, q);
                }
            };
            let v = s.sampleRate / 2;
            return de(
                {
                    get bufferSize() {
                        return h;
                    },
                    get channelCount() {
                        return y.channelCount;
                    },
                    set channelCount(T) {
                        y.channelCount = T;
                    },
                    get channelCountMode() {
                        return y.channelCountMode;
                    },
                    set channelCountMode(T) {
                        y.channelCountMode = T;
                    },
                    get channelInterpretation() {
                        return y.channelInterpretation;
                    },
                    set channelInterpretation(T) {
                        y.channelInterpretation = T;
                    },
                    get context() {
                        return y.context;
                    },
                    get inputs() {
                        return [y];
                    },
                    get numberOfInputs() {
                        return y.numberOfInputs;
                    },
                    get numberOfOutputs() {
                        return y.numberOfOutputs;
                    },
                    addEventListener(...T) {
                        return y.addEventListener(T[0], T[1], T[2]);
                    },
                    dispatchEvent(...T) {
                        return y.dispatchEvent(T[0]);
                    },
                    getFrequencyResponse(T, F, E) {
                        if (T.length !== F.length || F.length !== E.length) throw r();
                        let D = T.length;
                        for (let N = 0; N < D; N += 1) {
                            let W = -Math.PI * (T[N] / v),
                                q = [Math.cos(W), Math.sin(W)],
                                Z = ru(d, q),
                                G = ru(p, q),
                                Y = kp(Z, G);
                            (F[N] = Math.sqrt(Y[0] * Y[0] + Y[1] * Y[1])),
                                (E[N] = Math.atan2(Y[1], Y[0]));
                        }
                    },
                    removeEventListener(...T) {
                        return y.removeEventListener(T[0], T[1], T[2]);
                    },
                },
                y
            );
        };
    var nu = (r, t) => r.createMediaElementSource(t.mediaElement);
    var iu = (r, t) => {
        let e = r.createMediaStreamDestination();
        return (
            rt(e, t),
            e.numberOfOutputs === 1 &&
                Object.defineProperty(e, 'numberOfOutputs', { get: () => 0 }),
            e
        );
    };
    var au = (r, { mediaStream: t }) => {
        let e = t.getAudioTracks();
        e.sort((n, i) => (n.id < i.id ? -1 : n.id > i.id ? 1 : 0));
        let o = e.slice(0, 1),
            s = r.createMediaStreamSource(new MediaStream(o));
        return Object.defineProperty(s, 'mediaStream', { value: t }), s;
    };
    var cu =
        (r, t) =>
        (e, { mediaStreamTrack: o }) => {
            if (typeof e.createMediaStreamTrackSource == 'function')
                return e.createMediaStreamTrackSource(o);
            let s = new MediaStream([o]),
                n = e.createMediaStreamSource(s);
            if (o.kind !== 'audio') throw r();
            if (t(e)) throw new TypeError();
            return n;
        };
    var uu = r =>
        r === null
            ? null
            : r.hasOwnProperty('OfflineAudioContext')
            ? r.OfflineAudioContext
            : r.hasOwnProperty('webkitOfflineAudioContext')
            ? r.webkitOfflineAudioContext
            : null;
    var lu = (r, t, e, o, s, n) => (i, a) => {
        let c = i.createOscillator();
        return (
            rt(c, a),
            ut(c, a, 'detune'),
            ut(c, a, 'frequency'),
            a.periodicWave !== void 0 ? c.setPeriodicWave(a.periodicWave) : it(c, a, 'type'),
            t(e, () => e(i)) || rr(c),
            t(o, () => o(i)) || n(c, i),
            t(s, () => s(i)) || sr(c),
            r(i, c),
            c
        );
    };
    var hu = r => (t, e) => {
        let o = t.createPanner();
        return o.orientationX === void 0
            ? r(t, e)
            : (rt(o, e),
              ut(o, e, 'orientationX'),
              ut(o, e, 'orientationY'),
              ut(o, e, 'orientationZ'),
              ut(o, e, 'positionX'),
              ut(o, e, 'positionY'),
              ut(o, e, 'positionZ'),
              it(o, e, 'coneInnerAngle'),
              it(o, e, 'coneOuterAngle'),
              it(o, e, 'coneOuterGain'),
              it(o, e, 'distanceModel'),
              it(o, e, 'maxDistance'),
              it(o, e, 'panningModel'),
              it(o, e, 'refDistance'),
              it(o, e, 'rolloffFactor'),
              o);
    };
    var pu =
        (r, t, e, o, s, n, i, a, c, u) =>
        (
            l,
            {
                coneInnerAngle: h,
                coneOuterAngle: p,
                coneOuterGain: d,
                distanceModel: f,
                maxDistance: m,
                orientationX: _,
                orientationY: y,
                orientationZ: w,
                panningModel: O,
                positionX: k,
                positionY: x,
                positionZ: v,
                refDistance: b,
                rolloffFactor: T,
                ...F
            }
        ) => {
            let E = l.createPanner();
            if (F.channelCount > 2 || F.channelCountMode === 'max') throw i();
            rt(E, F);
            let D = {
                    channelCount: 1,
                    channelCountMode: 'explicit',
                    channelInterpretation: 'discrete',
                },
                N = e(l, { ...D, channelInterpretation: 'speakers', numberOfInputs: 6 }),
                W = o(l, { ...F, gain: 1 }),
                q = o(l, { ...D, gain: 1 }),
                Z = o(l, { ...D, gain: 0 }),
                G = o(l, { ...D, gain: 0 }),
                Y = o(l, { ...D, gain: 0 }),
                V = o(l, { ...D, gain: 0 }),
                C = o(l, { ...D, gain: 0 }),
                I = s(l, 256, 6, 1),
                A = n(l, { ...D, curve: new Float32Array([1, 1]), oversample: 'none' }),
                L = [_, y, w],
                U = [k, x, v],
                J = new Float32Array(1);
            (I.onaudioprocess = ({ inputBuffer: H }) => {
                let _e = [c(H, J, 0), c(H, J, 1), c(H, J, 2)];
                _e.some((oe, xe) => oe !== L[xe]) && (E.setOrientation(..._e), (L = _e));
                let $t = [c(H, J, 3), c(H, J, 4), c(H, J, 5)];
                $t.some((oe, xe) => oe !== U[xe]) && (E.setPosition(...$t), (U = $t));
            }),
                Object.defineProperty(Z.gain, 'defaultValue', { get: () => 0 }),
                Object.defineProperty(G.gain, 'defaultValue', { get: () => 0 }),
                Object.defineProperty(Y.gain, 'defaultValue', { get: () => 0 }),
                Object.defineProperty(V.gain, 'defaultValue', { get: () => 0 }),
                Object.defineProperty(C.gain, 'defaultValue', { get: () => 0 });
            let R = {
                get bufferSize() {},
                get channelCount() {
                    return E.channelCount;
                },
                set channelCount(H) {
                    if (H > 2) throw i();
                    (W.channelCount = H), (E.channelCount = H);
                },
                get channelCountMode() {
                    return E.channelCountMode;
                },
                set channelCountMode(H) {
                    if (H === 'max') throw i();
                    (W.channelCountMode = H), (E.channelCountMode = H);
                },
                get channelInterpretation() {
                    return E.channelInterpretation;
                },
                set channelInterpretation(H) {
                    (W.channelInterpretation = H), (E.channelInterpretation = H);
                },
                get coneInnerAngle() {
                    return E.coneInnerAngle;
                },
                set coneInnerAngle(H) {
                    E.coneInnerAngle = H;
                },
                get coneOuterAngle() {
                    return E.coneOuterAngle;
                },
                set coneOuterAngle(H) {
                    E.coneOuterAngle = H;
                },
                get coneOuterGain() {
                    return E.coneOuterGain;
                },
                set coneOuterGain(H) {
                    if (H < 0 || H > 1) throw t();
                    E.coneOuterGain = H;
                },
                get context() {
                    return E.context;
                },
                get distanceModel() {
                    return E.distanceModel;
                },
                set distanceModel(H) {
                    E.distanceModel = H;
                },
                get inputs() {
                    return [W];
                },
                get maxDistance() {
                    return E.maxDistance;
                },
                set maxDistance(H) {
                    if (H < 0) throw new RangeError();
                    E.maxDistance = H;
                },
                get numberOfInputs() {
                    return E.numberOfInputs;
                },
                get numberOfOutputs() {
                    return E.numberOfOutputs;
                },
                get orientationX() {
                    return q.gain;
                },
                get orientationY() {
                    return Z.gain;
                },
                get orientationZ() {
                    return G.gain;
                },
                get panningModel() {
                    return E.panningModel;
                },
                set panningModel(H) {
                    E.panningModel = H;
                },
                get positionX() {
                    return Y.gain;
                },
                get positionY() {
                    return V.gain;
                },
                get positionZ() {
                    return C.gain;
                },
                get refDistance() {
                    return E.refDistance;
                },
                set refDistance(H) {
                    if (H < 0) throw new RangeError();
                    E.refDistance = H;
                },
                get rolloffFactor() {
                    return E.rolloffFactor;
                },
                set rolloffFactor(H) {
                    if (H < 0) throw new RangeError();
                    E.rolloffFactor = H;
                },
                addEventListener(...H) {
                    return W.addEventListener(H[0], H[1], H[2]);
                },
                dispatchEvent(...H) {
                    return W.dispatchEvent(H[0]);
                },
                removeEventListener(...H) {
                    return W.removeEventListener(H[0], H[1], H[2]);
                },
            };
            h !== R.coneInnerAngle && (R.coneInnerAngle = h),
                p !== R.coneOuterAngle && (R.coneOuterAngle = p),
                d !== R.coneOuterGain && (R.coneOuterGain = d),
                f !== R.distanceModel && (R.distanceModel = f),
                m !== R.maxDistance && (R.maxDistance = m),
                _ !== R.orientationX.value && (R.orientationX.value = _),
                y !== R.orientationY.value && (R.orientationY.value = y),
                w !== R.orientationZ.value && (R.orientationZ.value = w),
                O !== R.panningModel && (R.panningModel = O),
                k !== R.positionX.value && (R.positionX.value = k),
                x !== R.positionY.value && (R.positionY.value = x),
                v !== R.positionZ.value && (R.positionZ.value = v),
                b !== R.refDistance && (R.refDistance = b),
                T !== R.rolloffFactor && (R.rolloffFactor = T),
                (L[0] !== 1 || L[1] !== 0 || L[2] !== 0) && E.setOrientation(...L),
                (U[0] !== 0 || U[1] !== 0 || U[2] !== 0) && E.setPosition(...U);
            let lt = () => {
                    W.connect(E),
                        r(W, A, 0, 0),
                        A.connect(q).connect(N, 0, 0),
                        A.connect(Z).connect(N, 0, 1),
                        A.connect(G).connect(N, 0, 2),
                        A.connect(Y).connect(N, 0, 3),
                        A.connect(V).connect(N, 0, 4),
                        A.connect(C).connect(N, 0, 5),
                        N.connect(I).connect(l.destination);
                },
                At = () => {
                    W.disconnect(E),
                        a(W, A, 0, 0),
                        A.disconnect(q),
                        q.disconnect(N),
                        A.disconnect(Z),
                        Z.disconnect(N),
                        A.disconnect(G),
                        G.disconnect(N),
                        A.disconnect(Y),
                        Y.disconnect(N),
                        A.disconnect(V),
                        V.disconnect(N),
                        A.disconnect(C),
                        C.disconnect(N),
                        N.disconnect(I),
                        I.disconnect(l.destination);
                };
            return u(de(R, E), lt, At);
        };
    var du =
        r =>
        (t, { disableNormalization: e, imag: o, real: s }) => {
            let n = o instanceof Float32Array ? o : new Float32Array(o),
                i = s instanceof Float32Array ? s : new Float32Array(s),
                a = t.createPeriodicWave(i, n, { disableNormalization: e });
            if (Array.from(o).length < 2) throw r();
            return a;
        };
    var ir = (r, t, e, o) => r.createScriptProcessor(t, e, o);
    var fu = (r, t) => (e, o) => {
        let s = o.channelCountMode;
        if (s === 'clamped-max') throw t();
        if (e.createStereoPanner === void 0) return r(e, o);
        let n = e.createStereoPanner();
        return (
            rt(n, o),
            ut(n, o, 'pan'),
            Object.defineProperty(n, 'channelCountMode', {
                get: () => s,
                set: i => {
                    if (i !== s) throw t();
                },
            }),
            n
        );
    };
    var mu = (r, t, e, o, s, n) => {
        let i = 16385,
            a = new Float32Array([1, 1]),
            c = Math.PI / 2,
            u = {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
            },
            l = { ...u, oversample: 'none' },
            h = (f, m, _, y) => {
                let w = new Float32Array(i),
                    O = new Float32Array(i);
                for (let F = 0; F < i; F += 1) {
                    let E = (F / (i - 1)) * c;
                    (w[F] = Math.cos(E)), (O[F] = Math.sin(E));
                }
                let k = e(f, { ...u, gain: 0 }),
                    x = o(f, { ...l, curve: w }),
                    v = o(f, { ...l, curve: a }),
                    b = e(f, { ...u, gain: 0 }),
                    T = o(f, { ...l, curve: O });
                return {
                    connectGraph() {
                        m.connect(k),
                            m.connect(v.inputs === void 0 ? v : v.inputs[0]),
                            m.connect(b),
                            v.connect(_),
                            _.connect(x.inputs === void 0 ? x : x.inputs[0]),
                            _.connect(T.inputs === void 0 ? T : T.inputs[0]),
                            x.connect(k.gain),
                            T.connect(b.gain),
                            k.connect(y, 0, 0),
                            b.connect(y, 0, 1);
                    },
                    disconnectGraph() {
                        m.disconnect(k),
                            m.disconnect(v.inputs === void 0 ? v : v.inputs[0]),
                            m.disconnect(b),
                            v.disconnect(_),
                            _.disconnect(x.inputs === void 0 ? x : x.inputs[0]),
                            _.disconnect(T.inputs === void 0 ? T : T.inputs[0]),
                            x.disconnect(k.gain),
                            T.disconnect(b.gain),
                            k.disconnect(y, 0, 0),
                            b.disconnect(y, 0, 1);
                    },
                };
            },
            p = (f, m, _, y) => {
                let w = new Float32Array(i),
                    O = new Float32Array(i),
                    k = new Float32Array(i),
                    x = new Float32Array(i),
                    v = Math.floor(i / 2);
                for (let Y = 0; Y < i; Y += 1)
                    if (Y > v) {
                        let V = ((Y - v) / (i - 1 - v)) * c;
                        (w[Y] = Math.cos(V)), (O[Y] = Math.sin(V)), (k[Y] = 0), (x[Y] = 1);
                    } else {
                        let V = (Y / (i - 1 - v)) * c;
                        (w[Y] = 1), (O[Y] = 0), (k[Y] = Math.cos(V)), (x[Y] = Math.sin(V));
                    }
                let b = t(f, {
                        channelCount: 2,
                        channelCountMode: 'explicit',
                        channelInterpretation: 'discrete',
                        numberOfOutputs: 2,
                    }),
                    T = e(f, { ...u, gain: 0 }),
                    F = o(f, { ...l, curve: w }),
                    E = e(f, { ...u, gain: 0 }),
                    D = o(f, { ...l, curve: O }),
                    N = o(f, { ...l, curve: a }),
                    W = e(f, { ...u, gain: 0 }),
                    q = o(f, { ...l, curve: k }),
                    Z = e(f, { ...u, gain: 0 }),
                    G = o(f, { ...l, curve: x });
                return {
                    connectGraph() {
                        m.connect(b),
                            m.connect(N.inputs === void 0 ? N : N.inputs[0]),
                            b.connect(T, 0),
                            b.connect(E, 0),
                            b.connect(W, 1),
                            b.connect(Z, 1),
                            N.connect(_),
                            _.connect(F.inputs === void 0 ? F : F.inputs[0]),
                            _.connect(D.inputs === void 0 ? D : D.inputs[0]),
                            _.connect(q.inputs === void 0 ? q : q.inputs[0]),
                            _.connect(G.inputs === void 0 ? G : G.inputs[0]),
                            F.connect(T.gain),
                            D.connect(E.gain),
                            q.connect(W.gain),
                            G.connect(Z.gain),
                            T.connect(y, 0, 0),
                            W.connect(y, 0, 0),
                            E.connect(y, 0, 1),
                            Z.connect(y, 0, 1);
                    },
                    disconnectGraph() {
                        m.disconnect(b),
                            m.disconnect(N.inputs === void 0 ? N : N.inputs[0]),
                            b.disconnect(T, 0),
                            b.disconnect(E, 0),
                            b.disconnect(W, 1),
                            b.disconnect(Z, 1),
                            N.disconnect(_),
                            _.disconnect(F.inputs === void 0 ? F : F.inputs[0]),
                            _.disconnect(D.inputs === void 0 ? D : D.inputs[0]),
                            _.disconnect(q.inputs === void 0 ? q : q.inputs[0]),
                            _.disconnect(G.inputs === void 0 ? G : G.inputs[0]),
                            F.disconnect(T.gain),
                            D.disconnect(E.gain),
                            q.disconnect(W.gain),
                            G.disconnect(Z.gain),
                            T.disconnect(y, 0, 0),
                            W.disconnect(y, 0, 0),
                            E.disconnect(y, 0, 1),
                            Z.disconnect(y, 0, 1);
                    },
                };
            },
            d = (f, m, _, y, w) => {
                if (m === 1) return h(f, _, y, w);
                if (m === 2) return p(f, _, y, w);
                throw s();
            };
        return (f, { channelCount: m, channelCountMode: _, pan: y, ...w }) => {
            if (_ === 'max') throw s();
            let O = r(f, { ...w, channelCount: 1, channelCountMode: _, numberOfInputs: 2 }),
                k = e(f, { ...w, channelCount: m, channelCountMode: _, gain: 1 }),
                x = e(f, {
                    channelCount: 1,
                    channelCountMode: 'explicit',
                    channelInterpretation: 'discrete',
                    gain: y,
                }),
                { connectGraph: v, disconnectGraph: b } = d(f, m, k, x, O);
            Object.defineProperty(x.gain, 'defaultValue', { get: () => 0 }),
                Object.defineProperty(x.gain, 'maxValue', { get: () => 1 }),
                Object.defineProperty(x.gain, 'minValue', { get: () => -1 });
            let T = {
                    get bufferSize() {},
                    get channelCount() {
                        return k.channelCount;
                    },
                    set channelCount(N) {
                        k.channelCount !== N &&
                            (F && b(),
                            ({ connectGraph: v, disconnectGraph: b } = d(f, N, k, x, O)),
                            F && v()),
                            (k.channelCount = N);
                    },
                    get channelCountMode() {
                        return k.channelCountMode;
                    },
                    set channelCountMode(N) {
                        if (N === 'clamped-max' || N === 'max') throw s();
                        k.channelCountMode = N;
                    },
                    get channelInterpretation() {
                        return k.channelInterpretation;
                    },
                    set channelInterpretation(N) {
                        k.channelInterpretation = N;
                    },
                    get context() {
                        return k.context;
                    },
                    get inputs() {
                        return [k];
                    },
                    get numberOfInputs() {
                        return k.numberOfInputs;
                    },
                    get numberOfOutputs() {
                        return k.numberOfOutputs;
                    },
                    get pan() {
                        return x.gain;
                    },
                    addEventListener(...N) {
                        return k.addEventListener(N[0], N[1], N[2]);
                    },
                    dispatchEvent(...N) {
                        return k.dispatchEvent(N[0]);
                    },
                    removeEventListener(...N) {
                        return k.removeEventListener(N[0], N[1], N[2]);
                    },
                },
                F = !1,
                E = () => {
                    v(), (F = !0);
                },
                D = () => {
                    b(), (F = !1);
                };
            return n(de(T, O), E, D);
        };
    };
    var gu = (r, t, e, o, s, n, i) => (a, c) => {
        let u = a.createWaveShaper();
        if (
            n !== null &&
            n.name === 'webkitAudioContext' &&
            a.createGain().gain.automationRate === void 0
        )
            return e(a, c);
        rt(u, c);
        let l =
            c.curve === null || c.curve instanceof Float32Array
                ? c.curve
                : new Float32Array(c.curve);
        if (l !== null && l.length < 2) throw t();
        it(u, { curve: l }, 'curve'), it(u, c, 'oversample');
        let h = null,
            p = !1;
        return (
            i(
                u,
                'curve',
                m => () => m.call(u),
                m => _ =>
                    m.call(u, _),
                    p &&
                        (o(_) && h === null
                            ? (h = r(a, u))
                            : !o(_) && h !== null && (h(), (h = null))),
                    _
            ),
            s(
                u,
                () => {
                    (p = !0), o(u.curve) && (h = r(a, u));
                },
                () => {
                    (p = !1), h !== null && (h(), (h = null));
                }
            )
        );
    };
    var _u =
        (r, t, e, o, s) =>
        (n, { curve: i, oversample: a, ...c }) => {
            let u = n.createWaveShaper(),
                l = n.createWaveShaper();
            rt(u, c), rt(l, c);
            let h = e(n, { ...c, gain: 1 }),
                p = e(n, { ...c, gain: -1 }),
                d = e(n, { ...c, gain: 1 }),
                f = e(n, { ...c, gain: -1 }),
                m = null,
                _ = !1,
                y = null,
                w = {
                    get bufferSize() {},
                    get channelCount() {
                        return u.channelCount;
                    },
                    set channelCount(x) {
                        (h.channelCount = x),
                            (p.channelCount = x),
                            (u.channelCount = x),
                            (d.channelCount = x),
                            (l.channelCount = x),
                            (f.channelCount = x);
                    },
                    get channelCountMode() {
                        return u.channelCountMode;
                    },
                    set channelCountMode(x) {
                        (h.channelCountMode = x),
                            (p.channelCountMode = x),
                            (u.channelCountMode = x),
                            (d.channelCountMode = x),
                            (l.channelCountMode = x),
                            (f.channelCountMode = x);
                    },
                    get channelInterpretation() {
                        return u.channelInterpretation;
                    },
                    set channelInterpretation(x) {
                        (h.channelInterpretation = x),
                            (p.channelInterpretation = x),
                            (u.channelInterpretation = x),
                            (d.channelInterpretation = x),
                            (l.channelInterpretation = x),
                            (f.channelInterpretation = x);
                    },
                    get context() {
                        return u.context;
                    },
                    get curve() {
                        return y;
                    },
                    set curve(x) {
                        if (x !== null && x.length < 2) throw t();
                        if (x === null) (u.curve = x), (l.curve = x);
                        else {
                            let v = x.length,
                                b = new Float32Array(v + 2 - (v % 2)),
                                T = new Float32Array(v + 2 - (v % 2));
                            (b[0] = x[0]), (T[0] = -x[v - 1]);
                            let F = Math.ceil((v + 1) / 2),
                                E = (v + 1) / 2 - 1;
                            for (let D = 1; D < F; D += 1) {
                                let N = (D / F) * E,
                                    W = Math.floor(N),
                                    q = Math.ceil(N);
                                (b[D] =
                                    W === q ? x[W] : (1 - (N - W)) * x[W] + (1 - (q - N)) * x[q]),
                                    (T[D] =
                                        W === q
                                            ? -x[v - 1 - W]
                                            : -((1 - (N - W)) * x[v - 1 - W]) -
                                              (1 - (q - N)) * x[v - 1 - q]);
                            }
                            (b[F] = v % 2 == 1 ? x[F - 1] : (x[F - 2] + x[F - 1]) / 2),
                                (u.curve = b),
                                (l.curve = T);
                        }
                        (y = x),
                            _ &&
                                (o(y) && m === null
                                    ? (m = r(n, h))
                                    : m !== null && (m(), (m = null)));
                    },
                    get inputs() {
                        return [h];
                    },
                    get numberOfInputs() {
                        return u.numberOfInputs;
                    },
                    get numberOfOutputs() {
                        return u.numberOfOutputs;
                    },
                    get oversample() {
                        return u.oversample;
                    },
                    set oversample(x) {
                        (u.oversample = x), (l.oversample = x);
                    },
                    addEventListener(...x) {
                        return h.addEventListener(x[0], x[1], x[2]);
                    },
                    dispatchEvent(...x) {
                        return h.dispatchEvent(x[0]);
                    },
                    removeEventListener(...x) {
                        return h.removeEventListener(x[0], x[1], x[2]);
                    },
                };
            i !== null && (w.curve = i instanceof Float32Array ? i : new Float32Array(i)),
                a !== w.oversample && (w.oversample = a);
            let O = () => {
                    h.connect(u).connect(d),
                        h.connect(p).connect(l).connect(f).connect(d),
                        (_ = !0),
                        o(y) && (m = r(n, h));
                },
                k = () => {
                    h.disconnect(u),
                        u.disconnect(d),
                        h.disconnect(p),
                        p.disconnect(l),
                        l.disconnect(f),
                        f.disconnect(d),
                        (_ = !1),
                        m !== null && (m(), (m = null));
                };
            return s(de(w, d), O, k);
        };
    var jt = () => new DOMException('', 'NotSupportedError');
    var Op = { numberOfChannels: 1 },
        xu = (r, t, e, o, s) =>
            class extends r {
                constructor(i, a, c) {
                    let u;
                    if (typeof i == 'number' && a !== void 0 && c !== void 0)
                        u = { length: a, numberOfChannels: i, sampleRate: c };
                    else if (typeof i == 'object') u = i;
                    else throw new Error('The given parameters are not valid.');
                    let { length: l, numberOfChannels: h, sampleRate: p } = { ...Op, ...u },
                        d = o(h, l, p);
                    t(we, () => we(d)) ||
                        d.addEventListener(
                            'statechange',
                            (() => {
                                let f = 0,
                                    m = _ => {
                                        this._state === 'running' &&
                                            (f > 0
                                                ? (d.removeEventListener('statechange', m),
                                                  _.stopImmediatePropagation(),
                                                  this._waitForThePromiseToSettle(_))
                                                : (f += 1));
                                    };
                                return m;
                            })()
                        );
                    super(d, h);
                    (this._length = l), (this._nativeOfflineAudioContext = d), (this._state = null);
                }
                get length() {
                    return this._nativeOfflineAudioContext.length === void 0
                        ? this._length
                        : this._nativeOfflineAudioContext.length;
                }
                get state() {
                    return this._state === null
                        ? this._nativeOfflineAudioContext.state
                        : this._state;
                }
                startRendering() {
                    return this._state === 'running'
                        ? Promise.reject(e())
                        : ((this._state = 'running'),
                          s(this.destination, this._nativeOfflineAudioContext).finally(() => {
                              (this._state = null), ao(this);
                          }));
                }
                _waitForThePromiseToSettle(i) {
                    this._state === null
                        ? this._nativeOfflineAudioContext.dispatchEvent(i)
                        : setTimeout(() => this._waitForThePromiseToSettle(i));
                }
            };
    var Dp = {
            channelCount: 2,
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            detune: 0,
            frequency: 440,
            periodicWave: void 0,
            type: 'sine',
        },
        yu = (r, t, e, o, s, n, i) =>
            class extends r {
                constructor(c, u) {
                    let l = s(c),
                        h = { ...Dp, ...u },
                        p = e(l, h),
                        d = n(l),
                        f = d ? o() : null,
                        m = c.sampleRate / 2;
                    super(c, !1, p, f);
                    (this._detune = t(this, d, p.detune, 153600, -153600)),
                        (this._frequency = t(this, d, p.frequency, m, -m)),
                        (this._nativeOscillatorNode = p),
                        (this._onended = null),
                        (this._oscillatorNodeRenderer = f),
                        this._oscillatorNodeRenderer !== null &&
                            h.periodicWave !== void 0 &&
                            (this._oscillatorNodeRenderer.periodicWave = h.periodicWave);
                }
                get detune() {
                    return this._detune;
                }
                get frequency() {
                    return this._frequency;
                }
                get onended() {
                    return this._onended;
                }
                set onended(c) {
                    let u = typeof c == 'function' ? i(this, c) : null;
                    this._nativeOscillatorNode.onended = u;
                    let l = this._nativeOscillatorNode.onended;
                    this._onended = l !== null && l === u ? c : l;
                }
                get type() {
                    return this._nativeOscillatorNode.type;
                }
                set type(c) {
                    (this._nativeOscillatorNode.type = c),
                        this._oscillatorNodeRenderer !== null &&
                            (this._oscillatorNodeRenderer.periodicWave = null);
                }
                setPeriodicWave(c) {
                    this._nativeOscillatorNode.setPeriodicWave(c),
                        this._oscillatorNodeRenderer !== null &&
                            (this._oscillatorNodeRenderer.periodicWave = c);
                }
                start(c = 0) {
                    if (
                        (this._nativeOscillatorNode.start(c),
                        this._oscillatorNodeRenderer !== null &&
                            (this._oscillatorNodeRenderer.start = c),
                        this.context.state !== 'closed')
                    ) {
                        ye(this);
                        let u = () => {
                            this._nativeOscillatorNode.removeEventListener('ended', u),
                                Kt(this) && Re(this);
                        };
                        this._nativeOscillatorNode.addEventListener('ended', u);
                    }
                }
                stop(c = 0) {
                    this._nativeOscillatorNode.stop(c),
                        this._oscillatorNodeRenderer !== null &&
                            (this._oscillatorNodeRenderer.stop = c);
                }
            };
    var vu = (r, t, e, o, s) => () => {
        let n = new WeakMap(),
            i = null,
            a = null,
            c = null,
            u = async (l, h) => {
                let p = e(l),
                    d = nt(p, h);
                if (!d) {
                    let f = {
                        channelCount: p.channelCount,
                        channelCountMode: p.channelCountMode,
                        channelInterpretation: p.channelInterpretation,
                        detune: p.detune.value,
                        frequency: p.frequency.value,
                        periodicWave: i === null ? void 0 : i,
                        type: p.type,
                    };
                    (p = t(h, f)), a !== null && p.start(a), c !== null && p.stop(c);
                }
                return (
                    n.set(h, p),
                    d
                        ? (await r(h, l.detune, p.detune), await r(h, l.frequency, p.frequency))
                        : (await o(h, l.detune, p.detune), await o(h, l.frequency, p.frequency)),
                    await s(l, h, p),
                    p
                );
            };
        return {
            set periodicWave(l) {
                i = l;
            },
            set start(l) {
                a = l;
            },
            set stop(l) {
                c = l;
            },
            render(l, h) {
                let p = n.get(h);
                return p !== void 0 ? Promise.resolve(p) : u(l, h);
            },
        };
    };
    var Ep = {
            channelCount: 2,
            channelCountMode: 'clamped-max',
            channelInterpretation: 'speakers',
            coneInnerAngle: 360,
            coneOuterAngle: 360,
            coneOuterGain: 0,
            distanceModel: 'inverse',
            maxDistance: 1e4,
            orientationX: 1,
            orientationY: 0,
            orientationZ: 0,
            panningModel: 'equalpower',
            positionX: 0,
            positionY: 0,
            positionZ: 0,
            refDistance: 1,
            rolloffFactor: 1,
        },
        wu = (r, t, e, o, s, n, i) =>
            class extends r {
                constructor(c, u) {
                    let l = s(c),
                        h = { ...Ep, ...u },
                        p = e(l, h),
                        d = n(l),
                        f = d ? o() : null;
                    super(c, !1, p, f);
                    (this._nativePannerNode = p),
                        (this._orientationX = t(this, d, p.orientationX, Tt, St)),
                        (this._orientationY = t(this, d, p.orientationY, Tt, St)),
                        (this._orientationZ = t(this, d, p.orientationZ, Tt, St)),
                        (this._positionX = t(this, d, p.positionX, Tt, St)),
                        (this._positionY = t(this, d, p.positionY, Tt, St)),
                        (this._positionZ = t(this, d, p.positionZ, Tt, St)),
                        i(this, 1);
                }
                get coneInnerAngle() {
                    return this._nativePannerNode.coneInnerAngle;
                }
                set coneInnerAngle(c) {
                    this._nativePannerNode.coneInnerAngle = c;
                }
                get coneOuterAngle() {
                    return this._nativePannerNode.coneOuterAngle;
                }
                set coneOuterAngle(c) {
                    this._nativePannerNode.coneOuterAngle = c;
                }
                get coneOuterGain() {
                    return this._nativePannerNode.coneOuterGain;
                }
                set coneOuterGain(c) {
                    this._nativePannerNode.coneOuterGain = c;
                }
                get distanceModel() {
                    return this._nativePannerNode.distanceModel;
                }
                set distanceModel(c) {
                    this._nativePannerNode.distanceModel = c;
                }
                get maxDistance() {
                    return this._nativePannerNode.maxDistance;
                }
                set maxDistance(c) {
                    this._nativePannerNode.maxDistance = c;
                }
                get orientationX() {
                    return this._orientationX;
                }
                get orientationY() {
                    return this._orientationY;
                }
                get orientationZ() {
                    return this._orientationZ;
                }
                get panningModel() {
                    return this._nativePannerNode.panningModel;
                }
                set panningModel(c) {
                    this._nativePannerNode.panningModel = c;
                }
                get positionX() {
                    return this._positionX;
                }
                get positionY() {
                    return this._positionY;
                }
                get positionZ() {
                    return this._positionZ;
                }
                get refDistance() {
                    return this._nativePannerNode.refDistance;
                }
                set refDistance(c) {
                    this._nativePannerNode.refDistance = c;
                }
                get rolloffFactor() {
                    return this._nativePannerNode.rolloffFactor;
                }
                set rolloffFactor(c) {
                    this._nativePannerNode.rolloffFactor = c;
                }
            };
    var bu = (r, t, e, o, s, n, i, a, c, u) => () => {
        let l = new WeakMap(),
            h = null,
            p = async (d, f) => {
                let m = null,
                    _ = n(d),
                    y = {
                        channelCount: _.channelCount,
                        channelCountMode: _.channelCountMode,
                        channelInterpretation: _.channelInterpretation,
                    },
                    w = {
                        ...y,
                        coneInnerAngle: _.coneInnerAngle,
                        coneOuterAngle: _.coneOuterAngle,
                        coneOuterGain: _.coneOuterGain,
                        distanceModel: _.distanceModel,
                        maxDistance: _.maxDistance,
                        panningModel: _.panningModel,
                        refDistance: _.refDistance,
                        rolloffFactor: _.rolloffFactor,
                    },
                    O = nt(_, f);
                if ('bufferSize' in _) m = o(f, { ...y, gain: 1 });
                else if (!O) {
                    let k = {
                        ...w,
                        orientationX: _.orientationX.value,
                        orientationY: _.orientationY.value,
                        orientationZ: _.orientationZ.value,
                        positionX: _.positionX.value,
                        positionY: _.positionY.value,
                        positionZ: _.positionZ.value,
                    };
                    _ = s(f, k);
                }
                if ((l.set(f, m === null ? _ : m), m !== null)) {
                    if (h === null) {
                        if (i === null)
                            throw new Error('Missing the native OfflineAudioContext constructor.');
                        let D = new i(6, d.context.length, f.sampleRate),
                            N = t(D, {
                                channelCount: 1,
                                channelCountMode: 'explicit',
                                channelInterpretation: 'speakers',
                                numberOfInputs: 6,
                            });
                        N.connect(D.destination),
                            (h = (async () => {
                                let W = await Promise.all(
                                    [
                                        d.orientationX,
                                        d.orientationY,
                                        d.orientationZ,
                                        d.positionX,
                                        d.positionY,
                                        d.positionZ,
                                    ].map(async (q, Z) => {
                                        let G = e(D, {
                                            channelCount: 1,
                                            channelCountMode: 'explicit',
                                            channelInterpretation: 'discrete',
                                            offset: Z === 0 ? 1 : 0,
                                        });
                                        return await a(D, q, G.offset), G;
                                    })
                                );
                                for (let q = 0; q < 6; q += 1) W[q].connect(N, 0, q), W[q].start(0);
                                return u(D);
                            })());
                    }
                    let k = await h,
                        x = o(f, { ...y, gain: 1 });
                    await c(d, f, x);
                    let v = [];
                    for (let D = 0; D < k.numberOfChannels; D += 1) v.push(k.getChannelData(D));
                    let b = [v[0][0], v[1][0], v[2][0]],
                        T = [v[3][0], v[4][0], v[5][0]],
                        F = o(f, { ...y, gain: 1 }),
                        E = s(f, {
                            ...w,
                            orientationX: b[0],
                            orientationY: b[1],
                            orientationZ: b[2],
                            positionX: T[0],
                            positionY: T[1],
                            positionZ: T[2],
                        });
                    x.connect(F).connect(E.inputs[0]), E.connect(m);
                    for (let D = 128; D < k.length; D += 128) {
                        let N = [v[0][D], v[1][D], v[2][D]],
                            W = [v[3][D], v[4][D], v[5][D]];
                        if (N.some((q, Z) => q !== b[Z]) || W.some((q, Z) => q !== T[Z])) {
                            (b = N), (T = W);
                            let q = D / f.sampleRate;
                            F.gain.setValueAtTime(0, q),
                                (F = o(f, { ...y, gain: 0 })),
                                (E = s(f, {
                                    ...w,
                                    orientationX: b[0],
                                    orientationY: b[1],
                                    orientationZ: b[2],
                                    positionX: T[0],
                                    positionY: T[1],
                                    positionZ: T[2],
                                })),
                                F.gain.setValueAtTime(1, q),
                                x.connect(F).connect(E.inputs[0]),
                                E.connect(m);
                        }
                    }
                    return m;
                }
                return (
                    O
                        ? (await r(f, d.orientationX, _.orientationX),
                          await r(f, d.orientationY, _.orientationY),
                          await r(f, d.orientationZ, _.orientationZ),
                          await r(f, d.positionX, _.positionX),
                          await r(f, d.positionY, _.positionY),
                          await r(f, d.positionZ, _.positionZ))
                        : (await a(f, d.orientationX, _.orientationX),
                          await a(f, d.orientationY, _.orientationY),
                          await a(f, d.orientationZ, _.orientationZ),
                          await a(f, d.positionX, _.positionX),
                          await a(f, d.positionY, _.positionY),
                          await a(f, d.positionZ, _.positionZ)),
                    pe(_) ? await c(d, f, _.inputs[0]) : await c(d, f, _),
                    _
                );
            };
        return {
            render(d, f) {
                let m = l.get(f);
                return m !== void 0 ? Promise.resolve(m) : p(d, f);
            },
        };
    };
    var Mp = { disableNormalization: !1 },
        Tu = (r, t, e, o) =>
            class Au {
                constructor(n, i) {
                    let a = t(n),
                        c = o({ ...Mp, ...i }),
                        u = r(a, c);
                    return e.add(u), u;
                }
                static [Symbol.hasInstance](n) {
                    return (
                        (n !== null &&
                            typeof n == 'object' &&
                            Object.getPrototypeOf(n) === Au.prototype) ||
                        e.has(n)
                    );
                }
            };
    var Su = (r, t) => (e, o, s) => r(o).replay(s), t(o, e, s);
    var Cu = (r, t, e) => async (o, s, n) => {
        let i = r(o);
        await Promise.all(
            i.activeInputs
                .map((a, c) =>
                    Array.from(a).map(async ([u, l]) => {
                        let p = await t(u).render(u, s),
                            d = o.context.destination;
                        !e(u) && (o !== d || !e(o)) && p.connect(n, l, c);
                    })
                )
                .reduce((a, c) => [...a, ...c], [])
        );
    };
    var ku = (r, t, e) => async (o, s, n) => {
        let i = t(o);
        await Promise.all(
            Array.from(i.activeInputs).map(async ([a, c]) => {
                let l = await r(a).render(a, s);
                e(a) || l.connect(n, c);
            })
        );
    };
    var Nu = (r, t, e, o) => s =>
        r(we, () => we(s))
            ? Promise.resolve(r(o, o)).then(n => {
                  if (!n) {
                      let i = e(s, 512, 0, 1);
                      (s.oncomplete = () => {
                          (i.onaudioprocess = null), i.disconnect();
                      }),
                          (i.onaudioprocess = () => s.currentTime),
                          i.connect(s.destination);
                  }
                  return s.startRendering();
              })
            : new Promise(n => {
                  let i = t(s, {
                      channelCount: 1,
                      channelCountMode: 'explicit',
                      channelInterpretation: 'discrete',
                      gain: 0,
                  });
                  (s.oncomplete = a => {
                      i.disconnect(), n(a.renderedBuffer);
                  }),
                      i.connect(s.destination),
                      s.startRendering();
              });
    var Ou = r => (t, e) => {
        r.set(t, e);
    };
    var Du = r => (t, e) => r.set(t, e);
    var Eu = (r, t, e, o, s, n, i, a) => (c, u) =>
        e(c)
            .render(c, u)
            .then(() => Promise.all(Array.from(o(u)).map(l => e(l).render(l, u))))
            .then(() => s(u))
            .then(
                l => (
                    typeof l.copyFromChannel != 'function'
                        ? (i(l), Zo(l))
                        : t(n, () => n(l)) || a(l),
                    r.add(l),
                    l
                )
            );
    var Fp = {
            channelCount: 2,
            channelCountMode: 'explicit',
            channelInterpretation: 'speakers',
            pan: 0,
        },
        Mu = (r, t, e, o, s, n) =>
            class extends r {
                constructor(a, c) {
                    let u = s(a),
                        l = { ...Fp, ...c },
                        h = e(u, l),
                        p = n(u),
                        d = p ? o() : null;
                    super(a, !1, h, d);
                    this._pan = t(this, p, h.pan);
                }
                get pan() {
                    return this._pan;
                }
            };
    var Fu = (r, t, e, o, s) => () => {
        let n = new WeakMap(),
            i = async (a, c) => {
                let u = e(a),
                    l = nt(u, c);
                if (!l) {
                    let h = {
                        channelCount: u.channelCount,
                        channelCountMode: u.channelCountMode,
                        channelInterpretation: u.channelInterpretation,
                        pan: u.pan.value,
                    };
                    u = t(c, h);
                }
                return (
                    n.set(c, u),
                    l ? await r(c, a.pan, u.pan) : await o(c, a.pan, u.pan),
                    pe(u) ? await s(a, c, u.inputs[0]) : await s(a, c, u),
                    u
                );
            };
        return {
            render(a, c) {
                let u = n.get(c);
                return u !== void 0 ? Promise.resolve(u) : i(a, c);
            },
        };
    };
    var Iu = r => () => {
        if (r === null) return !1;
        try {
            new r({ length: 1, sampleRate: 44100 });
        } catch {
            return !1;
        }
        return !0;
    };
    var Ru = (r, t) => async () => {
        if (r === null) return !0;
        if (t === null) return !1;
        let e = new Blob(
                [
                    'class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)',
                ],
                { type: 'application/javascript; charset=utf-8' }
            ),
            o = new t(1, 128, 44100),
            s = URL.createObjectURL(e),
            n = !1,
            i = !1;
        try {
            await o.audioWorklet.addModule(s);
            let a = new r(o, 'a', { numberOfOutputs: 0 }),
                c = o.createOscillator();
            (a.port.onmessage = () => (n = !0)),
                (a.onprocessorerror = () => (i = !0)),
                c.connect(a),
                c.start(0),
                await o.startRendering();
        } catch {
        } finally {
            URL.revokeObjectURL(s);
        }
        return n && !i;
    };
    var Pu = (r, t) => () => {
        if (t === null) return Promise.resolve(!1);
        let e = new t(1, 1, 44100),
            o = r(e, {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                gain: 0,
            });
        return new Promise(s => {
            (e.oncomplete = () => {
                o.disconnect(), s(e.currentTime !== 0);
            }),
                e.startRendering();
        });
    };
    var En = () => new DOMException('', 'UnknownError');
    var Ip = {
            channelCount: 2,
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            curve: null,
            oversample: 'none',
        },
        qu = (r, t, e, o, s, n, i) =>
            class extends r {
                constructor(c, u) {
                    let l = s(c),
                        h = { ...Ip, ...u },
                        p = e(l, h),
                        f = n(l) ? o() : null;
                    super(c, !0, p, f);
                    (this._isCurveNullified = !1), (this._nativeWaveShaperNode = p), i(this, 1);
                }
                get curve() {
                    return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve;
                }
                set curve(c) {
                    if (c === null)
                        (this._isCurveNullified = !0),
                            (this._nativeWaveShaperNode.curve = new Float32Array([0, 0]));
                    else {
                        if (c.length < 2) throw t();
                        (this._isCurveNullified = !1), (this._nativeWaveShaperNode.curve = c);
                    }
                }
                get oversample() {
                    return this._nativeWaveShaperNode.oversample;
                }
                set oversample(c) {
                    this._nativeWaveShaperNode.oversample = c;
                }
            };
    var Vu = (r, t, e) => () => {
        let o = new WeakMap(),
            s = async (n, i) => {
                let a = t(n);
                if (!nt(a, i)) {
                    let u = {
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        curve: a.curve,
                        oversample: a.oversample,
                    };
                    a = r(i, u);
                }
                return o.set(i, a), pe(a) ? await e(n, i, a.inputs[0]) : await e(n, i, a), a;
            };
        return {
            render(n, i) {
                let a = o.get(i);
                return a !== void 0 ? Promise.resolve(a) : s(n, i);
            },
        };
    };
    var Lu = () => (typeof window == 'undefined' ? null : window);
    var Wu = (r, t) => e => {
        (e.copyFromChannel = (o, s, n = 0) => {
            let i = r(n),
                a = r(s);
            if (a >= e.numberOfChannels) throw t();
            let c = e.length,
                u = e.getChannelData(a),
                l = o.length;
            for (let h = i < 0 ? -i : 0; h + i < c && h < l; h += 1) o[h] = u[h + i];
        }),
            (e.copyToChannel = (o, s, n = 0) => {
                let i = r(n),
                    a = r(s);
                if (a >= e.numberOfChannels) throw t();
                let c = e.length,
                    u = e.getChannelData(a),
                    l = o.length;
                for (let h = i < 0 ? -i : 0; h + i < c && h < l; h += 1) u[h + i] = o[h];
            });
    };
    var Bu = r => t => {
        (t.copyFromChannel = (
            e =>
            (o, s, n = 0) => {
                let i = r(n),
                    a = r(s);
                if (i < t.length) return e.call(t, o, a, i);
            }
        )(t.copyFromChannel)),
            (t.copyToChannel = (
                e =>
                (o, s, n = 0) => {
                    let i = r(n),
                        a = r(s);
                    if (i < t.length) return e.call(t, o, a, i);
                }
            )(t.copyToChannel));
    };
    var ju = r => (t, e) => {
        let o = e.createBuffer(1, 1, 44100);
        t.buffer === null && (t.buffer = o),
            r(
                t,
                'buffer',
                s => () => {
                    let n = s.call(t);
                    return n === o ? null : n;
                },
                s => n => s.call(t, n === null ? o : n)
            );
    };
    var Gu = (r, t) => (e, o) => {
        (o.channelCount = 1),
            (o.channelCountMode = 'explicit'),
            Object.defineProperty(o, 'channelCount', {
                get: () => 1,
                set: () => {
                    throw r();
                },
            }),
            Object.defineProperty(o, 'channelCountMode', {
                get: () => 'explicit',
                set: () => {
                    throw r();
                },
            });
        let s = e.createBufferSource();
        t(
            o,
            () => {
                let a = o.numberOfInputs;
                for (let c = 0; c < a; c += 1) s.connect(o, 0, c);
            },
            () => s.disconnect(o)
        );
    };
    var Mn = (r, t, e) =>
        r.copyFromChannel === void 0 ? r.getChannelData(e)[0] : (r.copyFromChannel(t, e), t[0]);
    var Fn = r => {
        if (r === null) return !1;
        let t = r.length;
        return t % 2 != 0 ? r[Math.floor(t / 2)] !== 0 : r[t / 2 - 1] + r[t / 2] !== 0;
    };
    var ar = (r, t, e, o) => {
        let s = r;
        for (; !s.hasOwnProperty(t); ) s = Object.getPrototypeOf(s);
        let { get: n, set: i } = Object.getOwnPropertyDescriptor(s, t);
        Object.defineProperty(r, t, { get: e(n), set: o(i) });
    };
    var zu = r => ({
        ...r,
        outputChannelCount:
            r.outputChannelCount !== void 0
                ? r.outputChannelCount
                : r.numberOfInputs === 1 && r.numberOfOutputs === 1
                ? [r.channelCount]
                : Array.from({ length: r.numberOfOutputs }, () => 1),
    });
    var Uu = r => ({ ...r, channelCount: r.numberOfOutputs });
    var Yu = r => {
        let { imag: t, real: e } = r;
        return t === void 0
            ? e === void 0
                ? { ...r, imag: [0, 0], real: [0, 0] }
                : { ...r, imag: Array.from(e, () => 0), real: e }
            : e === void 0
            ? { ...r, imag: t, real: Array.from(t, () => 0) }
            : { ...r, imag: t, real: e };
    };
    var In = (r, t, e) => {
        try {
            r.setValueAtTime(t, e);
        } catch (o) {
            if (o.code !== 9) throw o;
            In(r, t, e + 1e-7);
        }
    };
    var Hu = r => {
        let t = r.createBufferSource();
        t.start();
        try {
            t.start();
        } catch {
            return !0;
        }
        return !1;
    };
    var Xu = r => {
        let t = r.createBufferSource(),
            e = r.createBuffer(1, 1, 44100);
        t.buffer = e;
        try {
            t.start(0, 1);
        } catch {
            return !1;
        }
        return !0;
    };
    var Qu = r => {
        let t = r.createBufferSource();
        t.start();
        try {
            t.stop();
        } catch {
            return !1;
        }
        return !0;
    };
    var Ps = r => {
        let t = r.createOscillator();
        try {
            t.start(-1);
        } catch (e) {
            return e instanceof RangeError;
        }
        return !1;
    };
    var Rn = r => {
        let t = r.createBuffer(1, 1, 44100),
            e = r.createBufferSource();
        (e.buffer = t), e.start(), e.stop();
        try {
            return e.stop(), !0;
        } catch {
            return !1;
        }
    };
    var qs = r => {
        let t = r.createOscillator();
        try {
            t.stop(-1);
        } catch (e) {
            return e instanceof RangeError;
        }
        return !1;
    };
    var Zu = r => {
        let { port1: t, port2: e } = new MessageChannel();
        try {
            t.postMessage(r);
        } finally {
            t.close(), e.close();
        }
    };
    var $u = r => {
        r.start = (
            t =>
            (e = 0, o = 0, s) => {
                let n = r.buffer,
                    i = n === null ? o : Math.min(n.duration, o);
                n !== null && i > n.duration - 0.5 / r.context.sampleRate
                    ? t.call(r, e, 0, 0)
                    : t.call(r, e, i, s);
            }
        )(r.start);
    };
    var Pn = (r, t) => {
        let e = t.createGain();
        r.connect(e);
        let o = (s => () => {
            s.call(r, e), r.removeEventListener('ended', o);
        })(r.disconnect);
        r.addEventListener('ended', o),
            de(r, e),
            (r.stop = (s => {
                let n = !1;
                return (i = 0) => {
                    if (n)
                        try {
                            s.call(r, i);
                        } catch {
                            e.gain.setValueAtTime(0, i);
                        }
                    else s.call(r, i), (n = !0);
                };
            })(r.stop));
    };
    var To = (r, t) => e => {
        let o = { value: r };
        return (
            Object.defineProperties(e, { currentTarget: o, target: o }),
            typeof t == 'function' ? t.call(r, e) : t.handleEvent.call(r, e)
        );
    };
    var Rp = Wi(ve),
        Pp = Zi(ve),
        qp = Ya(no),
        Ku = new WeakMap(),
        Vp = cc(Ku),
        fe = ka(new Map(), new WeakMap()),
        Pe = Lu(),
        Ju = qc(fe, he),
        qn = ac(It),
        Gt = Cu(It, qn, He),
        Lp = ta(Ju, dt, Gt),
        mt = hc(Xo),
        Xe = uu(Pe),
        ft = Cc(Xe),
        tl = new WeakMap(),
        el = ec(To),
        cr = Bc(Pe),
        Vn = bc(cr),
        Ln = Tc(Pe),
        ol = Ac(Pe),
        Jr = Gc(Pe),
        Ct = _a(
            Bi(As),
            Qi(Rp, Pp, $o, qp, Ko, It, Vp, Ie, dt, ve, Kt, He, Jo),
            fe,
            _c(Xr, Ko, It, dt, wo, Kt),
            he,
            or,
            jt,
            Ga($o, Xr, It, dt, wo, mt, Kt, ft),
            Qa(tl, It, Ot),
            el,
            mt,
            Vn,
            Ln,
            ol,
            ft,
            Jr
        ),
        Wp = Ji(Ct, Lp, he, Ju, mt, ft);
    var Wn = new WeakSet(),
        rl = Vc(Pe),
        sl = qa(new Uint32Array(1)),
        Bn = Wu(sl, he),
        jn = Bu(sl),
        Bp = ea(Wn, fe, jt, rl, Xe, Iu(rl), Bn, jn);
    var Vs = $i(Jt),
        nl = ku(qn, io, He),
        qe = Ma(nl),
        ur = Wc(Vs, fe, Hu, Xu, Qu, Ps, Rn, qs, $u, ju(ar), Pn),
        Ve = Su(uc(io), nl),
        jp = sa(qe, ur, dt, Ve, Gt),
        be = ya(
            ji(Ss),
            tl,
            Hr,
            va,
            re.createCancelAndHoldAutomationEvent,
            re.createCancelScheduledValuesAutomationEvent,
            re.createExponentialRampToValueAutomationEvent,
            re.createLinearRampToValueAutomationEvent,
            re.createSetTargetAutomationEvent,
            re.createSetValueAutomationEvent,
            re.createSetValueCurveAutomationEvent,
            cr,
            In
        ),
        Gp = ra(Ct, jp, be, gt, ur, mt, ft, To);
    var zp = pa(Ct, da, he, gt, jc(Jt, ar), mt, ft, Gt),
        Up = Ca(qe, On, dt, Ve, Gt),
        Ao = Du(Ku),
        Yp = Sa(Ct, be, Up, or, On, mt, ft, Ao),
        uo = Rc(ve, Ln),
        Hp = Gu(gt, uo),
        lo = Zc(cr, Hp),
        Xp = Oa(lo, dt, Gt),
        Qp = Na(Ct, Xp, lo, mt, ft),
        Zp = Ea(nr, dt, Gt),
        $p = Da(Ct, Zp, nr, mt, ft, Uu),
        Kp = Jc(Vs, ur, Jt, uo),
        lr = Kc(Vs, fe, Kp, Ps, qs),
        Jp = Pa(qe, lr, dt, Ve, Gt),
        td = Ra(Ct, be, Jp, lr, mt, ft, To),
        il = tu(jt, ar),
        ed = La(il, dt, Gt),
        od = Va(Ct, ed, il, mt, ft, Ao),
        rd = Ua(qe, Dn, dt, Ve, Gt),
        sd = za(Ct, be, rd, Dn, mt, ft, Ao),
        al = eu(jt),
        nd = Ka(qe, al, dt, Ve, Gt),
        id = $a(Ct, be, nd, al, jt, mt, ft, Ao),
        ad = nc(qe, Jt, dt, Ve, Gt),
        cd = sc(Ct, be, ad, Jt, mt, ft),
        ud = su(or, gt, ir, jt),
        Ls = Nu(fe, Jt, ir, Pu(Jt, Xe)),
        ld = gc(ur, dt, Xe, Gt, Ls),
        hd = ou(ud),
        pd = mc(Ct, hd, ld, mt, ft, Ao),
        dd = fa(be, lo, lr, ir, jt, Mn, ft, ar),
        cl = new WeakMap(),
        Gn = Fc(zp, dd, el, ft, cl, To),
        ul = lu(Vs, fe, Ps, Rn, qs, Pn),
        fd = vu(qe, ul, dt, Ve, Gt),
        md = yu(Ct, be, ul, fd, mt, ft, To),
        ll = Ia(ur),
        gd = _u(ll, gt, Jt, Fn, uo),
        Ws = gu(ll, gt, gd, Fn, uo, cr, ar),
        _d = pu($o, gt, lo, Jt, ir, Ws, jt, Ko, Mn, uo),
        hl = hu(_d),
        xd = bu(qe, lo, lr, Jt, hl, dt, Xe, Ve, Gt, Ls),
        yd = wu(Ct, be, hl, xd, mt, ft, Ao),
        vd = du(he),
        wd = Tu(vd, mt, new WeakSet(), Yu),
        bd = mu(lo, nr, Jt, Ws, jt, uo),
        pl = fu(bd, jt),
        Td = Fu(qe, pl, dt, Ve, Gt),
        Ad = Mu(Ct, be, pl, Td, mt, ft),
        Sd = Vu(Ws, dt, Gt),
        Cd = qu(Ct, gt, Ws, Sd, mt, ft, Ao),
        dl = kc(Pe),
        zn = oc(Pe),
        fl = new WeakMap(),
        kd = pc(fl, Xe),
        Nd = dl
            ? Xi(
                  fe,
                  jt,
                  tc(Pe),
                  zn,
                  rc(Li),
                  mt,
                  kd,
                  ft,
                  Jr,
                  new WeakMap(),
                  new WeakMap(),
                  Ru(Jr, Xe),
                  Pe
              )
            : void 0,
        Od = Sc(Vn, ft),
        Dd = ja(Wn, fe, Ba, Ja, new WeakSet(), mt, Od, Qo, we, Bn, jn),
        ml = Aa(Nd, Wp, Bp, Gp, Yp, Qp, $p, td, od, Dd, sd, id, cd, pd, Gn, md, yd, wd, Ad, Cd),
        Ed = Nc(Ct, nu, mt, ft),
        Md = Oc(Ct, iu, mt, ft),
        Fd = Dc(Ct, au, mt, ft),
        Id = cu(gt, ft),
        Rd = Ec(Ct, Id, mt),
        gl = ha(ml, gt, jt, En, Ed, Md, Fd, Rd, cr);
    var Un = dc(cl),
        Pd = Ki(Un),
        _l = Fa(he),
        qd = Ha(Un),
        xl = Za(he),
        yl = new WeakMap(),
        Vd = ic(yl, Ot),
        Ld = Qc(_l, he, gt, lo, nr, lr, Jt, ir, jt, xl, zn, Vd, uo),
        Wd = Uc(gt, Ld, Jt, jt, uo),
        Bd = Ta(qe, _l, ur, lo, nr, lr, Jt, qd, xl, zn, dt, Jr, Xe, Ve, Gt, Ls),
        jd = lc(fl),
        Gd = Ou(yl),
        Yn = dl ? wa(Pd, Ct, be, Bd, Wd, It, jd, mt, ft, Jr, zu, Gd, Zu, To) : void 0;
    var cG = Mc(gt, jt, En, Gn, cr);
    var vl = Wa(jt, Xe),
        wl = Eu(Wn, fe, qn, Un, Ls, Qo, Bn, jn),
        uG = Ic(fe, gt, vl, Gn, wl);
    var bl = xu(ml, fe, gt, vl, wl);
    var Tl = xc(Xo, Vn),
        Al = yc(Ho, Ln),
        Sl = vc(Hr, ol),
        Cl = wc(Xo, ft);
    function j(r, t) {
        if (!r) throw new Error(t);
    }
    function qt(r, t, e = 1 / 0) {
        if (!(t <= r && r <= e))
            throw new RangeError(`Value must be within [${t}, ${e}], got: ${r}`);
    }
    function Bs(r) {
        !r.isOffline &&
            r.state !== 'running' &&
            ts(
                'The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.'
            );
    }
    var kl = console;
    function Nl(...r) {
        kl.log(...r);
    }
    function ts(...r) {
        kl.warn(...r);
    }
    function Dt(r) {
        return typeof r == 'undefined';
    }
    function Q(r) {
        return !Dt(r);
    }
    function Ol(r) {
        return typeof r == 'function';
    }
    function Yt(r) {
        return typeof r == 'number';
    }
    function Te(r) {
        return Object.prototype.toString.call(r) === '[object Object]' && r.constructor === Object;
    }
    function Hn(r) {
        return typeof r == 'boolean';
    }
    function kt(r) {
        return Array.isArray(r);
    }
    function Vt(r) {
        return typeof r == 'string';
    }
    function es(r) {
        return Vt(r) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(r);
    }
    function Dl(r) {
        return new gl(r);
    }
    function El(r, t, e) {
        return new bl(r, t, e);
    }
    var Le = typeof self == 'object' ? self : null,
        Ml = Le && (Le.hasOwnProperty('AudioContext') || Le.hasOwnProperty('webkitAudioContext'));
    function Fl(r, t, e) {
        return (
            j(Q(Yn), 'This node only works in a secure context (https or localhost)'),
            new Yn(r, t, e)
        );
    }
    var eh = rn(th()),
        {
            __extends: vG,
            __assign: wG,
            __rest: bG,
            __decorate: Ht,
            __param: TG,
            __metadata: AG,
            __awaiter: et,
            __generator: SG,
            __exportStar: CG,
            __createBinding: kG,
            __values: NG,
            __read: OG,
            __spread: DG,
            __spreadArrays: EG,
            __spreadArray: MG,
            __await: FG,
            __asyncGenerator: IG,
            __asyncDelegator: RG,
            __asyncValues: PG,
            __makeTemplateObject: qG,
            __importStar: VG,
            __importDefault: LG,
            __classPrivateFieldGet: WG,
            __classPrivateFieldSet: BG,
        } = eh.default;
    var Qn = class {
        constructor(t, e, o) {
            (this._callback = t), (this._type = e), (this._updateInterval = o), this._createClock();
        }
        _createWorker() {
            let t = new Blob(
                    [
                        `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`,
                    ],
                    { type: 'text/javascript' }
                ),
                e = URL.createObjectURL(t),
                o = new Worker(e);
            (o.onmessage = this._callback.bind(this)), (this._worker = o);
        }
        _createTimeout() {
            this._timeout = setTimeout(() => {
                this._createTimeout(), this._callback();
            }, this._updateInterval * 1e3);
        }
        _createClock() {
            if (this._type === 'worker')
                try {
                    this._createWorker();
                } catch {
                    (this._type = 'timeout'), this._createClock();
                }
            else this._type === 'timeout' && this._createTimeout();
        }
        _disposeClock() {
            this._timeout && (clearTimeout(this._timeout), (this._timeout = 0)),
                this._worker && (this._worker.terminate(), (this._worker.onmessage = null));
        }
        get updateInterval() {
            return this._updateInterval;
        }
        set updateInterval(t) {
            (this._updateInterval = Math.max(t, 128 / 44100)),
                this._type === 'worker' && this._worker.postMessage(Math.max(t * 1e3, 1));
        }
        get type() {
            return this._type;
        }
        set type(t) {
            this._disposeClock(), (this._type = t), this._createClock();
        }
        dispose() {
            this._disposeClock();
        }
    };
    function Ae(r) {
        return Sl(r);
    }
    function We(r) {
        return Al(r);
    }
    function pr(r) {
        return Cl(r);
    }
    function ho(r) {
        return Tl(r);
    }
    function Us(r) {
        return r instanceof AudioBuffer;
    }
    function Yd(r, t) {
        return r === 'value' || Ae(t) || We(t) || Us(t);
    }
    function me(r, ...t) {
        if (!t.length) return r;
        let e = t.shift();
        if (Te(r) && Te(e))
            for (let o in e)
                Yd(o, e[o])
                    ? (r[o] = e[o])
                    : Te(e[o])
                    ? (r[o] || Object.assign(r, { [o]: {} }), me(r[o], e[o]))
                    : Object.assign(r, { [o]: e[o] });
        return me(r, ...t);
    }
    function oh(r, t) {
        return r.length === t.length && r.every((e, o) => t[o] === e);
    }
    function g(r, t, e = [], o) {
        let s = {},
            n = Array.from(t);
        if (
            (Te(n[0]) &&
                o &&
                !Reflect.has(n[0], o) &&
                (Object.keys(n[0]).some(a => Reflect.has(r, a)) ||
                    (me(s, { [o]: n[0] }), e.splice(e.indexOf(o), 1), n.shift())),
            n.length === 1 && Te(n[0]))
        )
            me(s, n[0]);
        else for (let i = 0; i < e.length; i++) Q(n[i]) && (s[e[i]] = n[i]);
        return me(r, s);
    }
    function rh(r) {
        return r.constructor.getDefaults();
    }
    function ce(r, t) {
        return Dt(r) ? t : r;
    }
    function Se(r, t) {
        return (
            t.forEach(e => {
                Reflect.has(r, e) && delete r[e];
            }),
            r
        );
    }
    var Lt = class {
        constructor() {
            (this.debug = !1), (this._wasDisposed = !1);
        }
        static getDefaults() {
            return {};
        }
        log(...t) {
            (this.debug || (Le && this.toString() === Le.TONE_DEBUG_CLASS)) && Nl(this, ...t);
        }
        dispose() {
            return (this._wasDisposed = !0), this;
        }
        get disposed() {
            return this._wasDisposed;
        }
        toString() {
            return this.name;
        }
    };
    Lt.version = Vr;
    var Zn = 1e-6;
    function dr(r, t) {
        return r > t + Zn;
    }
    function os(r, t) {
        return dr(r, t) || te(r, t);
    }
    function Ys(r, t) {
        return r + Zn < t;
    }
    function te(r, t) {
        return Math.abs(r - t) < Zn;
    }
    function $n(r, t, e) {
        return Math.max(Math.min(r, e), t);
    }
    var Rt = class extends Lt {
        constructor() {
            super();
            (this.name = 'Timeline'), (this._timeline = []);
            let t = g(Rt.getDefaults(), arguments, ['memory']);
            (this.memory = t.memory), (this.increasing = t.increasing);
        }
        static getDefaults() {
            return { memory: 1 / 0, increasing: !1 };
        }
        get length() {
            return this._timeline.length;
        }
        add(t) {
            if (
                (j(Reflect.has(t, 'time'), 'Timeline: events must have a time attribute'),
                (t.time = t.time.valueOf()),
                this.increasing && this.length)
            ) {
                let e = this._timeline[this.length - 1];
                j(
                    os(t.time, e.time),
                    'The time must be greater than or equal to the last scheduled time'
                ),
                    this._timeline.push(t);
            } else {
                let e = this._search(t.time);
                this._timeline.splice(e + 1, 0, t);
            }
            if (this.length > this.memory) {
                let e = this.length - this.memory;
                this._timeline.splice(0, e);
            }
            return this;
        }
        remove(t) {
            let e = this._timeline.indexOf(t);
            return e !== -1 && this._timeline.splice(e, 1), this;
        }
        get(t, e = 'time') {
            let o = this._search(t, e);
            return o !== -1 ? this._timeline[o] : null;
        }
        peek() {
            return this._timeline[0];
        }
        shift() {
            return this._timeline.shift();
        }
        getAfter(t, e = 'time') {
            let o = this._search(t, e);
            return o + 1 < this._timeline.length ? this._timeline[o + 1] : null;
        }
        getBefore(t) {
            let e = this._timeline.length;
            if (e > 0 && this._timeline[e - 1].time < t) return this._timeline[e - 1];
            let o = this._search(t);
            return o - 1 >= 0 ? this._timeline[o - 1] : null;
        }
        cancel(t) {
            if (this._timeline.length > 1) {
                let e = this._search(t);
                if (e >= 0)
                    if (te(this._timeline[e].time, t)) {
                        for (let o = e; o >= 0 && te(this._timeline[o].time, t); o--) e = o;
                        this._timeline = this._timeline.slice(0, e);
                    } else this._timeline = this._timeline.slice(0, e + 1);
                else this._timeline = [];
            } else
                this._timeline.length === 1 &&
                    os(this._timeline[0].time, t) &&
                    (this._timeline = []);
            return this;
        }
        cancelBefore(t) {
            let e = this._search(t);
            return e >= 0 && (this._timeline = this._timeline.slice(e + 1)), this;
        }
        previousEvent(t) {
            let e = this._timeline.indexOf(t);
            return e > 0 ? this._timeline[e - 1] : null;
        }
        _search(t, e = 'time') {
            if (this._timeline.length === 0) return -1;
            let o = 0,
                s = this._timeline.length,
                n = s;
            if (s > 0 && this._timeline[s - 1][e] <= t) return s - 1;
            for (; o < n; ) {
                let i = Math.floor(o + (n - o) / 2),
                    a = this._timeline[i],
                    c = this._timeline[i + 1];
                if (te(a[e], t)) {
                    for (let u = i; u < this._timeline.length; u++) {
                        let l = this._timeline[u];
                        if (te(l[e], t)) i = u;
                        else break;
                    }
                    return i;
                } else {
                    if (Ys(a[e], t) && dr(c[e], t)) return i;
                    dr(a[e], t) ? (n = i) : (o = i + 1);
                }
            }
            return -1;
        }
        _iterate(t, e = 0, o = this._timeline.length - 1) {
            this._timeline.slice(e, o + 1).forEach(t);
        }
        forEach(t) {
            return this._iterate(t), this;
        }
        forEachBefore(t, e) {
            let o = this._search(t);
            return o !== -1 && this._iterate(e, 0, o), this;
        }
        forEachAfter(t, e) {
            let o = this._search(t);
            return this._iterate(e, o + 1), this;
        }
        forEachBetween(t, e, o) {
            let s = this._search(t),
                n = this._search(e);
            return (
                s !== -1 && n !== -1
                    ? (this._timeline[s].time !== t && (s += 1),
                      this._timeline[n].time === e && (n -= 1),
                      this._iterate(o, s, n))
                    : s === -1 && this._iterate(o, 0, n),
                this
            );
        }
        forEachFrom(t, e) {
            let o = this._search(t);
            for (; o >= 0 && this._timeline[o].time >= t; ) o--;
            return this._iterate(e, o + 1), this;
        }
        forEachAtTime(t, e) {
            let o = this._search(t);
            if (o !== -1 && te(this._timeline[o].time, t)) {
                let s = o;
                for (let n = o; n >= 0 && te(this._timeline[n].time, t); n--) s = n;
                this._iterate(
                    n => {
                        e(n);
                    },
                    s,
                    o
                );
            }
            return this;
        }
        dispose() {
            return super.dispose(), (this._timeline = []), this;
        }
    };
    var sh = [];
    function po(r) {
        sh.push(r);
    }
    function nh(r) {
        sh.forEach(t => t(r));
    }
    var ih = [];
    function fo(r) {
        ih.push(r);
    }
    function ah(r) {
        ih.forEach(t => t(r));
    }
    var Qe = class extends Lt {
        constructor() {
            super(...arguments);
            this.name = 'Emitter';
        }
        on(t, e) {
            return (
                t.split(/\W+/).forEach(s => {
                    Dt(this._events) && (this._events = {}),
                        this._events.hasOwnProperty(s) || (this._events[s] = []),
                        this._events[s].push(e);
                }),
                this
            );
        }
        once(t, e) {
            let o = (...s) => {
                e(...s), this.off(t, o);
            };
            return this.on(t, o), this;
        }
        off(t, e) {
            return (
                t.split(/\W+/).forEach(s => {
                    if ((Dt(this._events) && (this._events = {}), this._events.hasOwnProperty(t)))
                        if (Dt(e)) this._events[t] = [];
                        else {
                            let n = this._events[t];
                            for (let i = n.length - 1; i >= 0; i--) n[i] === e && n.splice(i, 1);
                        }
                }),
                this
            );
        }
        emit(t, ...e) {
            if (this._events && this._events.hasOwnProperty(t)) {
                let o = this._events[t].slice(0);
                for (let s = 0, n = o.length; s < n; s++) o[s].apply(this, e);
            }
            return this;
        }
        static mixin(t) {
            ['on', 'once', 'off', 'emit'].forEach(e => {
                let o = Object.getOwnPropertyDescriptor(Qe.prototype, e);
                Object.defineProperty(t.prototype, e, o);
            });
        }
        dispose() {
            return super.dispose(), (this._events = void 0), this;
        }
    };
    var rs = class extends Qe {
        constructor() {
            super(...arguments);
            this.isOffline = !1;
        }
        toJSON() {
            return {};
        }
    };
    var mo = class extends rs {
        constructor() {
            super();
            (this.name = 'Context'),
                (this._constants = new Map()),
                (this._timeouts = new Rt()),
                (this._timeoutIds = 0),
                (this._initialized = !1),
                (this.isOffline = !1),
                (this._workletModules = new Map());
            let t = g(mo.getDefaults(), arguments, ['context']);
            t.context
                ? (this._context = t.context)
                : (this._context = Dl({ latencyHint: t.latencyHint })),
                (this._ticker = new Qn(
                    this.emit.bind(this, 'tick'),
                    t.clockSource,
                    t.updateInterval
                )),
                this.on('tick', this._timeoutLoop.bind(this)),
                (this._context.onstatechange = () => {
                    this.emit('statechange', this.state);
                }),
                this._setLatencyHint(t.latencyHint),
                (this.lookAhead = t.lookAhead);
        }
        static getDefaults() {
            return {
                clockSource: 'worker',
                latencyHint: 'interactive',
                lookAhead: 0.1,
                updateInterval: 0.05,
            };
        }
        initialize() {
            return this._initialized || (nh(this), (this._initialized = !0)), this;
        }
        createAnalyser() {
            return this._context.createAnalyser();
        }
        createOscillator() {
            return this._context.createOscillator();
        }
        createBufferSource() {
            return this._context.createBufferSource();
        }
        createBiquadFilter() {
            return this._context.createBiquadFilter();
        }
        createBuffer(t, e, o) {
            return this._context.createBuffer(t, e, o);
        }
        createChannelMerger(t) {
            return this._context.createChannelMerger(t);
        }
        createChannelSplitter(t) {
            return this._context.createChannelSplitter(t);
        }
        createConstantSource() {
            return this._context.createConstantSource();
        }
        createConvolver() {
            return this._context.createConvolver();
        }
        createDelay(t) {
            return this._context.createDelay(t);
        }
        createDynamicsCompressor() {
            return this._context.createDynamicsCompressor();
        }
        createGain() {
            return this._context.createGain();
        }
        createIIRFilter(t, e) {
            return this._context.createIIRFilter(t, e);
        }
        createPanner() {
            return this._context.createPanner();
        }
        createPeriodicWave(t, e, o) {
            return this._context.createPeriodicWave(t, e, o);
        }
        createStereoPanner() {
            return this._context.createStereoPanner();
        }
        createWaveShaper() {
            return this._context.createWaveShaper();
        }
        createMediaStreamSource(t) {
            return (
                j(ho(this._context), 'Not available if OfflineAudioContext'),
                this._context.createMediaStreamSource(t)
            );
        }
        createMediaElementSource(t) {
            return (
                j(ho(this._context), 'Not available if OfflineAudioContext'),
                this._context.createMediaElementSource(t)
            );
        }
        createMediaStreamDestination() {
            return (
                j(ho(this._context), 'Not available if OfflineAudioContext'),
                this._context.createMediaStreamDestination()
            );
        }
        decodeAudioData(t) {
            return this._context.decodeAudioData(t);
        }
        get currentTime() {
            return this._context.currentTime;
        }
        get state() {
            return this._context.state;
        }
        get sampleRate() {
            return this._context.sampleRate;
        }
        get listener() {
            return this.initialize(), this._listener;
        }
        set listener(t) {
            j(!this._initialized, 'The listener cannot be set after initialization.'),
                (this._listener = t);
        }
        get transport() {
            return this.initialize(), this._transport;
        }
        set transport(t) {
            j(!this._initialized, 'The transport cannot be set after initialization.'),
                (this._transport = t);
        }
        get draw() {
            return this.initialize(), this._draw;
        }
        set draw(t) {
            j(!this._initialized, 'Draw cannot be set after initialization.'), (this._draw = t);
        }
        get destination() {
            return this.initialize(), this._destination;
        }
        set destination(t) {
            j(!this._initialized, 'The destination cannot be set after initialization.'),
                (this._destination = t);
        }
        createAudioWorkletNode(t, e) {
            return Fl(this.rawContext, t, e);
        }
        addAudioWorkletModule(t, e) {
            return et(this, void 0, void 0, function* () {
                j(
                    Q(this.rawContext.audioWorklet),
                    'AudioWorkletNode is only available in a secure context (https or localhost)'
                ),
                    this._workletModules.has(e) ||
                        this._workletModules.set(e, this.rawContext.audioWorklet.addModule(t)),
                    yield this._workletModules.get(e);
            });
        }
        workletsAreReady() {
            return et(this, void 0, void 0, function* () {
                let t = [];
                this._workletModules.forEach(e => t.push(e)), yield Promise.all(t);
            });
        }
        get updateInterval() {
            return this._ticker.updateInterval;
        }
        set updateInterval(t) {
            this._ticker.updateInterval = t;
        }
        get clockSource() {
            return this._ticker.type;
        }
        set clockSource(t) {
            this._ticker.type = t;
        }
        get latencyHint() {
            return this._latencyHint;
        }
        _setLatencyHint(t) {
            let e = 0;
            if (((this._latencyHint = t), Vt(t)))
                switch (t) {
                    case 'interactive':
                        e = 0.1;
                        break;
                    case 'playback':
                        e = 0.5;
                        break;
                    case 'balanced':
                        e = 0.25;
                        break;
                }
            (this.lookAhead = e), (this.updateInterval = e / 2);
        }
        get rawContext() {
            return this._context;
        }
        now() {
            return this._context.currentTime + this.lookAhead;
        }
        immediate() {
            return this._context.currentTime;
        }
        resume() {
            return ho(this._context) ? this._context.resume() : Promise.resolve();
        }
        close() {
            return et(this, void 0, void 0, function* () {
                ho(this._context) && (yield this._context.close()), this._initialized && ah(this);
            });
        }
        getConstant(t) {
            if (this._constants.has(t)) return this._constants.get(t);
            {
                let e = this._context.createBuffer(1, 128, this._context.sampleRate),
                    o = e.getChannelData(0);
                for (let n = 0; n < o.length; n++) o[n] = t;
                let s = this._context.createBufferSource();
                return (
                    (s.channelCount = 1),
                    (s.channelCountMode = 'explicit'),
                    (s.buffer = e),
                    (s.loop = !0),
                    s.start(0),
                    this._constants.set(t, s),
                    s
                );
            }
        }
        dispose() {
            return (
                super.dispose(),
                this._ticker.dispose(),
                this._timeouts.dispose(),
                Object.keys(this._constants).map(t => this._constants[t].disconnect()),
                this
            );
        }
        _timeoutLoop() {
            let t = this.now(),
                e = this._timeouts.peek();
            for (; this._timeouts.length && e && e.time <= t; )
                e.callback(), this._timeouts.shift(), (e = this._timeouts.peek());
        }
        setTimeout(t, e) {
            this._timeoutIds++;
            let o = this.now();
            return (
                this._timeouts.add({ callback: t, id: this._timeoutIds, time: o + e }),
                this._timeoutIds
            );
        }
        clearTimeout(t) {
            return (
                this._timeouts.forEach(e => {
                    e.id === t && this._timeouts.remove(e);
                }),
                this
            );
        }
        clearInterval(t) {
            return this.clearTimeout(t);
        }
        setInterval(t, e) {
            let o = ++this._timeoutIds,
                s = () => {
                    let n = this.now();
                    this._timeouts.add({
                        callback: () => {
                            t(), s();
                        },
                        id: o,
                        time: n + e,
                    });
                };
            return s(), o;
        }
    };
    var Kn = class extends rs {
        constructor() {
            super(...arguments);
            (this.lookAhead = 0), (this.latencyHint = 0), (this.isOffline = !1);
        }
        createAnalyser() {
            return {};
        }
        createOscillator() {
            return {};
        }
        createBufferSource() {
            return {};
        }
        createBiquadFilter() {
            return {};
        }
        createBuffer(t, e, o) {
            return {};
        }
        createChannelMerger(t) {
            return {};
        }
        createChannelSplitter(t) {
            return {};
        }
        createConstantSource() {
            return {};
        }
        createConvolver() {
            return {};
        }
        createDelay(t) {
            return {};
        }
        createDynamicsCompressor() {
            return {};
        }
        createGain() {
            return {};
        }
        createIIRFilter(t, e) {
            return {};
        }
        createPanner() {
            return {};
        }
        createPeriodicWave(t, e, o) {
            return {};
        }
        createStereoPanner() {
            return {};
        }
        createWaveShaper() {
            return {};
        }
        createMediaStreamSource(t) {
            return {};
        }
        createMediaElementSource(t) {
            return {};
        }
        createMediaStreamDestination() {
            return {};
        }
        decodeAudioData(t) {
            return Promise.resolve({});
        }
        createAudioWorkletNode(t, e) {
            return {};
        }
        get rawContext() {
            return {};
        }
        addAudioWorkletModule(t, e) {
            return et(this, void 0, void 0, function* () {
                return Promise.resolve();
            });
        }
        resume() {
            return Promise.resolve();
        }
        setTimeout(t, e) {
            return 0;
        }
        clearTimeout(t) {
            return this;
        }
        setInterval(t, e) {
            return 0;
        }
        clearInterval(t) {
            return this;
        }
        getConstant(t) {
            return {};
        }
        get currentTime() {
            return 0;
        }
        get state() {
            return {};
        }
        get sampleRate() {
            return 0;
        }
        get listener() {
            return {};
        }
        get transport() {
            return {};
        }
        get draw() {
            return {};
        }
        set draw(t) {}
        get destination() {
            return {};
        }
        set destination(t) {}
        now() {
            return 0;
        }
        immediate() {
            return 0;
        }
    };
    function M(r, t) {
        kt(t)
            ? t.forEach(e => M(r, e))
            : Object.defineProperty(r, t, { enumerable: !0, writable: !1 });
    }
    function So(r, t) {
        kt(t) ? t.forEach(e => So(r, e)) : Object.defineProperty(r, t, { writable: !0 });
    }
    var $ = () => {};
    var st = class extends Lt {
        constructor() {
            super();
            (this.name = 'ToneAudioBuffer'), (this.onload = $);
            let t = g(st.getDefaults(), arguments, ['url', 'onload', 'onerror']);
            (this.reverse = t.reverse),
                (this.onload = t.onload),
                (t.url && Us(t.url)) || t.url instanceof st
                    ? this.set(t.url)
                    : Vt(t.url) && this.load(t.url).catch(t.onerror);
        }
        static getDefaults() {
            return { onerror: $, onload: $, reverse: !1 };
        }
        get sampleRate() {
            return this._buffer ? this._buffer.sampleRate : Nt().sampleRate;
        }
        set(t) {
            return (
                t instanceof st
                    ? t.loaded
                        ? (this._buffer = t.get())
                        : (t.onload = () => {
                              this.set(t), this.onload(this);
                          })
                    : (this._buffer = t),
                this._reversed && this._reverse(),
                this
            );
        }
        get() {
            return this._buffer;
        }
        load(t) {
            return et(this, void 0, void 0, function* () {
                let e = st.load(t).then(o => {
                    this.set(o), this.onload(this);
                });
                st.downloads.push(e);
                try {
                    yield e;
                } finally {
                    let o = st.downloads.indexOf(e);
                    st.downloads.splice(o, 1);
                }
                return this;
            });
        }
        dispose() {
            return super.dispose(), (this._buffer = void 0), this;
        }
        fromArray(t) {
            let e = kt(t) && t[0].length > 0,
                o = e ? t.length : 1,
                s = e ? t[0].length : t.length,
                n = Nt(),
                i = n.createBuffer(o, s, n.sampleRate),
                a = !e && o === 1 ? [t] : t;
            for (let c = 0; c < o; c++) i.copyToChannel(a[c], c);
            return (this._buffer = i), this;
        }
        toMono(t) {
            if (Yt(t)) this.fromArray(this.toArray(t));
            else {
                let e = new Float32Array(this.length),
                    o = this.numberOfChannels;
                for (let s = 0; s < o; s++) {
                    let n = this.toArray(s);
                    for (let i = 0; i < n.length; i++) e[i] += n[i];
                }
                (e = e.map(s => s / o)), this.fromArray(e);
            }
            return this;
        }
        toArray(t) {
            if (Yt(t)) return this.getChannelData(t);
            if (this.numberOfChannels === 1) return this.toArray(0);
            {
                let e = [];
                for (let o = 0; o < this.numberOfChannels; o++) e[o] = this.getChannelData(o);
                return e;
            }
        }
        getChannelData(t) {
            return this._buffer ? this._buffer.getChannelData(t) : new Float32Array(0);
        }
        slice(t, e = this.duration) {
            let o = Math.floor(t * this.sampleRate),
                s = Math.floor(e * this.sampleRate);
            j(o < s, 'The start time must be less than the end time');
            let n = s - o,
                i = Nt().createBuffer(this.numberOfChannels, n, this.sampleRate);
            for (let a = 0; a < this.numberOfChannels; a++)
                i.copyToChannel(this.getChannelData(a).subarray(o, s), a);
            return new st(i);
        }
        _reverse() {
            if (this.loaded)
                for (let t = 0; t < this.numberOfChannels; t++) this.getChannelData(t).reverse();
            return this;
        }
        get loaded() {
            return this.length > 0;
        }
        get duration() {
            return this._buffer ? this._buffer.duration : 0;
        }
        get length() {
            return this._buffer ? this._buffer.length : 0;
        }
        get numberOfChannels() {
            return this._buffer ? this._buffer.numberOfChannels : 0;
        }
        get reverse() {
            return this._reversed;
        }
        set reverse(t) {
            this._reversed !== t && ((this._reversed = t), this._reverse());
        }
        static fromArray(t) {
            return new st().fromArray(t);
        }
        static fromUrl(t) {
            return et(this, void 0, void 0, function* () {
                return yield new st().load(t);
            });
        }
        static load(t) {
            return et(this, void 0, void 0, function* () {
                let e = t.match(/\[([^\]\[]+\|.+)\]$/);
                if (e) {
                    let a = e[1].split('|'),
                        c = a[0];
                    for (let u of a)
                        if (st.supportsType(u)) {
                            c = u;
                            break;
                        }
                    t = t.replace(e[0], c);
                }
                let o =
                        st.baseUrl === '' || st.baseUrl.endsWith('/')
                            ? st.baseUrl
                            : st.baseUrl + '/',
                    s = yield fetch(o + t);
                if (!s.ok) throw new Error(`could not load url: ${t}`);
                let n = yield s.arrayBuffer();
                return yield Nt().decodeAudioData(n);
            });
        }
        static supportsType(t) {
            let e = t.split('.'),
                o = e[e.length - 1];
            return document.createElement('audio').canPlayType('audio/' + o) !== '';
        }
        static loaded() {
            return et(this, void 0, void 0, function* () {
                for (yield Promise.resolve(); st.downloads.length; ) yield st.downloads[0];
            });
        }
    };
    st.baseUrl = '';
    st.downloads = [];
    var Ze = class extends mo {
        constructor() {
            super({
                clockSource: 'offline',
                context: pr(arguments[0])
                    ? arguments[0]
                    : El(arguments[0], arguments[1] * arguments[2], arguments[2]),
                lookAhead: 0,
                updateInterval: pr(arguments[0])
                    ? 128 / arguments[0].sampleRate
                    : 128 / arguments[2],
            });
            (this.name = 'OfflineContext'),
                (this._currentTime = 0),
                (this.isOffline = !0),
                (this._duration = pr(arguments[0])
                    ? arguments[0].length / arguments[0].sampleRate
                    : arguments[1]);
        }
        now() {
            return this._currentTime;
        }
        get currentTime() {
            return this._currentTime;
        }
        _renderClock(t) {
            return et(this, void 0, void 0, function* () {
                let e = 0;
                for (; this._duration - this._currentTime >= 0; ) {
                    this.emit('tick'), (this._currentTime += 128 / this.sampleRate), e++;
                    let o = Math.floor(this.sampleRate / 128);
                    t && e % o == 0 && (yield new Promise(s => setTimeout(s, 1)));
                }
            });
        }
        render(t = !0) {
            return et(this, void 0, void 0, function* () {
                yield this.workletsAreReady(), yield this._renderClock(t);
                let e = yield this._context.startRendering();
                return new st(e);
            });
        }
        close() {
            return Promise.resolve();
        }
    };
    var ch = new Kn(),
        ss = ch;
    function Nt() {
        return ss === ch && Ml && ns(new mo()), ss;
    }
    function ns(r) {
        ho(r) ? (ss = new mo(r)) : pr(r) ? (ss = new Ze(r)) : (ss = r);
    }
    if (Le && !Le.TONE_SILENCE_LOGGING) {
        let r = 'v';
        Vr === 'dev' && (r = '');
        let t = ` * Tone.js ${r}${Vr} * `;
        console.log(`%c${t}`, 'background: #000; color: #fff');
    }
    function fr(r) {
        return Math.pow(10, r / 20);
    }
    function mr(r) {
        return 20 * (Math.log(r) / Math.LN10);
    }
    function Co(r) {
        return Math.pow(2, r / 12);
    }
    var Hs = 440;
    function uh() {
        return Hs;
    }
    function lh(r) {
        Hs = r;
    }
    function ko(r) {
        return Math.round(Jn(r));
    }
    function Jn(r) {
        return 69 + 12 * Math.log2(r / Hs);
    }
    function Xs(r) {
        return Hs * Math.pow(2, (r - 69) / 12);
    }
    var is = class extends Lt {
        constructor(t, e, o) {
            super();
            (this.defaultUnits = 's'),
                (this._val = e),
                (this._units = o),
                (this.context = t),
                (this._expressions = this._getExpressions());
        }
        _getExpressions() {
            return {
                hz: {
                    method: t => this._frequencyToUnits(parseFloat(t)),
                    regexp: /^(\d+(?:\.\d+)?)hz$/i,
                },
                i: { method: t => this._ticksToUnits(parseInt(t, 10)), regexp: /^(\d+)i$/i },
                m: {
                    method: t => this._beatsToUnits(parseInt(t, 10) * this._getTimeSignature()),
                    regexp: /^(\d+)m$/i,
                },
                n: {
                    method: (t, e) => {
                        let o = parseInt(t, 10),
                            s = e === '.' ? 1.5 : 1;
                        return o === 1
                            ? this._beatsToUnits(this._getTimeSignature()) * s
                            : this._beatsToUnits(4 / o) * s;
                    },
                    regexp: /^(\d+)n(\.?)$/i,
                },
                number: {
                    method: t => this._expressions[this.defaultUnits].method.call(this, t),
                    regexp: /^(\d+(?:\.\d+)?)$/,
                },
                s: {
                    method: t => this._secondsToUnits(parseFloat(t)),
                    regexp: /^(\d+(?:\.\d+)?)s$/,
                },
                samples: {
                    method: t => parseInt(t, 10) / this.context.sampleRate,
                    regexp: /^(\d+)samples$/,
                },
                t: {
                    method: t => {
                        let e = parseInt(t, 10);
                        return this._beatsToUnits(8 / (Math.floor(e) * 3));
                    },
                    regexp: /^(\d+)t$/i,
                },
                tr: {
                    method: (t, e, o) => {
                        let s = 0;
                        return (
                            t &&
                                t !== '0' &&
                                (s += this._beatsToUnits(this._getTimeSignature() * parseFloat(t))),
                            e && e !== '0' && (s += this._beatsToUnits(parseFloat(e))),
                            o && o !== '0' && (s += this._beatsToUnits(parseFloat(o) / 4)),
                            s
                        );
                    },
                    regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/,
                },
            };
        }
        valueOf() {
            if ((this._val instanceof is && this.fromType(this._val), Dt(this._val)))
                return this._noArg();
            if (Vt(this._val) && Dt(this._units)) {
                for (let t in this._expressions)
                    if (this._expressions[t].regexp.test(this._val.trim())) {
                        this._units = t;
                        break;
                    }
            } else if (Te(this._val)) {
                let t = 0;
                for (let e in this._val)
                    if (Q(this._val[e])) {
                        let o = this._val[e];
                        t += new this.constructor(this.context, e).valueOf() * o;
                    }
                return t;
            }
            if (Q(this._units)) {
                let t = this._expressions[this._units],
                    e = this._val.toString().trim().match(t.regexp);
                return e ? t.method.apply(this, e.slice(1)) : t.method.call(this, this._val);
            } else return Vt(this._val) ? parseFloat(this._val) : this._val;
        }
        _frequencyToUnits(t) {
            return 1 / t;
        }
        _beatsToUnits(t) {
            return (60 / this._getBpm()) * t;
        }
        _secondsToUnits(t) {
            return t;
        }
        _ticksToUnits(t) {
            return (t * this._beatsToUnits(1)) / this._getPPQ();
        }
        _noArg() {
            return this._now();
        }
        _getBpm() {
            return this.context.transport.bpm.value;
        }
        _getTimeSignature() {
            return this.context.transport.timeSignature;
        }
        _getPPQ() {
            return this.context.transport.PPQ;
        }
        fromType(t) {
            switch (((this._units = void 0), this.defaultUnits)) {
                case 's':
                    this._val = t.toSeconds();
                    break;
                case 'i':
                    this._val = t.toTicks();
                    break;
                case 'hz':
                    this._val = t.toFrequency();
                    break;
                case 'midi':
                    this._val = t.toMidi();
                    break;
            }
            return this;
        }
        toFrequency() {
            return 1 / this.toSeconds();
        }
        toSamples() {
            return this.toSeconds() * this.context.sampleRate;
        }
        toMilliseconds() {
            return this.toSeconds() * 1e3;
        }
    };
    var Xt = class extends is {
        constructor() {
            super(...arguments);
            this.name = 'TimeClass';
        }
        _getExpressions() {
            return Object.assign(super._getExpressions(), {
                now: {
                    method: t => this._now() + new this.constructor(this.context, t).valueOf(),
                    regexp: /^\+(.+)/,
                },
                quantize: {
                    method: t => {
                        let e = new Xt(this.context, t).valueOf();
                        return this._secondsToUnits(this.context.transport.nextSubdivision(e));
                    },
                    regexp: /^@(.+)/,
                },
            });
        }
        quantize(t, e = 1) {
            let o = new this.constructor(this.context, t).valueOf(),
                s = this.valueOf(),
                a = Math.round(s / o) * o - s;
            return s + a * e;
        }
        toNotation() {
            let t = this.toSeconds(),
                e = ['1m'];
            for (let n = 1; n < 9; n++) {
                let i = Math.pow(2, n);
                e.push(i + 'n.'), e.push(i + 'n'), e.push(i + 't');
            }
            e.push('0');
            let o = e[0],
                s = new Xt(this.context, e[0]).toSeconds();
            return (
                e.forEach(n => {
                    let i = new Xt(this.context, n).toSeconds();
                    Math.abs(i - t) < Math.abs(s - t) && ((o = n), (s = i));
                }),
                o
            );
        }
        toBarsBeatsSixteenths() {
            let t = this._beatsToUnits(1),
                e = this.valueOf() / t;
            e = parseFloat(e.toFixed(4));
            let o = Math.floor(e / this._getTimeSignature()),
                s = (e % 1) * 4;
            e = Math.floor(e) % this._getTimeSignature();
            let n = s.toString();
            return n.length > 3 && (s = parseFloat(parseFloat(n).toFixed(3))), [o, e, s].join(':');
        }
        toTicks() {
            let t = this._beatsToUnits(1),
                e = this.valueOf() / t;
            return Math.round(e * this._getPPQ());
        }
        toSeconds() {
            return this.valueOf();
        }
        toMidi() {
            return ko(this.toFrequency());
        }
        _now() {
            return this.context.now();
        }
    };
    var Wt = class extends Xt {
            constructor() {
                super(...arguments);
                (this.name = 'Frequency'), (this.defaultUnits = 'hz');
            }
            static get A4() {
                return uh();
            }
            static set A4(t) {
                lh(t);
            }
            _getExpressions() {
                return Object.assign({}, super._getExpressions(), {
                    midi: {
                        regexp: /^(\d+(?:\.\d+)?midi)/,
                        method(t) {
                            return this.defaultUnits === 'midi' ? t : Wt.mtof(t);
                        },
                    },
                    note: {
                        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
                        method(t, e) {
                            let s = Hd[t.toLowerCase()] + (parseInt(e, 10) + 1) * 12;
                            return this.defaultUnits === 'midi' ? s : Wt.mtof(s);
                        },
                    },
                    tr: {
                        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
                        method(t, e, o) {
                            let s = 1;
                            return (
                                t &&
                                    t !== '0' &&
                                    (s *= this._beatsToUnits(
                                        this._getTimeSignature() * parseFloat(t)
                                    )),
                                e && e !== '0' && (s *= this._beatsToUnits(parseFloat(e))),
                                o && o !== '0' && (s *= this._beatsToUnits(parseFloat(o) / 4)),
                                s
                            );
                        },
                    },
                });
            }
            transpose(t) {
                return new Wt(this.context, this.valueOf() * Co(t));
            }
            harmonize(t) {
                return t.map(e => this.transpose(e));
            }
            toMidi() {
                return ko(this.valueOf());
            }
            toNote() {
                let t = this.toFrequency(),
                    e = Math.log2(t / Wt.A4),
                    o = Math.round(12 * e) + 57,
                    s = Math.floor(o / 12);
                return s < 0 && (o += -12 * s), Xd[o % 12] + s.toString();
            }
            toSeconds() {
                return 1 / super.toSeconds();
            }
            toTicks() {
                let t = this._beatsToUnits(1),
                    e = this.valueOf() / t;
                return Math.floor(e * this._getPPQ());
            }
            _noArg() {
                return 0;
            }
            _frequencyToUnits(t) {
                return t;
            }
            _ticksToUnits(t) {
                return 1 / ((t * 60) / (this._getBpm() * this._getPPQ()));
            }
            _beatsToUnits(t) {
                return 1 / super._beatsToUnits(t);
            }
            _secondsToUnits(t) {
                return 1 / t;
            }
            static mtof(t) {
                return Xs(t);
            }
            static ftom(t) {
                return ko(t);
            }
        },
        Hd = {
            cbb: -2,
            cb: -1,
            c: 0,
            'c#': 1,
            cx: 2,
            dbb: 0,
            db: 1,
            d: 2,
            'd#': 3,
            dx: 4,
            ebb: 2,
            eb: 3,
            e: 4,
            'e#': 5,
            ex: 6,
            fbb: 3,
            fb: 4,
            f: 5,
            'f#': 6,
            fx: 7,
            gbb: 5,
            gb: 6,
            g: 7,
            'g#': 8,
            gx: 9,
            abb: 7,
            ab: 8,
            a: 9,
            'a#': 10,
            ax: 11,
            bbb: 9,
            bb: 10,
            b: 11,
            'b#': 12,
            bx: 13,
        },
        Xd = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    var Ce = class extends Xt {
        constructor() {
            super(...arguments);
            this.name = 'TransportTime';
        }
        _now() {
            return this.context.transport.seconds;
        }
    };
    var yt = class extends Lt {
        constructor() {
            super();
            let t = g(yt.getDefaults(), arguments, ['context']);
            this.defaultContext ? (this.context = this.defaultContext) : (this.context = t.context);
        }
        static getDefaults() {
            return { context: Nt() };
        }
        now() {
            return this.context.currentTime + this.context.lookAhead;
        }
        immediate() {
            return this.context.currentTime;
        }
        get sampleTime() {
            return 1 / this.context.sampleRate;
        }
        get blockTime() {
            return 128 / this.context.sampleRate;
        }
        toSeconds(t) {
            return new Xt(this.context, t).toSeconds();
        }
        toFrequency(t) {
            return new Wt(this.context, t).toFrequency();
        }
        toTicks(t) {
            return new Ce(this.context, t).toTicks();
        }
        _getPartialProperties(t) {
            let e = this.get();
            return (
                Object.keys(e).forEach(o => {
                    Dt(t[o]) && delete e[o];
                }),
                e
            );
        }
        get() {
            let t = rh(this);
            return (
                Object.keys(t).forEach(e => {
                    if (Reflect.has(this, e)) {
                        let o = this[e];
                        Q(o) && Q(o.value) && Q(o.setValueAtTime)
                            ? (t[e] = o.value)
                            : o instanceof yt
                            ? (t[e] = o._getPartialProperties(t[e]))
                            : kt(o) || Yt(o) || Vt(o) || Hn(o)
                            ? (t[e] = o)
                            : delete t[e];
                    }
                }),
                t
            );
        }
        set(t) {
            return (
                Object.keys(t).forEach(e => {
                    Reflect.has(this, e) &&
                        Q(this[e]) &&
                        (this[e] && Q(this[e].value) && Q(this[e].setValueAtTime)
                            ? this[e].value !== t[e] && (this[e].value = t[e])
                            : this[e] instanceof yt
                            ? this[e].set(t[e])
                            : (this[e] = t[e]));
                }),
                this
            );
        }
    };
    var $e = class extends Rt {
        constructor(t = 'stopped') {
            super();
            (this.name = 'StateTimeline'),
                (this._initial = t),
                this.setStateAtTime(this._initial, 0);
        }
        getValueAtTime(t) {
            let e = this.get(t);
            return e !== null ? e.state : this._initial;
        }
        setStateAtTime(t, e, o) {
            return qt(e, 0), this.add(Object.assign({}, o, { state: t, time: e })), this;
        }
        getLastState(t, e) {
            let o = this._search(e);
            for (let s = o; s >= 0; s--) {
                let n = this._timeline[s];
                if (n.state === t) return n;
            }
        }
        getNextState(t, e) {
            let o = this._search(e);
            if (o !== -1)
                for (let s = o; s < this._timeline.length; s++) {
                    let n = this._timeline[s];
                    if (n.state === t) return n;
                }
        }
    };
    var X = class extends yt {
        constructor() {
            super(g(X.getDefaults(), arguments, ['param', 'units', 'convert']));
            (this.name = 'Param'), (this.overridden = !1), (this._minOutput = 1e-7);
            let t = g(X.getDefaults(), arguments, ['param', 'units', 'convert']);
            for (
                j(
                    Q(t.param) && (Ae(t.param) || t.param instanceof X),
                    'param must be an AudioParam'
                );
                !Ae(t.param);

            )
                t.param = t.param._param;
            (this._swappable = Q(t.swappable) ? t.swappable : !1),
                this._swappable
                    ? ((this.input = this.context.createGain()),
                      (this._param = t.param),
                      this.input.connect(this._param))
                    : (this._param = this.input = t.param),
                (this._events = new Rt(1e3)),
                (this._initialValue = this._param.defaultValue),
                (this.units = t.units),
                (this.convert = t.convert),
                (this._minValue = t.minValue),
                (this._maxValue = t.maxValue),
                Q(t.value) &&
                    t.value !== this._toType(this._initialValue) &&
                    this.setValueAtTime(t.value, 0);
        }
        static getDefaults() {
            return Object.assign(yt.getDefaults(), { convert: !0, units: 'number' });
        }
        get value() {
            let t = this.now();
            return this.getValueAtTime(t);
        }
        set value(t) {
            this.cancelScheduledValues(this.now()), this.setValueAtTime(t, this.now());
        }
        get minValue() {
            return Q(this._minValue)
                ? this._minValue
                : this.units === 'time' ||
                  this.units === 'frequency' ||
                  this.units === 'normalRange' ||
                  this.units === 'positive' ||
                  this.units === 'transportTime' ||
                  this.units === 'ticks' ||
                  this.units === 'bpm' ||
                  this.units === 'hertz' ||
                  this.units === 'samples'
                ? 0
                : this.units === 'audioRange'
                ? -1
                : this.units === 'decibels'
                ? -1 / 0
                : this._param.minValue;
        }
        get maxValue() {
            return Q(this._maxValue)
                ? this._maxValue
                : this.units === 'normalRange' || this.units === 'audioRange'
                ? 1
                : this._param.maxValue;
        }
        _is(t, e) {
            return this.units === e;
        }
        _assertRange(t) {
            return (
                Q(this.maxValue) &&
                    Q(this.minValue) &&
                    qt(t, this._fromType(this.minValue), this._fromType(this.maxValue)),
                t
            );
        }
        _fromType(t) {
            return this.convert && !this.overridden
                ? this._is(t, 'time')
                    ? this.toSeconds(t)
                    : this._is(t, 'decibels')
                    ? fr(t)
                    : this._is(t, 'frequency')
                    ? this.toFrequency(t)
                    : t
                : this.overridden
                ? 0
                : t;
        }
        _toType(t) {
            return this.convert && this.units === 'decibels' ? mr(t) : t;
        }
        setValueAtTime(t, e) {
            let o = this.toSeconds(e),
                s = this._fromType(t);
            return (
                j(
                    isFinite(s) && isFinite(o),
                    `Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(
                        e
                    )}`
                ),
                this._assertRange(s),
                this.log(this.units, 'setValueAtTime', t, o),
                this._events.add({ time: o, type: 'setValueAtTime', value: s }),
                this._param.setValueAtTime(s, o),
                this
            );
        }
        getValueAtTime(t) {
            let e = Math.max(this.toSeconds(t), 0),
                o = this._events.getAfter(e),
                s = this._events.get(e),
                n = this._initialValue;
            if (s === null) n = this._initialValue;
            else if (s.type === 'setTargetAtTime' && (o === null || o.type === 'setValueAtTime')) {
                let i = this._events.getBefore(s.time),
                    a;
                i === null ? (a = this._initialValue) : (a = i.value),
                    s.type === 'setTargetAtTime' &&
                        (n = this._exponentialApproach(s.time, a, s.value, s.constant, e));
            } else if (o === null) n = s.value;
            else if (
                o.type === 'linearRampToValueAtTime' ||
                o.type === 'exponentialRampToValueAtTime'
            ) {
                let i = s.value;
                if (s.type === 'setTargetAtTime') {
                    let a = this._events.getBefore(s.time);
                    a === null ? (i = this._initialValue) : (i = a.value);
                }
                o.type === 'linearRampToValueAtTime'
                    ? (n = this._linearInterpolate(s.time, i, o.time, o.value, e))
                    : (n = this._exponentialInterpolate(s.time, i, o.time, o.value, e));
            } else n = s.value;
            return this._toType(n);
        }
        setRampPoint(t) {
            t = this.toSeconds(t);
            let e = this.getValueAtTime(t);
            return (
                this.cancelAndHoldAtTime(t),
                this._fromType(e) === 0 && (e = this._toType(this._minOutput)),
                this.setValueAtTime(e, t),
                this
            );
        }
        linearRampToValueAtTime(t, e) {
            let o = this._fromType(t),
                s = this.toSeconds(e);
            return (
                j(
                    isFinite(o) && isFinite(s),
                    `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(
                        t
                    )}, ${JSON.stringify(e)}`
                ),
                this._assertRange(o),
                this._events.add({ time: s, type: 'linearRampToValueAtTime', value: o }),
                this.log(this.units, 'linearRampToValueAtTime', t, s),
                this._param.linearRampToValueAtTime(o, s),
                this
            );
        }
        exponentialRampToValueAtTime(t, e) {
            let o = this._fromType(t);
            (o = te(o, 0) ? this._minOutput : o), this._assertRange(o);
            let s = this.toSeconds(e);
            return (
                j(
                    isFinite(o) && isFinite(s),
                    `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(
                        t
                    )}, ${JSON.stringify(e)}`
                ),
                this._events.add({ time: s, type: 'exponentialRampToValueAtTime', value: o }),
                this.log(this.units, 'exponentialRampToValueAtTime', t, s),
                this._param.exponentialRampToValueAtTime(o, s),
                this
            );
        }
        exponentialRampTo(t, e, o) {
            return (
                (o = this.toSeconds(o)),
                this.setRampPoint(o),
                this.exponentialRampToValueAtTime(t, o + this.toSeconds(e)),
                this
            );
        }
        linearRampTo(t, e, o) {
            return (
                (o = this.toSeconds(o)),
                this.setRampPoint(o),
                this.linearRampToValueAtTime(t, o + this.toSeconds(e)),
                this
            );
        }
        targetRampTo(t, e, o) {
            return (
                (o = this.toSeconds(o)),
                this.setRampPoint(o),
                this.exponentialApproachValueAtTime(t, o, e),
                this
            );
        }
        exponentialApproachValueAtTime(t, e, o) {
            (e = this.toSeconds(e)), (o = this.toSeconds(o));
            let s = Math.log(o + 1) / Math.log(200);
            return (
                this.setTargetAtTime(t, e, s),
                this.cancelAndHoldAtTime(e + o * 0.9),
                this.linearRampToValueAtTime(t, e + o),
                this
            );
        }
        setTargetAtTime(t, e, o) {
            let s = this._fromType(t);
            j(isFinite(o) && o > 0, 'timeConstant must be a number greater than 0');
            let n = this.toSeconds(e);
            return (
                this._assertRange(s),
                j(
                    isFinite(s) && isFinite(n),
                    `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(
                        e
                    )}`
                ),
                this._events.add({ constant: o, time: n, type: 'setTargetAtTime', value: s }),
                this.log(this.units, 'setTargetAtTime', t, n, o),
                this._param.setTargetAtTime(s, n, o),
                this
            );
        }
        setValueCurveAtTime(t, e, o, s = 1) {
            (o = this.toSeconds(o)), (e = this.toSeconds(e));
            let n = this._fromType(t[0]) * s;
            this.setValueAtTime(this._toType(n), e);
            let i = o / (t.length - 1);
            for (let a = 1; a < t.length; a++) {
                let c = this._fromType(t[a]) * s;
                this.linearRampToValueAtTime(this._toType(c), e + a * i);
            }
            return this;
        }
        cancelScheduledValues(t) {
            let e = this.toSeconds(t);
            return (
                j(isFinite(e), `Invalid argument to cancelScheduledValues: ${JSON.stringify(t)}`),
                this._events.cancel(e),
                this._param.cancelScheduledValues(e),
                this.log(this.units, 'cancelScheduledValues', e),
                this
            );
        }
        cancelAndHoldAtTime(t) {
            let e = this.toSeconds(t),
                o = this._fromType(this.getValueAtTime(e));
            j(isFinite(e), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(t)}`),
                this.log(this.units, 'cancelAndHoldAtTime', e, 'value=' + o);
            let s = this._events.get(e),
                n = this._events.getAfter(e);
            return (
                s && te(s.time, e)
                    ? n
                        ? (this._param.cancelScheduledValues(n.time), this._events.cancel(n.time))
                        : (this._param.cancelAndHoldAtTime(e),
                          this._events.cancel(e + this.sampleTime))
                    : n &&
                      (this._param.cancelScheduledValues(n.time),
                      this._events.cancel(n.time),
                      n.type === 'linearRampToValueAtTime'
                          ? this.linearRampToValueAtTime(this._toType(o), e)
                          : n.type === 'exponentialRampToValueAtTime' &&
                            this.exponentialRampToValueAtTime(this._toType(o), e)),
                this._events.add({ time: e, type: 'setValueAtTime', value: o }),
                this._param.setValueAtTime(o, e),
                this
            );
        }
        rampTo(t, e = 0.1, o) {
            return (
                this.units === 'frequency' || this.units === 'bpm' || this.units === 'decibels'
                    ? this.exponentialRampTo(t, e, o)
                    : this.linearRampTo(t, e, o),
                this
            );
        }
        apply(t) {
            let e = this.context.currentTime;
            t.setValueAtTime(this.getValueAtTime(e), e);
            let o = this._events.get(e);
            if (o && o.type === 'setTargetAtTime') {
                let s = this._events.getAfter(o.time),
                    n = s ? s.time : e + 2,
                    i = (n - e) / 10;
                for (let a = e; a < n; a += i) t.linearRampToValueAtTime(this.getValueAtTime(a), a);
            }
            return (
                this._events.forEachAfter(this.context.currentTime, s => {
                    s.type === 'cancelScheduledValues'
                        ? t.cancelScheduledValues(s.time)
                        : s.type === 'setTargetAtTime'
                        ? t.setTargetAtTime(s.value, s.time, s.constant)
                        : t[s.type](s.value, s.time);
                }),
                this
            );
        }
        setParam(t) {
            j(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
            let e = this.input;
            return (
                e.disconnect(this._param),
                this.apply(t),
                (this._param = t),
                e.connect(this._param),
                this
            );
        }
        dispose() {
            return super.dispose(), this._events.dispose(), this;
        }
        get defaultValue() {
            return this._toType(this._param.defaultValue);
        }
        _exponentialApproach(t, e, o, s, n) {
            return o + (e - o) * Math.exp(-(n - t) / s);
        }
        _linearInterpolate(t, e, o, s, n) {
            return e + (s - e) * ((n - t) / (o - t));
        }
        _exponentialInterpolate(t, e, o, s, n) {
            return e * Math.pow(s / e, (n - t) / (o - t));
        }
    };
    var S = class extends yt {
        constructor() {
            super(...arguments);
            (this.name = 'ToneAudioNode'), (this._internalChannels = []);
        }
        get numberOfInputs() {
            return Q(this.input)
                ? Ae(this.input) || this.input instanceof X
                    ? 1
                    : this.input.numberOfInputs
                : 0;
        }
        get numberOfOutputs() {
            return Q(this.output) ? this.output.numberOfOutputs : 0;
        }
        _isAudioNode(t) {
            return Q(t) && (t instanceof S || We(t));
        }
        _getInternalNodes() {
            let t = this._internalChannels.slice(0);
            return (
                this._isAudioNode(this.input) && t.push(this.input),
                this._isAudioNode(this.output) && this.input !== this.output && t.push(this.output),
                t
            );
        }
        _setChannelProperties(t) {
            this._getInternalNodes().forEach(o => {
                (o.channelCount = t.channelCount),
                    (o.channelCountMode = t.channelCountMode),
                    (o.channelInterpretation = t.channelInterpretation);
            });
        }
        _getChannelProperties() {
            let t = this._getInternalNodes();
            j(t.length > 0, 'ToneAudioNode does not have any internal nodes');
            let e = t[0];
            return {
                channelCount: e.channelCount,
                channelCountMode: e.channelCountMode,
                channelInterpretation: e.channelInterpretation,
            };
        }
        get channelCount() {
            return this._getChannelProperties().channelCount;
        }
        set channelCount(t) {
            let e = this._getChannelProperties();
            this._setChannelProperties(Object.assign(e, { channelCount: t }));
        }
        get channelCountMode() {
            return this._getChannelProperties().channelCountMode;
        }
        set channelCountMode(t) {
            let e = this._getChannelProperties();
            this._setChannelProperties(Object.assign(e, { channelCountMode: t }));
        }
        get channelInterpretation() {
            return this._getChannelProperties().channelInterpretation;
        }
        set channelInterpretation(t) {
            let e = this._getChannelProperties();
            this._setChannelProperties(Object.assign(e, { channelInterpretation: t }));
        }
        connect(t, e = 0, o = 0) {
            return Et(this, t, e, o), this;
        }
        toDestination() {
            return this.connect(this.context.destination), this;
        }
        toMaster() {
            return ts('toMaster() has been renamed toDestination()'), this.toDestination();
        }
        disconnect(t, e = 0, o = 0) {
            return ti(this, t, e, o), this;
        }
        chain(...t) {
            return Qt(this, ...t), this;
        }
        fan(...t) {
            return t.forEach(e => this.connect(e)), this;
        }
        dispose() {
            return (
                super.dispose(),
                Q(this.input) &&
                    (this.input instanceof S
                        ? this.input.dispose()
                        : We(this.input) && this.input.disconnect()),
                Q(this.output) &&
                    (this.output instanceof S
                        ? this.output.dispose()
                        : We(this.output) && this.output.disconnect()),
                (this._internalChannels = []),
                this
            );
        }
    };
    function Qt(...r) {
        let t = r.shift();
        r.reduce((e, o) => (e instanceof S ? e.connect(o) : We(e) && Et(e, o), o), t);
    }
    function Et(r, t, e = 0, o = 0) {
        for (
            j(Q(r), 'Cannot connect from undefined node'),
                j(Q(t), 'Cannot connect to undefined node'),
                (t instanceof S || We(t)) &&
                    j(t.numberOfInputs > 0, 'Cannot connect to node with no inputs'),
                j(r.numberOfOutputs > 0, 'Cannot connect from node with no outputs');
            t instanceof S || t instanceof X;

        )
            Q(t.input) && (t = t.input);
        for (; r instanceof S; ) Q(r.output) && (r = r.output);
        Ae(t) ? r.connect(t, e) : r.connect(t, e, o);
    }
    function ti(r, t, e = 0, o = 0) {
        if (Q(t)) for (; t instanceof S; ) t = t.input;
        for (; !We(r); ) Q(r.output) && (r = r.output);
        Ae(t) ? r.disconnect(t, e) : We(t) ? r.disconnect(t, e, o) : r.disconnect();
    }
    var P = class extends S {
        constructor() {
            super(g(P.getDefaults(), arguments, ['gain', 'units']));
            (this.name = 'Gain'),
                (this._gainNode = this.context.createGain()),
                (this.input = this._gainNode),
                (this.output = this._gainNode);
            let t = g(P.getDefaults(), arguments, ['gain', 'units']);
            (this.gain = new X({
                context: this.context,
                convert: t.convert,
                param: this._gainNode.gain,
                units: t.units,
                value: t.gain,
                minValue: t.minValue,
                maxValue: t.maxValue,
            })),
                M(this, 'gain');
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { convert: !0, gain: 1, units: 'gain' });
        }
        dispose() {
            return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this;
        }
    };
    var Be = class extends S {
        constructor(t) {
            super(t);
            (this.onended = $),
                (this._startTime = -1),
                (this._stopTime = -1),
                (this._timeout = -1),
                (this.output = new P({ context: this.context, gain: 0 })),
                (this._gainNode = this.output),
                (this.getStateAtTime = function (e) {
                    let o = this.toSeconds(e);
                    return this._startTime !== -1 &&
                        o >= this._startTime &&
                        (this._stopTime === -1 || o <= this._stopTime)
                        ? 'started'
                        : 'stopped';
                }),
                (this._fadeIn = t.fadeIn),
                (this._fadeOut = t.fadeOut),
                (this._curve = t.curve),
                (this.onended = t.onended);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), {
                curve: 'linear',
                fadeIn: 0,
                fadeOut: 0,
                onended: $,
            });
        }
        _startGain(t, e = 1) {
            j(this._startTime === -1, 'Source cannot be started more than once');
            let o = this.toSeconds(this._fadeIn);
            return (
                (this._startTime = t + o),
                (this._startTime = Math.max(this._startTime, this.context.currentTime)),
                o > 0
                    ? (this._gainNode.gain.setValueAtTime(0, t),
                      this._curve === 'linear'
                          ? this._gainNode.gain.linearRampToValueAtTime(e, t + o)
                          : this._gainNode.gain.exponentialApproachValueAtTime(e, t, o))
                    : this._gainNode.gain.setValueAtTime(e, t),
                this
            );
        }
        stop(t) {
            return this.log('stop', t), this._stopGain(this.toSeconds(t)), this;
        }
        _stopGain(t) {
            j(this._startTime !== -1, "'start' must be called before 'stop'"), this.cancelStop();
            let e = this.toSeconds(this._fadeOut);
            return (
                (this._stopTime = this.toSeconds(t) + e),
                (this._stopTime = Math.max(this._stopTime, this.context.currentTime)),
                e > 0
                    ? this._curve === 'linear'
                        ? this._gainNode.gain.linearRampTo(0, e, t)
                        : this._gainNode.gain.targetRampTo(0, e, t)
                    : (this._gainNode.gain.cancelAndHoldAtTime(t),
                      this._gainNode.gain.setValueAtTime(0, t)),
                this.context.clearTimeout(this._timeout),
                (this._timeout = this.context.setTimeout(() => {
                    let o = this._curve === 'exponential' ? e * 2 : 0;
                    this._stopSource(this.now() + o), this._onended();
                }, this._stopTime - this.context.currentTime)),
                this
            );
        }
        _onended() {
            if (
                this.onended !== $ &&
                (this.onended(this), (this.onended = $), !this.context.isOffline)
            ) {
                let t = () => this.dispose();
                typeof window.requestIdleCallback != 'undefined'
                    ? window.requestIdleCallback(t)
                    : setTimeout(t, 1e3);
            }
        }
        get state() {
            return this.getStateAtTime(this.now());
        }
        cancelStop() {
            return (
                this.log('cancelStop'),
                j(this._startTime !== -1, 'Source is not started'),
                this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime),
                this.context.clearTimeout(this._timeout),
                (this._stopTime = -1),
                this
            );
        }
        dispose() {
            return super.dispose(), this._gainNode.disconnect(), this;
        }
    };
    var No = class extends Be {
        constructor() {
            super(g(No.getDefaults(), arguments, ['offset']));
            (this.name = 'ToneConstantSource'),
                (this._source = this.context.createConstantSource());
            let t = g(No.getDefaults(), arguments, ['offset']);
            Et(this._source, this._gainNode),
                (this.offset = new X({
                    context: this.context,
                    convert: t.convert,
                    param: this._source.offset,
                    units: t.units,
                    value: t.offset,
                    minValue: t.minValue,
                    maxValue: t.maxValue,
                }));
        }
        static getDefaults() {
            return Object.assign(Be.getDefaults(), { convert: !0, offset: 1, units: 'number' });
        }
        start(t) {
            let e = this.toSeconds(t);
            return this.log('start', e), this._startGain(e), this._source.start(e), this;
        }
        _stopSource(t) {
            this._source.stop(t);
        }
        dispose() {
            return (
                super.dispose(),
                this.state === 'started' && this.stop(),
                this._source.disconnect(),
                this.offset.dispose(),
                this
            );
        }
    };
    var z = class extends S {
        constructor() {
            super(g(z.getDefaults(), arguments, ['value', 'units']));
            (this.name = 'Signal'), (this.override = !0);
            let t = g(z.getDefaults(), arguments, ['value', 'units']);
            (this.output = this._constantSource =
                new No({
                    context: this.context,
                    convert: t.convert,
                    offset: t.value,
                    units: t.units,
                    minValue: t.minValue,
                    maxValue: t.maxValue,
                })),
                this._constantSource.start(0),
                (this.input = this._param = this._constantSource.offset);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { convert: !0, units: 'number', value: 0 });
        }
        connect(t, e = 0, o = 0) {
            return Oo(this, t, e, o), this;
        }
        dispose() {
            return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this;
        }
        setValueAtTime(t, e) {
            return this._param.setValueAtTime(t, e), this;
        }
        getValueAtTime(t) {
            return this._param.getValueAtTime(t);
        }
        setRampPoint(t) {
            return this._param.setRampPoint(t), this;
        }
        linearRampToValueAtTime(t, e) {
            return this._param.linearRampToValueAtTime(t, e), this;
        }
        exponentialRampToValueAtTime(t, e) {
            return this._param.exponentialRampToValueAtTime(t, e), this;
        }
        exponentialRampTo(t, e, o) {
            return this._param.exponentialRampTo(t, e, o), this;
        }
        linearRampTo(t, e, o) {
            return this._param.linearRampTo(t, e, o), this;
        }
        targetRampTo(t, e, o) {
            return this._param.targetRampTo(t, e, o), this;
        }
        exponentialApproachValueAtTime(t, e, o) {
            return this._param.exponentialApproachValueAtTime(t, e, o), this;
        }
        setTargetAtTime(t, e, o) {
            return this._param.setTargetAtTime(t, e, o), this;
        }
        setValueCurveAtTime(t, e, o, s) {
            return this._param.setValueCurveAtTime(t, e, o, s), this;
        }
        cancelScheduledValues(t) {
            return this._param.cancelScheduledValues(t), this;
        }
        cancelAndHoldAtTime(t) {
            return this._param.cancelAndHoldAtTime(t), this;
        }
        rampTo(t, e, o) {
            return this._param.rampTo(t, e, o), this;
        }
        get value() {
            return this._param.value;
        }
        set value(t) {
            this._param.value = t;
        }
        get convert() {
            return this._param.convert;
        }
        set convert(t) {
            this._param.convert = t;
        }
        get units() {
            return this._param.units;
        }
        get overridden() {
            return this._param.overridden;
        }
        set overridden(t) {
            this._param.overridden = t;
        }
        get maxValue() {
            return this._param.maxValue;
        }
        get minValue() {
            return this._param.minValue;
        }
        apply(t) {
            return this._param.apply(t), this;
        }
    };
    function Oo(r, t, e, o) {
        (t instanceof X || Ae(t) || (t instanceof z && t.override)) &&
            (t.cancelScheduledValues(0),
            t.setValueAtTime(0, 0),
            t instanceof z && (t.overridden = !0)),
            Et(r, t, e, o);
    }
    var gr = class extends X {
        constructor() {
            super(g(gr.getDefaults(), arguments, ['value']));
            (this.name = 'TickParam'), (this._events = new Rt(1 / 0)), (this._multiplier = 1);
            let t = g(gr.getDefaults(), arguments, ['value']);
            (this._multiplier = t.multiplier),
                this._events.cancel(0),
                this._events.add({
                    ticks: 0,
                    time: 0,
                    type: 'setValueAtTime',
                    value: this._fromType(t.value),
                }),
                this.setValueAtTime(t.value, 0);
        }
        static getDefaults() {
            return Object.assign(X.getDefaults(), { multiplier: 1, units: 'hertz', value: 1 });
        }
        setTargetAtTime(t, e, o) {
            (e = this.toSeconds(e)), this.setRampPoint(e);
            let s = this._fromType(t),
                n = this._events.get(e),
                i = Math.round(Math.max(1 / o, 1));
            for (let a = 0; a <= i; a++) {
                let c = o * a + e,
                    u = this._exponentialApproach(n.time, n.value, s, o, c);
                this.linearRampToValueAtTime(this._toType(u), c);
            }
            return this;
        }
        setValueAtTime(t, e) {
            let o = this.toSeconds(e);
            super.setValueAtTime(t, e);
            let s = this._events.get(o),
                n = this._events.previousEvent(s),
                i = this._getTicksUntilEvent(n, o);
            return (s.ticks = Math.max(i, 0)), this;
        }
        linearRampToValueAtTime(t, e) {
            let o = this.toSeconds(e);
            super.linearRampToValueAtTime(t, e);
            let s = this._events.get(o),
                n = this._events.previousEvent(s),
                i = this._getTicksUntilEvent(n, o);
            return (s.ticks = Math.max(i, 0)), this;
        }
        exponentialRampToValueAtTime(t, e) {
            e = this.toSeconds(e);
            let o = this._fromType(t),
                s = this._events.get(e),
                n = Math.round(Math.max((e - s.time) * 10, 1)),
                i = (e - s.time) / n;
            for (let a = 0; a <= n; a++) {
                let c = i * a + s.time,
                    u = this._exponentialInterpolate(s.time, s.value, e, o, c);
                this.linearRampToValueAtTime(this._toType(u), c);
            }
            return this;
        }
        _getTicksUntilEvent(t, e) {
            if (t === null) t = { ticks: 0, time: 0, type: 'setValueAtTime', value: 0 };
            else if (Dt(t.ticks)) {
                let i = this._events.previousEvent(t);
                t.ticks = this._getTicksUntilEvent(i, t.time);
            }
            let o = this._fromType(this.getValueAtTime(t.time)),
                s = this._fromType(this.getValueAtTime(e)),
                n = this._events.get(e);
            return (
                n &&
                    n.time === e &&
                    n.type === 'setValueAtTime' &&
                    (s = this._fromType(this.getValueAtTime(e - this.sampleTime))),
                0.5 * (e - t.time) * (o + s) + t.ticks
            );
        }
        getTicksAtTime(t) {
            let e = this.toSeconds(t),
                o = this._events.get(e);
            return Math.max(this._getTicksUntilEvent(o, e), 0);
        }
        getDurationOfTicks(t, e) {
            let o = this.toSeconds(e),
                s = this.getTicksAtTime(e);
            return this.getTimeOfTick(s + t) - o;
        }
        getTimeOfTick(t) {
            let e = this._events.get(t, 'ticks'),
                o = this._events.getAfter(t, 'ticks');
            if (e && e.ticks === t) return e.time;
            if (e && o && o.type === 'linearRampToValueAtTime' && e.value !== o.value) {
                let s = this._fromType(this.getValueAtTime(e.time)),
                    i = (this._fromType(this.getValueAtTime(o.time)) - s) / (o.time - e.time),
                    a = Math.sqrt(Math.pow(s, 2) - 2 * i * (e.ticks - t)),
                    c = (-s + a) / i,
                    u = (-s - a) / i;
                return (c > 0 ? c : u) + e.time;
            } else
                return e
                    ? e.value === 0
                        ? 1 / 0
                        : e.time + (t - e.ticks) / e.value
                    : t / this._initialValue;
        }
        ticksToTime(t, e) {
            return this.getDurationOfTicks(t, e);
        }
        timeToTicks(t, e) {
            let o = this.toSeconds(e),
                s = this.toSeconds(t),
                n = this.getTicksAtTime(o);
            return this.getTicksAtTime(o + s) - n;
        }
        _fromType(t) {
            return this.units === 'bpm' && this.multiplier
                ? 1 / (60 / t / this.multiplier)
                : super._fromType(t);
        }
        _toType(t) {
            return this.units === 'bpm' && this.multiplier
                ? (t / this.multiplier) * 60
                : super._toType(t);
        }
        get multiplier() {
            return this._multiplier;
        }
        set multiplier(t) {
            let e = this.value;
            (this._multiplier = t), this.cancelScheduledValues(0), this.setValueAtTime(e, 0);
        }
    };
    var _r = class extends z {
        constructor() {
            super(g(_r.getDefaults(), arguments, ['value']));
            this.name = 'TickSignal';
            let t = g(_r.getDefaults(), arguments, ['value']);
            this.input = this._param = new gr({
                context: this.context,
                convert: t.convert,
                multiplier: t.multiplier,
                param: this._constantSource.offset,
                units: t.units,
                value: t.value,
            });
        }
        static getDefaults() {
            return Object.assign(z.getDefaults(), { multiplier: 1, units: 'hertz', value: 1 });
        }
        ticksToTime(t, e) {
            return this._param.ticksToTime(t, e);
        }
        timeToTicks(t, e) {
            return this._param.timeToTicks(t, e);
        }
        getTimeOfTick(t) {
            return this._param.getTimeOfTick(t);
        }
        getDurationOfTicks(t, e) {
            return this._param.getDurationOfTicks(t, e);
        }
        getTicksAtTime(t) {
            return this._param.getTicksAtTime(t);
        }
        get multiplier() {
            return this._param.multiplier;
        }
        set multiplier(t) {
            this._param.multiplier = t;
        }
        dispose() {
            return super.dispose(), this._param.dispose(), this;
        }
    };
    var xr = class extends yt {
        constructor() {
            super(g(xr.getDefaults(), arguments, ['frequency']));
            (this.name = 'TickSource'), (this._state = new $e()), (this._tickOffset = new Rt());
            let t = g(xr.getDefaults(), arguments, ['frequency']);
            (this.frequency = new _r({
                context: this.context,
                units: t.units,
                value: t.frequency,
            })),
                M(this, 'frequency'),
                this._state.setStateAtTime('stopped', 0),
                this.setTicksAtTime(0, 0);
        }
        static getDefaults() {
            return Object.assign({ frequency: 1, units: 'hertz' }, yt.getDefaults());
        }
        get state() {
            return this.getStateAtTime(this.now());
        }
        start(t, e) {
            let o = this.toSeconds(t);
            return (
                this._state.getValueAtTime(o) !== 'started' &&
                    (this._state.setStateAtTime('started', o), Q(e) && this.setTicksAtTime(e, o)),
                this
            );
        }
        stop(t) {
            let e = this.toSeconds(t);
            if (this._state.getValueAtTime(e) === 'stopped') {
                let o = this._state.get(e);
                o && o.time > 0 && (this._tickOffset.cancel(o.time), this._state.cancel(o.time));
            }
            return (
                this._state.cancel(e),
                this._state.setStateAtTime('stopped', e),
                this.setTicksAtTime(0, e),
                this
            );
        }
        pause(t) {
            let e = this.toSeconds(t);
            return (
                this._state.getValueAtTime(e) === 'started' &&
                    this._state.setStateAtTime('paused', e),
                this
            );
        }
        cancel(t) {
            return (t = this.toSeconds(t)), this._state.cancel(t), this._tickOffset.cancel(t), this;
        }
        getTicksAtTime(t) {
            let e = this.toSeconds(t),
                o = this._state.getLastState('stopped', e),
                s = { state: 'paused', time: e };
            this._state.add(s);
            let n = o,
                i = 0;
            return (
                this._state.forEachBetween(o.time, e + this.sampleTime, a => {
                    let c = n.time,
                        u = this._tickOffset.get(a.time);
                    u && u.time >= n.time && ((i = u.ticks), (c = u.time)),
                        n.state === 'started' &&
                            a.state !== 'started' &&
                            (i +=
                                this.frequency.getTicksAtTime(a.time) -
                                this.frequency.getTicksAtTime(c)),
                        (n = a);
                }),
                this._state.remove(s),
                i
            );
        }
        get ticks() {
            return this.getTicksAtTime(this.now());
        }
        set ticks(t) {
            this.setTicksAtTime(t, this.now());
        }
        get seconds() {
            return this.getSecondsAtTime(this.now());
        }
        set seconds(t) {
            let e = this.now(),
                o = this.frequency.timeToTicks(t, e);
            this.setTicksAtTime(o, e);
        }
        getSecondsAtTime(t) {
            t = this.toSeconds(t);
            let e = this._state.getLastState('stopped', t),
                o = { state: 'paused', time: t };
            this._state.add(o);
            let s = e,
                n = 0;
            return (
                this._state.forEachBetween(e.time, t + this.sampleTime, i => {
                    let a = s.time,
                        c = this._tickOffset.get(i.time);
                    c && c.time >= s.time && ((n = c.seconds), (a = c.time)),
                        s.state === 'started' && i.state !== 'started' && (n += i.time - a),
                        (s = i);
                }),
                this._state.remove(o),
                n
            );
        }
        setTicksAtTime(t, e) {
            return (
                (e = this.toSeconds(e)),
                this._tickOffset.cancel(e),
                this._tickOffset.add({
                    seconds: this.frequency.getDurationOfTicks(t, e),
                    ticks: t,
                    time: e,
                }),
                this
            );
        }
        getStateAtTime(t) {
            return (t = this.toSeconds(t)), this._state.getValueAtTime(t);
        }
        getTimeOfTick(t, e = this.now()) {
            let o = this._tickOffset.get(e),
                s = this._state.get(e),
                n = Math.max(o.time, s.time),
                i = this.frequency.getTicksAtTime(n) + t - o.ticks;
            return this.frequency.getTimeOfTick(i);
        }
        forEachTickBetween(t, e, o) {
            let s = this._state.get(t);
            this._state.forEachBetween(t, e, i => {
                s &&
                    s.state === 'started' &&
                    i.state !== 'started' &&
                    this.forEachTickBetween(Math.max(s.time, t), i.time - this.sampleTime, o),
                    (s = i);
            });
            let n = null;
            if (s && s.state === 'started') {
                let i = Math.max(s.time, t),
                    a = this.frequency.getTicksAtTime(i),
                    c = this.frequency.getTicksAtTime(s.time),
                    u = a - c,
                    l = Math.ceil(u) - u;
                l = te(l, 1) ? 0 : l;
                let h = this.frequency.getTimeOfTick(a + l);
                for (; h < e; ) {
                    try {
                        o(h, Math.round(this.getTicksAtTime(h)));
                    } catch (p) {
                        n = p;
                        break;
                    }
                    h += this.frequency.getDurationOfTicks(1, h);
                }
            }
            if (n) throw n;
            return this;
        }
        dispose() {
            return (
                super.dispose(),
                this._state.dispose(),
                this._tickOffset.dispose(),
                this.frequency.dispose(),
                this
            );
        }
    };
    var go = class extends yt {
        constructor() {
            super(g(go.getDefaults(), arguments, ['callback', 'frequency']));
            (this.name = 'Clock'),
                (this.callback = $),
                (this._lastUpdate = 0),
                (this._state = new $e('stopped')),
                (this._boundLoop = this._loop.bind(this));
            let t = g(go.getDefaults(), arguments, ['callback', 'frequency']);
            (this.callback = t.callback),
                (this._tickSource = new xr({
                    context: this.context,
                    frequency: t.frequency,
                    units: t.units,
                })),
                (this._lastUpdate = 0),
                (this.frequency = this._tickSource.frequency),
                M(this, 'frequency'),
                this._state.setStateAtTime('stopped', 0),
                this.context.on('tick', this._boundLoop);
        }
        static getDefaults() {
            return Object.assign(yt.getDefaults(), { callback: $, frequency: 1, units: 'hertz' });
        }
        get state() {
            return this._state.getValueAtTime(this.now());
        }
        start(t, e) {
            Bs(this.context);
            let o = this.toSeconds(t);
            return (
                this.log('start', o),
                this._state.getValueAtTime(o) !== 'started' &&
                    (this._state.setStateAtTime('started', o),
                    this._tickSource.start(o, e),
                    o < this._lastUpdate && this.emit('start', o, e)),
                this
            );
        }
        stop(t) {
            let e = this.toSeconds(t);
            return (
                this.log('stop', e),
                this._state.cancel(e),
                this._state.setStateAtTime('stopped', e),
                this._tickSource.stop(e),
                e < this._lastUpdate && this.emit('stop', e),
                this
            );
        }
        pause(t) {
            let e = this.toSeconds(t);
            return (
                this._state.getValueAtTime(e) === 'started' &&
                    (this._state.setStateAtTime('paused', e),
                    this._tickSource.pause(e),
                    e < this._lastUpdate && this.emit('pause', e)),
                this
            );
        }
        get ticks() {
            return Math.ceil(this.getTicksAtTime(this.now()));
        }
        set ticks(t) {
            this._tickSource.ticks = t;
        }
        get seconds() {
            return this._tickSource.seconds;
        }
        set seconds(t) {
            this._tickSource.seconds = t;
        }
        getSecondsAtTime(t) {
            return this._tickSource.getSecondsAtTime(t);
        }
        setTicksAtTime(t, e) {
            return this._tickSource.setTicksAtTime(t, e), this;
        }
        getTimeOfTick(t, e = this.now()) {
            return this._tickSource.getTimeOfTick(t, e);
        }
        getTicksAtTime(t) {
            return this._tickSource.getTicksAtTime(t);
        }
        nextTickTime(t, e) {
            let o = this.toSeconds(e),
                s = this.getTicksAtTime(o);
            return this._tickSource.getTimeOfTick(s + t, o);
        }
        _loop() {
            let t = this._lastUpdate,
                e = this.now();
            (this._lastUpdate = e),
                this.log('loop', t, e),
                t !== e &&
                    (this._state.forEachBetween(t, e, o => {
                        switch (o.state) {
                            case 'started':
                                let s = this._tickSource.getTicksAtTime(o.time);
                                this.emit('start', o.time, s);
                                break;
                            case 'stopped':
                                o.time !== 0 && this.emit('stop', o.time);
                                break;
                            case 'paused':
                                this.emit('pause', o.time);
                                break;
                        }
                    }),
                    this._tickSource.forEachTickBetween(t, e, (o, s) => {
                        this.callback(o, s);
                    }));
        }
        getStateAtTime(t) {
            let e = this.toSeconds(t);
            return this._state.getValueAtTime(e);
        }
        dispose() {
            return (
                super.dispose(),
                this.context.off('tick', this._boundLoop),
                this._tickSource.dispose(),
                this._state.dispose(),
                this
            );
        }
    };
    Qe.mixin(go);
    var je = class extends S {
        constructor() {
            super(g(je.getDefaults(), arguments, ['delayTime', 'maxDelay']));
            this.name = 'Delay';
            let t = g(je.getDefaults(), arguments, ['delayTime', 'maxDelay']),
                e = this.toSeconds(t.maxDelay);
            (this._maxDelay = Math.max(e, this.toSeconds(t.delayTime))),
                (this._delayNode = this.input = this.output = this.context.createDelay(e)),
                (this.delayTime = new X({
                    context: this.context,
                    param: this._delayNode.delayTime,
                    units: 'time',
                    value: t.delayTime,
                    minValue: 0,
                    maxValue: this.maxDelay,
                })),
                M(this, 'delayTime');
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { delayTime: 0, maxDelay: 1 });
        }
        get maxDelay() {
            return this._maxDelay;
        }
        dispose() {
            return super.dispose(), this._delayNode.disconnect(), this.delayTime.dispose(), this;
        }
    };
    var Do = class extends Lt {
        constructor() {
            super();
            (this.name = 'ToneAudioBuffers'), (this._buffers = new Map()), (this._loadingCount = 0);
            let t = g(Do.getDefaults(), arguments, ['urls', 'onload', 'baseUrl'], 'urls');
            (this.baseUrl = t.baseUrl),
                Object.keys(t.urls).forEach(e => {
                    this._loadingCount++;
                    let o = t.urls[e];
                    this.add(e, o, this._bufferLoaded.bind(this, t.onload), t.onerror);
                });
        }
        static getDefaults() {
            return { baseUrl: '', onerror: $, onload: $, urls: {} };
        }
        has(t) {
            return this._buffers.has(t.toString());
        }
        get(t) {
            return (
                j(this.has(t), `ToneAudioBuffers has no buffer named: ${t}`),
                this._buffers.get(t.toString())
            );
        }
        _bufferLoaded(t) {
            this._loadingCount--, this._loadingCount === 0 && t && t();
        }
        get loaded() {
            return Array.from(this._buffers).every(([t, e]) => e.loaded);
        }
        add(t, e, o = $, s = $) {
            return (
                Vt(e)
                    ? this._buffers.set(t.toString(), new st(this.baseUrl + e, o, s))
                    : this._buffers.set(t.toString(), new st(e, o, s)),
                this
            );
        }
        dispose() {
            return (
                super.dispose(),
                this._buffers.forEach(t => t.dispose()),
                this._buffers.clear(),
                this
            );
        }
    };
    var ee = class extends Ce {
        constructor() {
            super(...arguments);
            (this.name = 'Ticks'), (this.defaultUnits = 'i');
        }
        _now() {
            return this.context.transport.ticks;
        }
        _beatsToUnits(t) {
            return this._getPPQ() * t;
        }
        _secondsToUnits(t) {
            return Math.floor((t / (60 / this._getBpm())) * this._getPPQ());
        }
        _ticksToUnits(t) {
            return t;
        }
        toTicks() {
            return this.valueOf();
        }
        toSeconds() {
            return (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());
        }
    };
    var hh = class extends yt {
        constructor() {
            super(...arguments);
            (this.name = 'Draw'),
                (this.expiration = 0.25),
                (this.anticipation = 0.008),
                (this._events = new Rt()),
                (this._boundDrawLoop = this._drawLoop.bind(this)),
                (this._animationFrame = -1);
        }
        schedule(t, e) {
            return (
                this._events.add({ callback: t, time: this.toSeconds(e) }),
                this._events.length === 1 &&
                    (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)),
                this
            );
        }
        cancel(t) {
            return this._events.cancel(this.toSeconds(t)), this;
        }
        _drawLoop() {
            let t = this.context.currentTime;
            for (; this._events.length && this._events.peek().time - this.anticipation <= t; ) {
                let e = this._events.shift();
                e && t - e.time <= this.expiration && e.callback();
            }
            this._events.length > 0 &&
                (this._animationFrame = requestAnimationFrame(this._boundDrawLoop));
        }
        dispose() {
            return (
                super.dispose(),
                this._events.dispose(),
                cancelAnimationFrame(this._animationFrame),
                this
            );
        }
    };
    po(r => {
        r.draw = new hh({ context: r });
    });
    fo(r => {
        r.draw.dispose();
    });
    var ei = class extends Lt {
            constructor() {
                super(...arguments);
                (this.name = 'IntervalTimeline'), (this._root = null), (this._length = 0);
            }
            add(t) {
                j(Q(t.time), 'Events must have a time property'),
                    j(Q(t.duration), 'Events must have a duration parameter'),
                    (t.time = t.time.valueOf());
                let e = new ph(t.time, t.time + t.duration, t);
                for (
                    this._root === null ? (this._root = e) : this._root.insert(e), this._length++;
                    e !== null;

                )
                    e.updateHeight(), e.updateMax(), this._rebalance(e), (e = e.parent);
                return this;
            }
            remove(t) {
                if (this._root !== null) {
                    let e = [];
                    this._root.search(t.time, e);
                    for (let o of e)
                        if (o.event === t) {
                            this._removeNode(o), this._length--;
                            break;
                        }
                }
                return this;
            }
            get length() {
                return this._length;
            }
            cancel(t) {
                return this.forEachFrom(t, e => this.remove(e)), this;
            }
            _setRoot(t) {
                (this._root = t), this._root !== null && (this._root.parent = null);
            }
            _replaceNodeInParent(t, e) {
                t.parent !== null
                    ? (t.isLeftChild() ? (t.parent.left = e) : (t.parent.right = e),
                      this._rebalance(t.parent))
                    : this._setRoot(e);
            }
            _removeNode(t) {
                if (t.left === null && t.right === null) this._replaceNodeInParent(t, null);
                else if (t.right === null) this._replaceNodeInParent(t, t.left);
                else if (t.left === null) this._replaceNodeInParent(t, t.right);
                else {
                    let e = t.getBalance(),
                        o,
                        s = null;
                    if (e > 0)
                        if (t.left.right === null) (o = t.left), (o.right = t.right), (s = o);
                        else {
                            for (o = t.left.right; o.right !== null; ) o = o.right;
                            o.parent &&
                                ((o.parent.right = o.left),
                                (s = o.parent),
                                (o.left = t.left),
                                (o.right = t.right));
                        }
                    else if (t.right.left === null) (o = t.right), (o.left = t.left), (s = o);
                    else {
                        for (o = t.right.left; o.left !== null; ) o = o.left;
                        o.parent &&
                            ((o.parent.left = o.right),
                            (s = o.parent),
                            (o.left = t.left),
                            (o.right = t.right));
                    }
                    t.parent !== null
                        ? t.isLeftChild()
                            ? (t.parent.left = o)
                            : (t.parent.right = o)
                        : this._setRoot(o),
                        s && this._rebalance(s);
                }
                t.dispose();
            }
            _rotateLeft(t) {
                let e = t.parent,
                    o = t.isLeftChild(),
                    s = t.right;
                s && ((t.right = s.left), (s.left = t)),
                    e !== null ? (o ? (e.left = s) : (e.right = s)) : this._setRoot(s);
            }
            _rotateRight(t) {
                let e = t.parent,
                    o = t.isLeftChild(),
                    s = t.left;
                s && ((t.left = s.right), (s.right = t)),
                    e !== null ? (o ? (e.left = s) : (e.right = s)) : this._setRoot(s);
            }
            _rebalance(t) {
                let e = t.getBalance();
                e > 1 && t.left
                    ? t.left.getBalance() < 0
                        ? this._rotateLeft(t.left)
                        : this._rotateRight(t)
                    : e < -1 &&
                      t.right &&
                      (t.right.getBalance() > 0 ? this._rotateRight(t.right) : this._rotateLeft(t));
            }
            get(t) {
                if (this._root !== null) {
                    let e = [];
                    if ((this._root.search(t, e), e.length > 0)) {
                        let o = e[0];
                        for (let s = 1; s < e.length; s++) e[s].low > o.low && (o = e[s]);
                        return o.event;
                    }
                }
                return null;
            }
            forEach(t) {
                if (this._root !== null) {
                    let e = [];
                    this._root.traverse(o => e.push(o)),
                        e.forEach(o => {
                            o.event && t(o.event);
                        });
                }
                return this;
            }
            forEachAtTime(t, e) {
                if (this._root !== null) {
                    let o = [];
                    this._root.search(t, o),
                        o.forEach(s => {
                            s.event && e(s.event);
                        });
                }
                return this;
            }
            forEachFrom(t, e) {
                if (this._root !== null) {
                    let o = [];
                    this._root.searchAfter(t, o),
                        o.forEach(s => {
                            s.event && e(s.event);
                        });
                }
                return this;
            }
            dispose() {
                return (
                    super.dispose(),
                    this._root !== null && this._root.traverse(t => t.dispose()),
                    (this._root = null),
                    this
                );
            }
        },
        ph = class {
            constructor(t, e, o) {
                (this._left = null),
                    (this._right = null),
                    (this.parent = null),
                    (this.height = 0),
                    (this.event = o),
                    (this.low = t),
                    (this.high = e),
                    (this.max = this.high);
            }
            insert(t) {
                t.low <= this.low
                    ? this.left === null
                        ? (this.left = t)
                        : this.left.insert(t)
                    : this.right === null
                    ? (this.right = t)
                    : this.right.insert(t);
            }
            search(t, e) {
                t > this.max ||
                    (this.left !== null && this.left.search(t, e),
                    this.low <= t && this.high > t && e.push(this),
                    !(this.low > t) && this.right !== null && this.right.search(t, e));
            }
            searchAfter(t, e) {
                this.low >= t && (e.push(this), this.left !== null && this.left.searchAfter(t, e)),
                    this.right !== null && this.right.searchAfter(t, e);
            }
            traverse(t) {
                t(this),
                    this.left !== null && this.left.traverse(t),
                    this.right !== null && this.right.traverse(t);
            }
            updateHeight() {
                this.left !== null && this.right !== null
                    ? (this.height = Math.max(this.left.height, this.right.height) + 1)
                    : this.right !== null
                    ? (this.height = this.right.height + 1)
                    : this.left !== null
                    ? (this.height = this.left.height + 1)
                    : (this.height = 0);
            }
            updateMax() {
                (this.max = this.high),
                    this.left !== null && (this.max = Math.max(this.max, this.left.max)),
                    this.right !== null && (this.max = Math.max(this.max, this.right.max));
            }
            getBalance() {
                let t = 0;
                return (
                    this.left !== null && this.right !== null
                        ? (t = this.left.height - this.right.height)
                        : this.left !== null
                        ? (t = this.left.height + 1)
                        : this.right !== null && (t = -(this.right.height + 1)),
                    t
                );
            }
            isLeftChild() {
                return this.parent !== null && this.parent.left === this;
            }
            get left() {
                return this._left;
            }
            set left(t) {
                (this._left = t),
                    t !== null && (t.parent = this),
                    this.updateHeight(),
                    this.updateMax();
            }
            get right() {
                return this._right;
            }
            set right(t) {
                (this._right = t),
                    t !== null && (t.parent = this),
                    this.updateHeight(),
                    this.updateMax();
            }
            dispose() {
                (this.parent = null),
                    (this._left = null),
                    (this._right = null),
                    (this.event = null);
            }
        };
    var se = class extends S {
        constructor() {
            super(g(se.getDefaults(), arguments, ['volume']));
            this.name = 'Volume';
            let t = g(se.getDefaults(), arguments, ['volume']);
            (this.input = this.output =
                new P({ context: this.context, gain: t.volume, units: 'decibels' })),
                (this.volume = this.output.gain),
                M(this, 'volume'),
                (this._unmutedVolume = t.volume),
                (this.mute = t.mute);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { mute: !1, volume: 0 });
        }
        get mute() {
            return this.volume.value === -1 / 0;
        }
        set mute(t) {
            !this.mute && t
                ? ((this._unmutedVolume = this.volume.value), (this.volume.value = -1 / 0))
                : this.mute && !t && (this.volume.value = this._unmutedVolume);
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.volume.dispose(), this;
        }
    };
    var as = class extends S {
        constructor() {
            super(g(as.getDefaults(), arguments));
            (this.name = 'Destination'),
                (this.input = new se({ context: this.context })),
                (this.output = new P({ context: this.context })),
                (this.volume = this.input.volume);
            let t = g(as.getDefaults(), arguments);
            Qt(this.input, this.output, this.context.rawContext.destination),
                (this.mute = t.mute),
                (this._internalChannels = [
                    this.input,
                    this.context.rawContext.destination,
                    this.output,
                ]);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { mute: !1, volume: 0 });
        }
        get mute() {
            return this.input.mute;
        }
        set mute(t) {
            this.input.mute = t;
        }
        chain(...t) {
            return (
                this.input.disconnect(), t.unshift(this.input), t.push(this.output), Qt(...t), this
            );
        }
        get maxChannelCount() {
            return this.context.rawContext.destination.maxChannelCount;
        }
        dispose() {
            return super.dispose(), this.volume.dispose(), this;
        }
    };
    po(r => {
        r.destination = new as({ context: r });
    });
    fo(r => {
        r.destination.dispose();
    });
    var oi = class extends Lt {
        constructor(t) {
            super();
            (this.name = 'TimelineValue'),
                (this._timeline = new Rt({ memory: 10 })),
                (this._initialValue = t);
        }
        set(t, e) {
            return this._timeline.add({ value: t, time: e }), this;
        }
        get(t) {
            let e = this._timeline.get(t);
            return e ? e.value : this._initialValue;
        }
    };
    var ke = class {
        constructor(t, e) {
            this.id = ke._eventId++;
            let o = Object.assign(ke.getDefaults(), e);
            (this.transport = t),
                (this.callback = o.callback),
                (this._once = o.once),
                (this.time = o.time);
        }
        static getDefaults() {
            return { callback: $, once: !1, time: 0 };
        }
        invoke(t) {
            this.callback && (this.callback(t), this._once && this.transport.clear(this.id));
        }
        dispose() {
            return (this.callback = void 0), this;
        }
    };
    ke._eventId = 0;
    var cs = class extends ke {
        constructor(t, e) {
            super(t, e);
            (this._currentId = -1),
                (this._nextId = -1),
                (this._nextTick = this.time),
                (this._boundRestart = this._restart.bind(this));
            let o = Object.assign(cs.getDefaults(), e);
            (this.duration = new ee(t.context, o.duration).valueOf()),
                (this._interval = new ee(t.context, o.interval).valueOf()),
                (this._nextTick = o.time),
                this.transport.on('start', this._boundRestart),
                this.transport.on('loopStart', this._boundRestart),
                (this.context = this.transport.context),
                this._restart();
        }
        static getDefaults() {
            return Object.assign({}, ke.getDefaults(), { duration: 1 / 0, interval: 1, once: !1 });
        }
        invoke(t) {
            this._createEvents(t), super.invoke(t);
        }
        _createEvents(t) {
            let e = this.transport.getTicksAtTime(t);
            e >= this.time &&
                e >= this._nextTick &&
                this._nextTick + this._interval < this.time + this.duration &&
                ((this._nextTick += this._interval),
                (this._currentId = this._nextId),
                (this._nextId = this.transport.scheduleOnce(
                    this.invoke.bind(this),
                    new ee(this.context, this._nextTick).toSeconds()
                )));
        }
        _restart(t) {
            this.transport.clear(this._currentId),
                this.transport.clear(this._nextId),
                (this._nextTick = this.time);
            let e = this.transport.getTicksAtTime(t);
            e > this.time &&
                (this._nextTick =
                    this.time + Math.ceil((e - this.time) / this._interval) * this._interval),
                (this._currentId = this.transport.scheduleOnce(
                    this.invoke.bind(this),
                    new ee(this.context, this._nextTick).toSeconds()
                )),
                (this._nextTick += this._interval),
                (this._nextId = this.transport.scheduleOnce(
                    this.invoke.bind(this),
                    new ee(this.context, this._nextTick).toSeconds()
                ));
        }
        dispose() {
            return (
                super.dispose(),
                this.transport.clear(this._currentId),
                this.transport.clear(this._nextId),
                this.transport.off('start', this._boundRestart),
                this.transport.off('loopStart', this._boundRestart),
                this
            );
        }
    };
    var yr = class extends yt {
        constructor() {
            super(g(yr.getDefaults(), arguments));
            (this.name = 'Transport'),
                (this._loop = new oi(!1)),
                (this._loopStart = 0),
                (this._loopEnd = 0),
                (this._scheduledEvents = {}),
                (this._timeline = new Rt()),
                (this._repeatedEvents = new ei()),
                (this._syncedSignals = []),
                (this._swingAmount = 0);
            let t = g(yr.getDefaults(), arguments);
            (this._ppq = t.ppq),
                (this._clock = new go({
                    callback: this._processTick.bind(this),
                    context: this.context,
                    frequency: 0,
                    units: 'bpm',
                })),
                this._bindClockEvents(),
                (this.bpm = this._clock.frequency),
                (this._clock.frequency.multiplier = t.ppq),
                this.bpm.setValueAtTime(t.bpm, 0),
                M(this, 'bpm'),
                (this._timeSignature = t.timeSignature),
                (this._swingTicks = t.ppq / 2);
        }
        static getDefaults() {
            return Object.assign(yt.getDefaults(), {
                bpm: 120,
                loopEnd: '4m',
                loopStart: 0,
                ppq: 192,
                swing: 0,
                swingSubdivision: '8n',
                timeSignature: 4,
            });
        }
        _processTick(t, e) {
            if (
                (this._loop.get(t) &&
                    e >= this._loopEnd &&
                    (this.emit('loopEnd', t),
                    this._clock.setTicksAtTime(this._loopStart, t),
                    (e = this._loopStart),
                    this.emit('loopStart', t, this._clock.getSecondsAtTime(t)),
                    this.emit('loop', t)),
                this._swingAmount > 0 && e % this._ppq != 0 && e % (this._swingTicks * 2) != 0)
            ) {
                let o = (e % (this._swingTicks * 2)) / (this._swingTicks * 2),
                    s = Math.sin(o * Math.PI) * this._swingAmount;
                t += new ee(this.context, (this._swingTicks * 2) / 3).toSeconds() * s;
            }
            this._timeline.forEachAtTime(e, o => o.invoke(t));
        }
        schedule(t, e) {
            let o = new ke(this, { callback: t, time: new Ce(this.context, e).toTicks() });
            return this._addEvent(o, this._timeline);
        }
        scheduleRepeat(t, e, o, s = 1 / 0) {
            let n = new cs(this, {
                callback: t,
                duration: new Xt(this.context, s).toTicks(),
                interval: new Xt(this.context, e).toTicks(),
                time: new Ce(this.context, o).toTicks(),
            });
            return this._addEvent(n, this._repeatedEvents);
        }
        scheduleOnce(t, e) {
            let o = new ke(this, {
                callback: t,
                once: !0,
                time: new Ce(this.context, e).toTicks(),
            });
            return this._addEvent(o, this._timeline);
        }
        clear(t) {
            if (this._scheduledEvents.hasOwnProperty(t)) {
                let e = this._scheduledEvents[t.toString()];
                e.timeline.remove(e.event),
                    e.event.dispose(),
                    delete this._scheduledEvents[t.toString()];
            }
            return this;
        }
        _addEvent(t, e) {
            return (
                (this._scheduledEvents[t.id.toString()] = { event: t, timeline: e }), e.add(t), t.id
            );
        }
        cancel(t = 0) {
            let e = this.toTicks(t);
            return (
                this._timeline.forEachFrom(e, o => this.clear(o.id)),
                this._repeatedEvents.forEachFrom(e, o => this.clear(o.id)),
                this
            );
        }
        _bindClockEvents() {
            this._clock.on('start', (t, e) => {
                (e = new ee(this.context, e).toSeconds()), this.emit('start', t, e);
            }),
                this._clock.on('stop', t => {
                    this.emit('stop', t);
                }),
                this._clock.on('pause', t => {
                    this.emit('pause', t);
                });
        }
        get state() {
            return this._clock.getStateAtTime(this.now());
        }
        start(t, e) {
            let o;
            return Q(e) && (o = this.toTicks(e)), this._clock.start(t, o), this;
        }
        stop(t) {
            return this._clock.stop(t), this;
        }
        pause(t) {
            return this._clock.pause(t), this;
        }
        toggle(t) {
            return (
                (t = this.toSeconds(t)),
                this._clock.getStateAtTime(t) !== 'started' ? this.start(t) : this.stop(t),
                this
            );
        }
        get timeSignature() {
            return this._timeSignature;
        }
        set timeSignature(t) {
            kt(t) && (t = (t[0] / t[1]) * 4), (this._timeSignature = t);
        }
        get loopStart() {
            return new Xt(this.context, this._loopStart, 'i').toSeconds();
        }
        set loopStart(t) {
            this._loopStart = this.toTicks(t);
        }
        get loopEnd() {
            return new Xt(this.context, this._loopEnd, 'i').toSeconds();
        }
        set loopEnd(t) {
            this._loopEnd = this.toTicks(t);
        }
        get loop() {
            return this._loop.get(this.now());
        }
        set loop(t) {
            this._loop.set(t, this.now());
        }
        setLoopPoints(t, e) {
            return (this.loopStart = t), (this.loopEnd = e), this;
        }
        get swing() {
            return this._swingAmount;
        }
        set swing(t) {
            this._swingAmount = t;
        }
        get swingSubdivision() {
            return new ee(this.context, this._swingTicks).toNotation();
        }
        set swingSubdivision(t) {
            this._swingTicks = this.toTicks(t);
        }
        get position() {
            let t = this.now(),
                e = this._clock.getTicksAtTime(t);
            return new ee(this.context, e).toBarsBeatsSixteenths();
        }
        set position(t) {
            let e = this.toTicks(t);
            this.ticks = e;
        }
        get seconds() {
            return this._clock.seconds;
        }
        set seconds(t) {
            let e = this.now(),
                o = this._clock.frequency.timeToTicks(t, e);
            this.ticks = o;
        }
        get progress() {
            if (this.loop) {
                let t = this.now();
                return (
                    (this._clock.getTicksAtTime(t) - this._loopStart) /
                    (this._loopEnd - this._loopStart)
                );
            } else return 0;
        }
        get ticks() {
            return this._clock.ticks;
        }
        set ticks(t) {
            if (this._clock.ticks !== t) {
                let e = this.now();
                if (this.state === 'started') {
                    let o = this._clock.getTicksAtTime(e),
                        s = this._clock.frequency.getDurationOfTicks(Math.ceil(o) - o, e),
                        n = e + s;
                    this.emit('stop', n),
                        this._clock.setTicksAtTime(t, n),
                        this.emit('start', n, this._clock.getSecondsAtTime(n));
                } else this._clock.setTicksAtTime(t, e);
            }
        }
        getTicksAtTime(t) {
            return Math.round(this._clock.getTicksAtTime(t));
        }
        getSecondsAtTime(t) {
            return this._clock.getSecondsAtTime(t);
        }
        get PPQ() {
            return this._clock.frequency.multiplier;
        }
        set PPQ(t) {
            this._clock.frequency.multiplier = t;
        }
        nextSubdivision(t) {
            if (((t = this.toTicks(t)), this.state !== 'started')) return 0;
            {
                let e = this.now(),
                    o = this.getTicksAtTime(e),
                    s = t - (o % t);
                return this._clock.nextTickTime(s, e);
            }
        }
        syncSignal(t, e) {
            if (!e) {
                let s = this.now();
                if (t.getValueAtTime(s) !== 0) {
                    let n = this.bpm.getValueAtTime(s),
                        i = 1 / (60 / n / this.PPQ);
                    e = t.getValueAtTime(s) / i;
                } else e = 0;
            }
            let o = new P(e);
            return (
                this.bpm.connect(o),
                o.connect(t._param),
                this._syncedSignals.push({ initial: t.value, ratio: o, signal: t }),
                (t.value = 0),
                this
            );
        }
        unsyncSignal(t) {
            for (let e = this._syncedSignals.length - 1; e >= 0; e--) {
                let o = this._syncedSignals[e];
                o.signal === t &&
                    (o.ratio.dispose(),
                    (o.signal.value = o.initial),
                    this._syncedSignals.splice(e, 1));
            }
            return this;
        }
        dispose() {
            return (
                super.dispose(),
                this._clock.dispose(),
                So(this, 'bpm'),
                this._timeline.dispose(),
                this._repeatedEvents.dispose(),
                this
            );
        }
    };
    Qe.mixin(yr);
    po(r => {
        r.transport = new yr({ context: r });
    });
    fo(r => {
        r.transport.dispose();
    });
    var pt = class extends S {
        constructor(t) {
            super(t);
            (this.input = void 0),
                (this._state = new $e('stopped')),
                (this._synced = !1),
                (this._scheduled = []),
                (this._syncedStart = $),
                (this._syncedStop = $),
                (this._state.memory = 100),
                (this._state.increasing = !0),
                (this._volume = this.output =
                    new se({ context: this.context, mute: t.mute, volume: t.volume })),
                (this.volume = this._volume.volume),
                M(this, 'volume'),
                (this.onstop = t.onstop);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { mute: !1, onstop: $, volume: 0 });
        }
        get state() {
            return this._synced
                ? this.context.transport.state === 'started'
                    ? this._state.getValueAtTime(this.context.transport.seconds)
                    : 'stopped'
                : this._state.getValueAtTime(this.now());
        }
        get mute() {
            return this._volume.mute;
        }
        set mute(t) {
            this._volume.mute = t;
        }
        _clampToCurrentTime(t) {
            return this._synced ? t : Math.max(t, this.context.currentTime);
        }
        start(t, e, o) {
            let s = Dt(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
            if (
                ((s = this._clampToCurrentTime(s)),
                !this._synced && this._state.getValueAtTime(s) === 'started')
            )
                j(
                    dr(s, this._state.get(s).time),
                    'Start time must be strictly greater than previous start time'
                ),
                    this._state.cancel(s),
                    this._state.setStateAtTime('started', s),
                    this.log('restart', s),
                    this.restart(s, e, o);
            else if (
                (this.log('start', s), this._state.setStateAtTime('started', s), this._synced)
            ) {
                let n = this._state.get(s);
                n &&
                    ((n.offset = this.toSeconds(ce(e, 0))),
                    (n.duration = o ? this.toSeconds(o) : void 0));
                let i = this.context.transport.schedule(a => {
                    this._start(a, e, o);
                }, s);
                this._scheduled.push(i),
                    this.context.transport.state === 'started' &&
                        this.context.transport.getSecondsAtTime(this.immediate()) > s &&
                        this._syncedStart(this.now(), this.context.transport.seconds);
            } else Bs(this.context), this._start(s, e, o);
            return this;
        }
        stop(t) {
            let e = Dt(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
            if (
                ((e = this._clampToCurrentTime(e)),
                this._state.getValueAtTime(e) === 'started' ||
                    Q(this._state.getNextState('started', e)))
            ) {
                if ((this.log('stop', e), !this._synced)) this._stop(e);
                else {
                    let o = this.context.transport.schedule(this._stop.bind(this), e);
                    this._scheduled.push(o);
                }
                this._state.cancel(e), this._state.setStateAtTime('stopped', e);
            }
            return this;
        }
        restart(t, e, o) {
            return (
                (t = this.toSeconds(t)),
                this._state.getValueAtTime(t) === 'started' &&
                    (this._state.cancel(t), this._restart(t, e, o)),
                this
            );
        }
        sync() {
            return (
                this._synced ||
                    ((this._synced = !0),
                    (this._syncedStart = (t, e) => {
                        if (e > 0) {
                            let o = this._state.get(e);
                            if (o && o.state === 'started' && o.time !== e) {
                                let s = e - this.toSeconds(o.time),
                                    n;
                                o.duration && (n = this.toSeconds(o.duration) - s),
                                    this._start(t, this.toSeconds(o.offset) + s, n);
                            }
                        }
                    }),
                    (this._syncedStop = t => {
                        let e = this.context.transport.getSecondsAtTime(
                            Math.max(t - this.sampleTime, 0)
                        );
                        this._state.getValueAtTime(e) === 'started' && this._stop(t);
                    }),
                    this.context.transport.on('start', this._syncedStart),
                    this.context.transport.on('loopStart', this._syncedStart),
                    this.context.transport.on('stop', this._syncedStop),
                    this.context.transport.on('pause', this._syncedStop),
                    this.context.transport.on('loopEnd', this._syncedStop)),
                this
            );
        }
        unsync() {
            return (
                this._synced &&
                    (this.context.transport.off('stop', this._syncedStop),
                    this.context.transport.off('pause', this._syncedStop),
                    this.context.transport.off('loopEnd', this._syncedStop),
                    this.context.transport.off('start', this._syncedStart),
                    this.context.transport.off('loopStart', this._syncedStart)),
                (this._synced = !1),
                this._scheduled.forEach(t => this.context.transport.clear(t)),
                (this._scheduled = []),
                this._state.cancel(0),
                this._stop(0),
                this
            );
        }
        dispose() {
            return (
                super.dispose(),
                (this.onstop = $),
                this.unsync(),
                this._volume.dispose(),
                this._state.dispose(),
                this
            );
        }
    };
    var Ne = class extends Be {
        constructor() {
            super(g(Ne.getDefaults(), arguments, ['url', 'onload']));
            (this.name = 'ToneBufferSource'),
                (this._source = this.context.createBufferSource()),
                (this._internalChannels = [this._source]),
                (this._sourceStarted = !1),
                (this._sourceStopped = !1);
            let t = g(Ne.getDefaults(), arguments, ['url', 'onload']);
            Et(this._source, this._gainNode),
                (this._source.onended = () => this._stopSource()),
                (this.playbackRate = new X({
                    context: this.context,
                    param: this._source.playbackRate,
                    units: 'positive',
                    value: t.playbackRate,
                })),
                (this.loop = t.loop),
                (this.loopStart = t.loopStart),
                (this.loopEnd = t.loopEnd),
                (this._buffer = new st(t.url, t.onload, t.onerror)),
                this._internalChannels.push(this._source);
        }
        static getDefaults() {
            return Object.assign(Be.getDefaults(), {
                url: new st(),
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                onload: $,
                onerror: $,
                playbackRate: 1,
            });
        }
        get fadeIn() {
            return this._fadeIn;
        }
        set fadeIn(t) {
            this._fadeIn = t;
        }
        get fadeOut() {
            return this._fadeOut;
        }
        set fadeOut(t) {
            this._fadeOut = t;
        }
        get curve() {
            return this._curve;
        }
        set curve(t) {
            this._curve = t;
        }
        start(t, e, o, s = 1) {
            j(this.buffer.loaded, 'buffer is either not set or not loaded');
            let n = this.toSeconds(t);
            this._startGain(n, s), this.loop ? (e = ce(e, this.loopStart)) : (e = ce(e, 0));
            let i = Math.max(this.toSeconds(e), 0);
            if (this.loop) {
                let a = this.toSeconds(this.loopEnd) || this.buffer.duration,
                    c = this.toSeconds(this.loopStart),
                    u = a - c;
                os(i, a) && (i = ((i - c) % u) + c), te(i, this.buffer.duration) && (i = 0);
            }
            if (
                ((this._source.buffer = this.buffer.get()),
                (this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration),
                Ys(i, this.buffer.duration) &&
                    ((this._sourceStarted = !0), this._source.start(n, i)),
                Q(o))
            ) {
                let a = this.toSeconds(o);
                (a = Math.max(a, 0)), this.stop(n + a);
            }
            return this;
        }
        _stopSource(t) {
            !this._sourceStopped &&
                this._sourceStarted &&
                ((this._sourceStopped = !0), this._source.stop(this.toSeconds(t)), this._onended());
        }
        get loopStart() {
            return this._source.loopStart;
        }
        set loopStart(t) {
            this._source.loopStart = this.toSeconds(t);
        }
        get loopEnd() {
            return this._source.loopEnd;
        }
        set loopEnd(t) {
            this._source.loopEnd = this.toSeconds(t);
        }
        get buffer() {
            return this._buffer;
        }
        set buffer(t) {
            this._buffer.set(t);
        }
        get loop() {
            return this._source.loop;
        }
        set loop(t) {
            (this._source.loop = t), this._sourceStarted && this.cancelStop();
        }
        dispose() {
            return (
                super.dispose(),
                (this._source.onended = null),
                this._source.disconnect(),
                this._buffer.dispose(),
                this.playbackRate.dispose(),
                this
            );
        }
    };
    var z5 = 44100 * 5;
    function ne(r, t) {
        return et(this, void 0, void 0, function* () {
            let e = t / r.context.sampleRate,
                o = new Ze(1, e, r.context.sampleRate);
            return (
                new r.constructor(
                    Object.assign(r.get(), { frequency: 2 / e, detune: 0, context: o })
                )
                    .toDestination()
                    .start(0),
                (yield o.render()).getChannelData(0)
            );
        });
    }
    var Eo = class extends Be {
        constructor() {
            super(g(Eo.getDefaults(), arguments, ['frequency', 'type']));
            (this.name = 'ToneOscillatorNode'),
                (this._oscillator = this.context.createOscillator()),
                (this._internalChannels = [this._oscillator]);
            let t = g(Eo.getDefaults(), arguments, ['frequency', 'type']);
            Et(this._oscillator, this._gainNode),
                (this.type = t.type),
                (this.frequency = new X({
                    context: this.context,
                    param: this._oscillator.frequency,
                    units: 'frequency',
                    value: t.frequency,
                })),
                (this.detune = new X({
                    context: this.context,
                    param: this._oscillator.detune,
                    units: 'cents',
                    value: t.detune,
                })),
                M(this, ['frequency', 'detune']);
        }
        static getDefaults() {
            return Object.assign(Be.getDefaults(), { detune: 0, frequency: 440, type: 'sine' });
        }
        start(t) {
            let e = this.toSeconds(t);
            return this.log('start', e), this._startGain(e), this._oscillator.start(e), this;
        }
        _stopSource(t) {
            this._oscillator.stop(t);
        }
        setPeriodicWave(t) {
            return this._oscillator.setPeriodicWave(t), this;
        }
        get type() {
            return this._oscillator.type;
        }
        set type(t) {
            this._oscillator.type = t;
        }
        dispose() {
            return (
                super.dispose(),
                this.state === 'started' && this.stop(),
                this._oscillator.disconnect(),
                this.frequency.dispose(),
                this.detune.dispose(),
                this
            );
        }
    };
    var at = class extends pt {
        constructor() {
            super(g(at.getDefaults(), arguments, ['frequency', 'type']));
            (this.name = 'Oscillator'), (this._oscillator = null);
            let t = g(at.getDefaults(), arguments, ['frequency', 'type']);
            (this.frequency = new z({
                context: this.context,
                units: 'frequency',
                value: t.frequency,
            })),
                M(this, 'frequency'),
                (this.detune = new z({ context: this.context, units: 'cents', value: t.detune })),
                M(this, 'detune'),
                (this._partials = t.partials),
                (this._partialCount = t.partialCount),
                (this._type = t.type),
                t.partialCount &&
                    t.type !== 'custom' &&
                    (this._type = this.baseType + t.partialCount.toString()),
                (this.phase = t.phase);
        }
        static getDefaults() {
            return Object.assign(pt.getDefaults(), {
                detune: 0,
                frequency: 440,
                partialCount: 0,
                partials: [],
                phase: 0,
                type: 'sine',
            });
        }
        _start(t) {
            let e = this.toSeconds(t),
                o = new Eo({ context: this.context, onended: () => this.onstop(this) });
            (this._oscillator = o),
                this._wave
                    ? this._oscillator.setPeriodicWave(this._wave)
                    : (this._oscillator.type = this._type),
                this._oscillator.connect(this.output),
                this.frequency.connect(this._oscillator.frequency),
                this.detune.connect(this._oscillator.detune),
                this._oscillator.start(e);
        }
        _stop(t) {
            let e = this.toSeconds(t);
            this._oscillator && this._oscillator.stop(e);
        }
        _restart(t) {
            let e = this.toSeconds(t);
            return (
                this.log('restart', e),
                this._oscillator && this._oscillator.cancelStop(),
                this._state.cancel(e),
                this
            );
        }
        syncFrequency() {
            return this.context.transport.syncSignal(this.frequency), this;
        }
        unsyncFrequency() {
            return this.context.transport.unsyncSignal(this.frequency), this;
        }
        _getCachedPeriodicWave() {
            if (this._type === 'custom')
                return at._periodicWaveCache.find(
                    e => e.phase === this._phase && oh(e.partials, this._partials)
                );
            {
                let t = at._periodicWaveCache.find(
                    e => e.type === this._type && e.phase === this._phase
                );
                return (this._partialCount = t ? t.partialCount : this._partialCount), t;
            }
        }
        get type() {
            return this._type;
        }
        set type(t) {
            this._type = t;
            let e = ['sine', 'square', 'sawtooth', 'triangle'].indexOf(t) !== -1;
            if (this._phase === 0 && e)
                (this._wave = void 0),
                    (this._partialCount = 0),
                    this._oscillator !== null && (this._oscillator.type = t);
            else {
                let o = this._getCachedPeriodicWave();
                if (Q(o)) {
                    let { partials: s, wave: n } = o;
                    (this._wave = n),
                        (this._partials = s),
                        this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave);
                } else {
                    let [s, n] = this._getRealImaginary(t, this._phase),
                        i = this.context.createPeriodicWave(s, n);
                    (this._wave = i),
                        this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave),
                        at._periodicWaveCache.push({
                            imag: n,
                            partialCount: this._partialCount,
                            partials: this._partials,
                            phase: this._phase,
                            real: s,
                            type: this._type,
                            wave: this._wave,
                        }),
                        at._periodicWaveCache.length > 100 && at._periodicWaveCache.shift();
                }
            }
        }
        get baseType() {
            return this._type.replace(this.partialCount.toString(), '');
        }
        set baseType(t) {
            this.partialCount && this._type !== 'custom' && t !== 'custom'
                ? (this.type = t + this.partialCount)
                : (this.type = t);
        }
        get partialCount() {
            return this._partialCount;
        }
        set partialCount(t) {
            qt(t, 0);
            let e = this._type,
                o = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
            if ((o && (e = o[1]), this._type !== 'custom'))
                t === 0 ? (this.type = e) : (this.type = e + t.toString());
            else {
                let s = new Float32Array(t);
                this._partials.forEach((n, i) => (s[i] = n)),
                    (this._partials = Array.from(s)),
                    (this.type = this._type);
            }
        }
        _getRealImaginary(t, e) {
            let s = 4096 / 2,
                n = new Float32Array(s),
                i = new Float32Array(s),
                a = 1;
            if (t === 'custom') {
                if (
                    ((a = this._partials.length + 1),
                    (this._partialCount = this._partials.length),
                    (s = a),
                    this._partials.length === 0)
                )
                    return [n, i];
            } else {
                let c = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);
                c
                    ? ((a = parseInt(c[2], 10) + 1),
                      (this._partialCount = parseInt(c[2], 10)),
                      (t = c[1]),
                      (a = Math.max(a, 2)),
                      (s = a))
                    : (this._partialCount = 0),
                    (this._partials = []);
            }
            for (let c = 1; c < s; ++c) {
                let u = 2 / (c * Math.PI),
                    l;
                switch (t) {
                    case 'sine':
                        (l = c <= a ? 1 : 0), (this._partials[c - 1] = l);
                        break;
                    case 'square':
                        (l = c & 1 ? 2 * u : 0), (this._partials[c - 1] = l);
                        break;
                    case 'sawtooth':
                        (l = u * (c & 1 ? 1 : -1)), (this._partials[c - 1] = l);
                        break;
                    case 'triangle':
                        c & 1 ? (l = 2 * (u * u) * (((c - 1) >> 1) & 1 ? -1 : 1)) : (l = 0),
                            (this._partials[c - 1] = l);
                        break;
                    case 'custom':
                        l = this._partials[c - 1];
                        break;
                    default:
                        throw new TypeError('Oscillator: invalid type: ' + t);
                }
                l !== 0
                    ? ((n[c] = -l * Math.sin(e * c)), (i[c] = l * Math.cos(e * c)))
                    : ((n[c] = 0), (i[c] = 0));
            }
            return [n, i];
        }
        _inverseFFT(t, e, o) {
            let s = 0,
                n = t.length;
            for (let i = 0; i < n; i++) s += t[i] * Math.cos(i * o) + e[i] * Math.sin(i * o);
            return s;
        }
        getInitialValue() {
            let [t, e] = this._getRealImaginary(this._type, 0),
                o = 0,
                s = Math.PI * 2,
                n = 32;
            for (let i = 0; i < n; i++) o = Math.max(this._inverseFFT(t, e, (i / n) * s), o);
            return $n(-this._inverseFFT(t, e, this._phase) / o, -1, 1);
        }
        get partials() {
            return this._partials.slice(0, this.partialCount);
        }
        set partials(t) {
            (this._partials = t),
                (this._partialCount = this._partials.length),
                t.length && (this.type = 'custom');
        }
        get phase() {
            return this._phase * (180 / Math.PI);
        }
        set phase(t) {
            (this._phase = (t * Math.PI) / 180), (this.type = this._type);
        }
        asArray(t = 1024) {
            return et(this, void 0, void 0, function* () {
                return ne(this, t);
            });
        }
        dispose() {
            return (
                super.dispose(),
                this._oscillator !== null && this._oscillator.dispose(),
                (this._wave = void 0),
                this.frequency.dispose(),
                this.detune.dispose(),
                this
            );
        }
    };
    at._periodicWaveCache = [];
    var Bt = class extends S {
        constructor() {
            super(Object.assign(g(Bt.getDefaults(), arguments, ['context'])));
        }
        connect(t, e = 0, o = 0) {
            return Oo(this, t, e, o), this;
        }
    };
    var zt = class extends Bt {
        constructor() {
            super(Object.assign(g(zt.getDefaults(), arguments, ['mapping', 'length'])));
            (this.name = 'WaveShaper'),
                (this._shaper = this.context.createWaveShaper()),
                (this.input = this._shaper),
                (this.output = this._shaper);
            let t = g(zt.getDefaults(), arguments, ['mapping', 'length']);
            kt(t.mapping) || t.mapping instanceof Float32Array
                ? (this.curve = Float32Array.from(t.mapping))
                : Ol(t.mapping) && this.setMap(t.mapping, t.length);
        }
        static getDefaults() {
            return Object.assign(z.getDefaults(), { length: 1024 });
        }
        setMap(t, e = 1024) {
            let o = new Float32Array(e);
            for (let s = 0, n = e; s < n; s++) {
                let i = (s / (n - 1)) * 2 - 1;
                o[s] = t(i, s);
            }
            return (this.curve = o), this;
        }
        get curve() {
            return this._shaper.curve;
        }
        set curve(t) {
            this._shaper.curve = t;
        }
        get oversample() {
            return this._shaper.oversample;
        }
        set oversample(t) {
            let e = ['none', '2x', '4x'].some(o => o.includes(t));
            j(e, "oversampling must be either 'none', '2x', or '4x'"),
                (this._shaper.oversample = t);
        }
        dispose() {
            return super.dispose(), this._shaper.disconnect(), this;
        }
    };
    var vr = class extends Bt {
        constructor() {
            super(...arguments);
            (this.name = 'AudioToGain'),
                (this._norm = new zt({ context: this.context, mapping: t => (t + 1) / 2 })),
                (this.input = this._norm),
                (this.output = this._norm);
        }
        dispose() {
            return super.dispose(), this._norm.dispose(), this;
        }
    };
    var _t = class extends z {
        constructor() {
            super(Object.assign(g(_t.getDefaults(), arguments, ['value'])));
            (this.name = 'Multiply'), (this.override = !1);
            let t = g(_t.getDefaults(), arguments, ['value']);
            (this._mult =
                this.input =
                this.output =
                    new P({ context: this.context, minValue: t.minValue, maxValue: t.maxValue })),
                (this.factor = this._param = this._mult.gain),
                this.factor.setValueAtTime(t.value, 0);
        }
        static getDefaults() {
            return Object.assign(z.getDefaults(), { value: 0 });
        }
        dispose() {
            return super.dispose(), this._mult.dispose(), this;
        }
    };
    var Mo = class extends pt {
        constructor() {
            super(g(Mo.getDefaults(), arguments, ['frequency', 'type', 'modulationType']));
            (this.name = 'AMOscillator'),
                (this._modulationScale = new vr({ context: this.context })),
                (this._modulationNode = new P({ context: this.context }));
            let t = g(Mo.getDefaults(), arguments, ['frequency', 'type', 'modulationType']);
            (this._carrier = new at({
                context: this.context,
                detune: t.detune,
                frequency: t.frequency,
                onstop: () => this.onstop(this),
                phase: t.phase,
                type: t.type,
            })),
                (this.frequency = this._carrier.frequency),
                (this.detune = this._carrier.detune),
                (this._modulator = new at({
                    context: this.context,
                    phase: t.phase,
                    type: t.modulationType,
                })),
                (this.harmonicity = new _t({
                    context: this.context,
                    units: 'positive',
                    value: t.harmonicity,
                })),
                this.frequency.chain(this.harmonicity, this._modulator.frequency),
                this._modulator.chain(this._modulationScale, this._modulationNode.gain),
                this._carrier.chain(this._modulationNode, this.output),
                M(this, ['frequency', 'detune', 'harmonicity']);
        }
        static getDefaults() {
            return Object.assign(at.getDefaults(), { harmonicity: 1, modulationType: 'square' });
        }
        _start(t) {
            this._modulator.start(t), this._carrier.start(t);
        }
        _stop(t) {
            this._modulator.stop(t), this._carrier.stop(t);
        }
        _restart(t) {
            this._modulator.restart(t), this._carrier.restart(t);
        }
        get type() {
            return this._carrier.type;
        }
        set type(t) {
            this._carrier.type = t;
        }
        get baseType() {
            return this._carrier.baseType;
        }
        set baseType(t) {
            this._carrier.baseType = t;
        }
        get partialCount() {
            return this._carrier.partialCount;
        }
        set partialCount(t) {
            this._carrier.partialCount = t;
        }
        get modulationType() {
            return this._modulator.type;
        }
        set modulationType(t) {
            this._modulator.type = t;
        }
        get phase() {
            return this._carrier.phase;
        }
        set phase(t) {
            (this._carrier.phase = t), (this._modulator.phase = t);
        }
        get partials() {
            return this._carrier.partials;
        }
        set partials(t) {
            this._carrier.partials = t;
        }
        asArray(t = 1024) {
            return et(this, void 0, void 0, function* () {
                return ne(this, t);
            });
        }
        dispose() {
            return (
                super.dispose(),
                this.frequency.dispose(),
                this.detune.dispose(),
                this.harmonicity.dispose(),
                this._carrier.dispose(),
                this._modulator.dispose(),
                this._modulationNode.dispose(),
                this._modulationScale.dispose(),
                this
            );
        }
    };
    var Ke = class extends pt {
        constructor() {
            super(g(Ke.getDefaults(), arguments, ['frequency', 'type', 'modulationType']));
            (this.name = 'FMOscillator'),
                (this._modulationNode = new P({ context: this.context, gain: 0 }));
            let t = g(Ke.getDefaults(), arguments, ['frequency', 'type', 'modulationType']);
            (this._carrier = new at({
                context: this.context,
                detune: t.detune,
                frequency: 0,
                onstop: () => this.onstop(this),
                phase: t.phase,
                type: t.type,
            })),
                (this.detune = this._carrier.detune),
                (this.frequency = new z({
                    context: this.context,
                    units: 'frequency',
                    value: t.frequency,
                })),
                (this._modulator = new at({
                    context: this.context,
                    phase: t.phase,
                    type: t.modulationType,
                })),
                (this.harmonicity = new _t({
                    context: this.context,
                    units: 'positive',
                    value: t.harmonicity,
                })),
                (this.modulationIndex = new _t({
                    context: this.context,
                    units: 'positive',
                    value: t.modulationIndex,
                })),
                this.frequency.connect(this._carrier.frequency),
                this.frequency.chain(this.harmonicity, this._modulator.frequency),
                this.frequency.chain(this.modulationIndex, this._modulationNode),
                this._modulator.connect(this._modulationNode.gain),
                this._modulationNode.connect(this._carrier.frequency),
                this._carrier.connect(this.output),
                this.detune.connect(this._modulator.detune),
                M(this, ['modulationIndex', 'frequency', 'detune', 'harmonicity']);
        }
        static getDefaults() {
            return Object.assign(at.getDefaults(), {
                harmonicity: 1,
                modulationIndex: 2,
                modulationType: 'square',
            });
        }
        _start(t) {
            this._modulator.start(t), this._carrier.start(t);
        }
        _stop(t) {
            this._modulator.stop(t), this._carrier.stop(t);
        }
        _restart(t) {
            return this._modulator.restart(t), this._carrier.restart(t), this;
        }
        get type() {
            return this._carrier.type;
        }
        set type(t) {
            this._carrier.type = t;
        }
        get baseType() {
            return this._carrier.baseType;
        }
        set baseType(t) {
            this._carrier.baseType = t;
        }
        get partialCount() {
            return this._carrier.partialCount;
        }
        set partialCount(t) {
            this._carrier.partialCount = t;
        }
        get modulationType() {
            return this._modulator.type;
        }
        set modulationType(t) {
            this._modulator.type = t;
        }
        get phase() {
            return this._carrier.phase;
        }
        set phase(t) {
            (this._carrier.phase = t), (this._modulator.phase = t);
        }
        get partials() {
            return this._carrier.partials;
        }
        set partials(t) {
            this._carrier.partials = t;
        }
        asArray(t = 1024) {
            return et(this, void 0, void 0, function* () {
                return ne(this, t);
            });
        }
        dispose() {
            return (
                super.dispose(),
                this.frequency.dispose(),
                this.harmonicity.dispose(),
                this._carrier.dispose(),
                this._modulator.dispose(),
                this._modulationNode.dispose(),
                this.modulationIndex.dispose(),
                this
            );
        }
    };
    var Je = class extends pt {
        constructor() {
            super(g(Je.getDefaults(), arguments, ['frequency', 'width']));
            (this.name = 'PulseOscillator'),
                (this._widthGate = new P({ context: this.context, gain: 0 })),
                (this._thresh = new zt({ context: this.context, mapping: e => (e <= 0 ? -1 : 1) }));
            let t = g(Je.getDefaults(), arguments, ['frequency', 'width']);
            (this.width = new z({ context: this.context, units: 'audioRange', value: t.width })),
                (this._triangle = new at({
                    context: this.context,
                    detune: t.detune,
                    frequency: t.frequency,
                    onstop: () => this.onstop(this),
                    phase: t.phase,
                    type: 'triangle',
                })),
                (this.frequency = this._triangle.frequency),
                (this.detune = this._triangle.detune),
                this._triangle.chain(this._thresh, this.output),
                this.width.chain(this._widthGate, this._thresh),
                M(this, ['width', 'frequency', 'detune']);
        }
        static getDefaults() {
            return Object.assign(pt.getDefaults(), {
                detune: 0,
                frequency: 440,
                phase: 0,
                type: 'pulse',
                width: 0.2,
            });
        }
        _start(t) {
            (t = this.toSeconds(t)),
                this._triangle.start(t),
                this._widthGate.gain.setValueAtTime(1, t);
        }
        _stop(t) {
            (t = this.toSeconds(t)),
                this._triangle.stop(t),
                this._widthGate.gain.cancelScheduledValues(t),
                this._widthGate.gain.setValueAtTime(0, t);
        }
        _restart(t) {
            this._triangle.restart(t),
                this._widthGate.gain.cancelScheduledValues(t),
                this._widthGate.gain.setValueAtTime(1, t);
        }
        get phase() {
            return this._triangle.phase;
        }
        set phase(t) {
            this._triangle.phase = t;
        }
        get type() {
            return 'pulse';
        }
        get baseType() {
            return 'pulse';
        }
        get partials() {
            return [];
        }
        get partialCount() {
            return 0;
        }
        set carrierType(t) {
            this._triangle.type = t;
        }
        asArray(t = 1024) {
            return et(this, void 0, void 0, function* () {
                return ne(this, t);
            });
        }
        dispose() {
            return (
                super.dispose(),
                this._triangle.dispose(),
                this.width.dispose(),
                this._widthGate.dispose(),
                this._thresh.dispose(),
                this
            );
        }
    };
    var Fo = class extends pt {
        constructor() {
            super(g(Fo.getDefaults(), arguments, ['frequency', 'type', 'spread']));
            (this.name = 'FatOscillator'), (this._oscillators = []);
            let t = g(Fo.getDefaults(), arguments, ['frequency', 'type', 'spread']);
            (this.frequency = new z({
                context: this.context,
                units: 'frequency',
                value: t.frequency,
            })),
                (this.detune = new z({ context: this.context, units: 'cents', value: t.detune })),
                (this._spread = t.spread),
                (this._type = t.type),
                (this._phase = t.phase),
                (this._partials = t.partials),
                (this._partialCount = t.partialCount),
                (this.count = t.count),
                M(this, ['frequency', 'detune']);
        }
        static getDefaults() {
            return Object.assign(at.getDefaults(), { count: 3, spread: 20, type: 'sawtooth' });
        }
        _start(t) {
            (t = this.toSeconds(t)), this._forEach(e => e.start(t));
        }
        _stop(t) {
            (t = this.toSeconds(t)), this._forEach(e => e.stop(t));
        }
        _restart(t) {
            this._forEach(e => e.restart(t));
        }
        _forEach(t) {
            for (let e = 0; e < this._oscillators.length; e++) t(this._oscillators[e], e);
        }
        get type() {
            return this._type;
        }
        set type(t) {
            (this._type = t), this._forEach(e => (e.type = t));
        }
        get spread() {
            return this._spread;
        }
        set spread(t) {
            if (((this._spread = t), this._oscillators.length > 1)) {
                let e = -t / 2,
                    o = t / (this._oscillators.length - 1);
                this._forEach((s, n) => (s.detune.value = e + o * n));
            }
        }
        get count() {
            return this._oscillators.length;
        }
        set count(t) {
            if ((qt(t, 1), this._oscillators.length !== t)) {
                this._forEach(e => e.dispose()), (this._oscillators = []);
                for (let e = 0; e < t; e++) {
                    let o = new at({
                        context: this.context,
                        volume: -6 - t * 1.1,
                        type: this._type,
                        phase: this._phase + (e / t) * 360,
                        partialCount: this._partialCount,
                        onstop: e === 0 ? () => this.onstop(this) : $,
                    });
                    this.type === 'custom' && (o.partials = this._partials),
                        this.frequency.connect(o.frequency),
                        this.detune.connect(o.detune),
                        (o.detune.overridden = !1),
                        o.connect(this.output),
                        (this._oscillators[e] = o);
                }
                (this.spread = this._spread),
                    this.state === 'started' && this._forEach(e => e.start());
            }
        }
        get phase() {
            return this._phase;
        }
        set phase(t) {
            (this._phase = t),
                this._forEach((e, o) => (e.phase = this._phase + (o / this.count) * 360));
        }
        get baseType() {
            return this._oscillators[0].baseType;
        }
        set baseType(t) {
            this._forEach(e => (e.baseType = t)), (this._type = this._oscillators[0].type);
        }
        get partials() {
            return this._oscillators[0].partials;
        }
        set partials(t) {
            (this._partials = t),
                (this._partialCount = this._partials.length),
                t.length && ((this._type = 'custom'), this._forEach(e => (e.partials = t)));
        }
        get partialCount() {
            return this._oscillators[0].partialCount;
        }
        set partialCount(t) {
            (this._partialCount = t),
                this._forEach(e => (e.partialCount = t)),
                (this._type = this._oscillators[0].type);
        }
        asArray(t = 1024) {
            return et(this, void 0, void 0, function* () {
                return ne(this, t);
            });
        }
        dispose() {
            return (
                super.dispose(),
                this.frequency.dispose(),
                this.detune.dispose(),
                this._forEach(t => t.dispose()),
                this
            );
        }
    };
    var Io = class extends pt {
        constructor() {
            super(g(Io.getDefaults(), arguments, ['frequency', 'modulationFrequency']));
            (this.name = 'PWMOscillator'),
                (this.sourceType = 'pwm'),
                (this._scale = new _t({ context: this.context, value: 2 }));
            let t = g(Io.getDefaults(), arguments, ['frequency', 'modulationFrequency']);
            (this._pulse = new Je({ context: this.context, frequency: t.modulationFrequency })),
                (this._pulse.carrierType = 'sine'),
                (this.modulationFrequency = this._pulse.frequency),
                (this._modulator = new at({
                    context: this.context,
                    detune: t.detune,
                    frequency: t.frequency,
                    onstop: () => this.onstop(this),
                    phase: t.phase,
                })),
                (this.frequency = this._modulator.frequency),
                (this.detune = this._modulator.detune),
                this._modulator.chain(this._scale, this._pulse.width),
                this._pulse.connect(this.output),
                M(this, ['modulationFrequency', 'frequency', 'detune']);
        }
        static getDefaults() {
            return Object.assign(pt.getDefaults(), {
                detune: 0,
                frequency: 440,
                modulationFrequency: 0.4,
                phase: 0,
                type: 'pwm',
            });
        }
        _start(t) {
            (t = this.toSeconds(t)), this._modulator.start(t), this._pulse.start(t);
        }
        _stop(t) {
            (t = this.toSeconds(t)), this._modulator.stop(t), this._pulse.stop(t);
        }
        _restart(t) {
            this._modulator.restart(t), this._pulse.restart(t);
        }
        get type() {
            return 'pwm';
        }
        get baseType() {
            return 'pwm';
        }
        get partials() {
            return [];
        }
        get partialCount() {
            return 0;
        }
        get phase() {
            return this._modulator.phase;
        }
        set phase(t) {
            this._modulator.phase = t;
        }
        asArray(t = 1024) {
            return et(this, void 0, void 0, function* () {
                return ne(this, t);
            });
        }
        dispose() {
            return (
                super.dispose(),
                this._pulse.dispose(),
                this._scale.dispose(),
                this._modulator.dispose(),
                this
            );
        }
    };
    var dh = { am: Mo, fat: Fo, fm: Ke, oscillator: at, pulse: Je, pwm: Io },
        to = class extends pt {
            constructor() {
                super(g(to.getDefaults(), arguments, ['frequency', 'type']));
                this.name = 'OmniOscillator';
                let t = g(to.getDefaults(), arguments, ['frequency', 'type']);
                (this.frequency = new z({
                    context: this.context,
                    units: 'frequency',
                    value: t.frequency,
                })),
                    (this.detune = new z({
                        context: this.context,
                        units: 'cents',
                        value: t.detune,
                    })),
                    M(this, ['frequency', 'detune']),
                    this.set(t);
            }
            static getDefaults() {
                return Object.assign(
                    at.getDefaults(),
                    Ke.getDefaults(),
                    Mo.getDefaults(),
                    Fo.getDefaults(),
                    Je.getDefaults(),
                    Io.getDefaults()
                );
            }
            _start(t) {
                this._oscillator.start(t);
            }
            _stop(t) {
                this._oscillator.stop(t);
            }
            _restart(t) {
                return this._oscillator.restart(t), this;
            }
            get type() {
                let t = '';
                return (
                    ['am', 'fm', 'fat'].some(e => this._sourceType === e) && (t = this._sourceType),
                    t + this._oscillator.type
                );
            }
            set type(t) {
                t.substr(0, 2) === 'fm'
                    ? (this._createNewOscillator('fm'),
                      (this._oscillator = this._oscillator),
                      (this._oscillator.type = t.substr(2)))
                    : t.substr(0, 2) === 'am'
                    ? (this._createNewOscillator('am'),
                      (this._oscillator = this._oscillator),
                      (this._oscillator.type = t.substr(2)))
                    : t.substr(0, 3) === 'fat'
                    ? (this._createNewOscillator('fat'),
                      (this._oscillator = this._oscillator),
                      (this._oscillator.type = t.substr(3)))
                    : t === 'pwm'
                    ? (this._createNewOscillator('pwm'), (this._oscillator = this._oscillator))
                    : t === 'pulse'
                    ? this._createNewOscillator('pulse')
                    : (this._createNewOscillator('oscillator'),
                      (this._oscillator = this._oscillator),
                      (this._oscillator.type = t));
            }
            get partials() {
                return this._oscillator.partials;
            }
            set partials(t) {
                !this._getOscType(this._oscillator, 'pulse') &&
                    !this._getOscType(this._oscillator, 'pwm') &&
                    (this._oscillator.partials = t);
            }
            get partialCount() {
                return this._oscillator.partialCount;
            }
            set partialCount(t) {
                !this._getOscType(this._oscillator, 'pulse') &&
                    !this._getOscType(this._oscillator, 'pwm') &&
                    (this._oscillator.partialCount = t);
            }
            set(t) {
                return Reflect.has(t, 'type') && t.type && (this.type = t.type), super.set(t), this;
            }
            _createNewOscillator(t) {
                if (t !== this._sourceType) {
                    this._sourceType = t;
                    let e = dh[t],
                        o = this.now();
                    if (this._oscillator) {
                        let s = this._oscillator;
                        s.stop(o), this.context.setTimeout(() => s.dispose(), this.blockTime);
                    }
                    (this._oscillator = new e({ context: this.context })),
                        this.frequency.connect(this._oscillator.frequency),
                        this.detune.connect(this._oscillator.detune),
                        this._oscillator.connect(this.output),
                        (this._oscillator.onstop = () => this.onstop(this)),
                        this.state === 'started' && this._oscillator.start(o);
                }
            }
            get phase() {
                return this._oscillator.phase;
            }
            set phase(t) {
                this._oscillator.phase = t;
            }
            get sourceType() {
                return this._sourceType;
            }
            set sourceType(t) {
                let e = 'sine';
                this._oscillator.type !== 'pwm' &&
                    this._oscillator.type !== 'pulse' &&
                    (e = this._oscillator.type),
                    t === 'fm'
                        ? (this.type = 'fm' + e)
                        : t === 'am'
                        ? (this.type = 'am' + e)
                        : t === 'fat'
                        ? (this.type = 'fat' + e)
                        : t === 'oscillator'
                        ? (this.type = e)
                        : t === 'pulse'
                        ? (this.type = 'pulse')
                        : t === 'pwm' && (this.type = 'pwm');
            }
            _getOscType(t, e) {
                return t instanceof dh[e];
            }
            get baseType() {
                return this._oscillator.baseType;
            }
            set baseType(t) {
                !this._getOscType(this._oscillator, 'pulse') &&
                    !this._getOscType(this._oscillator, 'pwm') &&
                    t !== 'pulse' &&
                    t !== 'pwm' &&
                    (this._oscillator.baseType = t);
            }
            get width() {
                if (this._getOscType(this._oscillator, 'pulse')) return this._oscillator.width;
            }
            get count() {
                if (this._getOscType(this._oscillator, 'fat')) return this._oscillator.count;
            }
            set count(t) {
                this._getOscType(this._oscillator, 'fat') && Yt(t) && (this._oscillator.count = t);
            }
            get spread() {
                if (this._getOscType(this._oscillator, 'fat')) return this._oscillator.spread;
            }
            set spread(t) {
                this._getOscType(this._oscillator, 'fat') && Yt(t) && (this._oscillator.spread = t);
            }
            get modulationType() {
                if (
                    this._getOscType(this._oscillator, 'fm') ||
                    this._getOscType(this._oscillator, 'am')
                )
                    return this._oscillator.modulationType;
            }
            set modulationType(t) {
                (this._getOscType(this._oscillator, 'fm') ||
                    this._getOscType(this._oscillator, 'am')) &&
                    Vt(t) &&
                    (this._oscillator.modulationType = t);
            }
            get modulationIndex() {
                if (this._getOscType(this._oscillator, 'fm'))
                    return this._oscillator.modulationIndex;
            }
            get harmonicity() {
                if (
                    this._getOscType(this._oscillator, 'fm') ||
                    this._getOscType(this._oscillator, 'am')
                )
                    return this._oscillator.harmonicity;
            }
            get modulationFrequency() {
                if (this._getOscType(this._oscillator, 'pwm'))
                    return this._oscillator.modulationFrequency;
            }
            asArray(t = 1024) {
                return et(this, void 0, void 0, function* () {
                    return ne(this, t);
                });
            }
            dispose() {
                return (
                    super.dispose(),
                    this.detune.dispose(),
                    this.frequency.dispose(),
                    this._oscillator.dispose(),
                    this
                );
            }
        };
    var _o = class extends z {
        constructor() {
            super(Object.assign(g(_o.getDefaults(), arguments, ['value'])));
            (this.override = !1),
                (this.name = 'Add'),
                (this._sum = new P({ context: this.context })),
                (this.input = this._sum),
                (this.output = this._sum),
                (this.addend = this._param),
                Qt(this._constantSource, this._sum);
        }
        static getDefaults() {
            return Object.assign(z.getDefaults(), { value: 0 });
        }
        dispose() {
            return super.dispose(), this._sum.dispose(), this;
        }
    };
    var Oe = class extends Bt {
        constructor() {
            super(Object.assign(g(Oe.getDefaults(), arguments, ['min', 'max'])));
            this.name = 'Scale';
            let t = g(Oe.getDefaults(), arguments, ['min', 'max']);
            (this._mult = this.input = new _t({ context: this.context, value: t.max - t.min })),
                (this._add = this.output = new _o({ context: this.context, value: t.min })),
                (this._min = t.min),
                (this._max = t.max),
                this.input.connect(this.output);
        }
        static getDefaults() {
            return Object.assign(Bt.getDefaults(), { max: 1, min: 0 });
        }
        get min() {
            return this._min;
        }
        set min(t) {
            (this._min = t), this._setRange();
        }
        get max() {
            return this._max;
        }
        set max(t) {
            (this._max = t), this._setRange();
        }
        _setRange() {
            (this._add.value = this._min), (this._mult.value = this._max - this._min);
        }
        dispose() {
            return super.dispose(), this._add.dispose(), this._mult.dispose(), this;
        }
    };
    var us = class extends Bt {
        constructor() {
            super(Object.assign(g(us.getDefaults(), arguments)));
            (this.name = 'Zero'),
                (this._gain = new P({ context: this.context })),
                (this.output = this._gain),
                (this.input = void 0),
                Et(this.context.getConstant(0), this._gain);
        }
        dispose() {
            return super.dispose(), ti(this.context.getConstant(0), this._gain), this;
        }
    };
    var ie = class extends S {
        constructor() {
            super(g(ie.getDefaults(), arguments, ['frequency', 'min', 'max']));
            (this.name = 'LFO'),
                (this._stoppedValue = 0),
                (this._units = 'number'),
                (this.convert = !0),
                (this._fromType = X.prototype._fromType),
                (this._toType = X.prototype._toType),
                (this._is = X.prototype._is),
                (this._clampValue = X.prototype._clampValue);
            let t = g(ie.getDefaults(), arguments, ['frequency', 'min', 'max']);
            (this._oscillator = new at(t)),
                (this.frequency = this._oscillator.frequency),
                (this._amplitudeGain = new P({
                    context: this.context,
                    gain: t.amplitude,
                    units: 'normalRange',
                })),
                (this.amplitude = this._amplitudeGain.gain),
                (this._stoppedSignal = new z({
                    context: this.context,
                    units: 'audioRange',
                    value: 0,
                })),
                (this._zeros = new us({ context: this.context })),
                (this._a2g = new vr({ context: this.context })),
                (this._scaler = this.output =
                    new Oe({ context: this.context, max: t.max, min: t.min })),
                (this.units = t.units),
                (this.min = t.min),
                (this.max = t.max),
                this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler),
                this._zeros.connect(this._a2g),
                this._stoppedSignal.connect(this._a2g),
                M(this, ['amplitude', 'frequency']),
                (this.phase = t.phase);
        }
        static getDefaults() {
            return Object.assign(at.getDefaults(), {
                amplitude: 1,
                frequency: '4n',
                max: 1,
                min: 0,
                type: 'sine',
                units: 'number',
            });
        }
        start(t) {
            return (
                (t = this.toSeconds(t)),
                this._stoppedSignal.setValueAtTime(0, t),
                this._oscillator.start(t),
                this
            );
        }
        stop(t) {
            return (
                (t = this.toSeconds(t)),
                this._stoppedSignal.setValueAtTime(this._stoppedValue, t),
                this._oscillator.stop(t),
                this
            );
        }
        sync() {
            return this._oscillator.sync(), this._oscillator.syncFrequency(), this;
        }
        unsync() {
            return this._oscillator.unsync(), this._oscillator.unsyncFrequency(), this;
        }
        _setStoppedValue() {
            (this._stoppedValue = this._oscillator.getInitialValue()),
                (this._stoppedSignal.value = this._stoppedValue);
        }
        get min() {
            return this._toType(this._scaler.min);
        }
        set min(t) {
            (t = this._fromType(t)), (this._scaler.min = t);
        }
        get max() {
            return this._toType(this._scaler.max);
        }
        set max(t) {
            (t = this._fromType(t)), (this._scaler.max = t);
        }
        get type() {
            return this._oscillator.type;
        }
        set type(t) {
            (this._oscillator.type = t), this._setStoppedValue();
        }
        get partials() {
            return this._oscillator.partials;
        }
        set partials(t) {
            (this._oscillator.partials = t), this._setStoppedValue();
        }
        get phase() {
            return this._oscillator.phase;
        }
        set phase(t) {
            (this._oscillator.phase = t), this._setStoppedValue();
        }
        get units() {
            return this._units;
        }
        set units(t) {
            let e = this.min,
                o = this.max;
            (this._units = t), (this.min = e), (this.max = o);
        }
        get state() {
            return this._oscillator.state;
        }
        connect(t, e, o) {
            return (
                (t instanceof X || t instanceof z) &&
                    ((this.convert = t.convert), (this.units = t.units)),
                Oo(this, t, e, o),
                this
            );
        }
        dispose() {
            return (
                super.dispose(),
                this._oscillator.dispose(),
                this._stoppedSignal.dispose(),
                this._zeros.dispose(),
                this._scaler.dispose(),
                this._a2g.dispose(),
                this._amplitudeGain.dispose(),
                this.amplitude.dispose(),
                this
            );
        }
    };
    function Qs(r, t = 1 / 0) {
        let e = new WeakMap();
        return function (o, s) {
            Reflect.defineProperty(o, s, {
                configurable: !0,
                enumerable: !0,
                get: function () {
                    return e.get(this);
                },
                set: function (n) {
                    qt(n, r, t), e.set(this, n);
                },
            });
        };
    }
    function ae(r, t = 1 / 0) {
        let e = new WeakMap();
        return function (o, s) {
            Reflect.defineProperty(o, s, {
                configurable: !0,
                enumerable: !0,
                get: function () {
                    return e.get(this);
                },
                set: function (n) {
                    qt(this.toSeconds(n), r, t), e.set(this, n);
                },
            });
        };
    }
    var Ro = class extends pt {
        constructor() {
            super(g(Ro.getDefaults(), arguments, ['url', 'onload']));
            (this.name = 'Player'), (this._activeSources = new Set());
            let t = g(Ro.getDefaults(), arguments, ['url', 'onload']);
            (this._buffer = new st({
                onload: this._onload.bind(this, t.onload),
                onerror: t.onerror,
                reverse: t.reverse,
                url: t.url,
            })),
                (this.autostart = t.autostart),
                (this._loop = t.loop),
                (this._loopStart = t.loopStart),
                (this._loopEnd = t.loopEnd),
                (this._playbackRate = t.playbackRate),
                (this.fadeIn = t.fadeIn),
                (this.fadeOut = t.fadeOut);
        }
        static getDefaults() {
            return Object.assign(pt.getDefaults(), {
                autostart: !1,
                fadeIn: 0,
                fadeOut: 0,
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                onload: $,
                onerror: $,
                playbackRate: 1,
                reverse: !1,
            });
        }
        load(t) {
            return et(this, void 0, void 0, function* () {
                return yield this._buffer.load(t), this._onload(), this;
            });
        }
        _onload(t = $) {
            t(), this.autostart && this.start();
        }
        _onSourceEnd(t) {
            this.onstop(this),
                this._activeSources.delete(t),
                this._activeSources.size === 0 &&
                    !this._synced &&
                    this._state.getValueAtTime(this.now()) === 'started' &&
                    (this._state.cancel(this.now()),
                    this._state.setStateAtTime('stopped', this.now()));
        }
        start(t, e, o) {
            return super.start(t, e, o), this;
        }
        _start(t, e, o) {
            this._loop ? (e = ce(e, this._loopStart)) : (e = ce(e, 0));
            let s = this.toSeconds(e),
                n = o;
            o = ce(o, Math.max(this._buffer.duration - s, 0));
            let i = this.toSeconds(o);
            (i = i / this._playbackRate), (t = this.toSeconds(t));
            let a = new Ne({
                url: this._buffer,
                context: this.context,
                fadeIn: this.fadeIn,
                fadeOut: this.fadeOut,
                loop: this._loop,
                loopEnd: this._loopEnd,
                loopStart: this._loopStart,
                onended: this._onSourceEnd.bind(this),
                playbackRate: this._playbackRate,
            }).connect(this.output);
            !this._loop &&
                !this._synced &&
                (this._state.cancel(t + i),
                this._state.setStateAtTime('stopped', t + i, { implicitEnd: !0 })),
                this._activeSources.add(a),
                this._loop && Dt(n)
                    ? a.start(t, s)
                    : a.start(t, s, i - this.toSeconds(this.fadeOut));
        }
        _stop(t) {
            let e = this.toSeconds(t);
            this._activeSources.forEach(o => o.stop(e));
        }
        restart(t, e, o) {
            return super.restart(t, e, o), this;
        }
        _restart(t, e, o) {
            this._stop(t), this._start(t, e, o);
        }
        seek(t, e) {
            let o = this.toSeconds(e);
            if (this._state.getValueAtTime(o) === 'started') {
                let s = this.toSeconds(t);
                this._stop(o), this._start(o, s);
            }
            return this;
        }
        setLoopPoints(t, e) {
            return (this.loopStart = t), (this.loopEnd = e), this;
        }
        get loopStart() {
            return this._loopStart;
        }
        set loopStart(t) {
            (this._loopStart = t),
                this.buffer.loaded && qt(this.toSeconds(t), 0, this.buffer.duration),
                this._activeSources.forEach(e => {
                    e.loopStart = t;
                });
        }
        get loopEnd() {
            return this._loopEnd;
        }
        set loopEnd(t) {
            (this._loopEnd = t),
                this.buffer.loaded && qt(this.toSeconds(t), 0, this.buffer.duration),
                this._activeSources.forEach(e => {
                    e.loopEnd = t;
                });
        }
        get buffer() {
            return this._buffer;
        }
        set buffer(t) {
            this._buffer.set(t);
        }
        get loop() {
            return this._loop;
        }
        set loop(t) {
            if (
                this._loop !== t &&
                ((this._loop = t),
                this._activeSources.forEach(e => {
                    e.loop = t;
                }),
                t)
            ) {
                let e = this._state.getNextState('stopped', this.now());
                e && this._state.cancel(e.time);
            }
        }
        get playbackRate() {
            return this._playbackRate;
        }
        set playbackRate(t) {
            this._playbackRate = t;
            let e = this.now(),
                o = this._state.getNextState('stopped', e);
            o &&
                o.implicitEnd &&
                (this._state.cancel(o.time), this._activeSources.forEach(s => s.cancelStop())),
                this._activeSources.forEach(s => {
                    s.playbackRate.setValueAtTime(t, e);
                });
        }
        get reverse() {
            return this._buffer.reverse;
        }
        set reverse(t) {
            this._buffer.reverse = t;
        }
        get loaded() {
            return this._buffer.loaded;
        }
        dispose() {
            return (
                super.dispose(),
                this._activeSources.forEach(t => t.dispose()),
                this._activeSources.clear(),
                this._buffer.dispose(),
                this
            );
        }
    };
    Ht([ae(0)], Ro.prototype, 'fadeIn', void 0);
    Ht([ae(0)], Ro.prototype, 'fadeOut', void 0);
    var ri = class extends Bt {
        constructor() {
            super(...arguments);
            (this.name = 'GainToAudio'),
                (this._norm = new zt({ context: this.context, mapping: t => Math.abs(t) * 2 - 1 })),
                (this.input = this._norm),
                (this.output = this._norm);
        }
        dispose() {
            return super.dispose(), this._norm.dispose(), this;
        }
    };
    var Pt = class extends S {
        constructor() {
            super(g(Pt.getDefaults(), arguments, ['attack', 'decay', 'sustain', 'release']));
            (this.name = 'Envelope'),
                (this._sig = new z({ context: this.context, value: 0 })),
                (this.output = this._sig),
                (this.input = void 0);
            let t = g(Pt.getDefaults(), arguments, ['attack', 'decay', 'sustain', 'release']);
            (this.attack = t.attack),
                (this.decay = t.decay),
                (this.sustain = t.sustain),
                (this.release = t.release),
                (this.attackCurve = t.attackCurve),
                (this.releaseCurve = t.releaseCurve),
                (this.decayCurve = t.decayCurve);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), {
                attack: 0.01,
                attackCurve: 'linear',
                decay: 0.1,
                decayCurve: 'exponential',
                release: 1,
                releaseCurve: 'exponential',
                sustain: 0.5,
            });
        }
        get value() {
            return this.getValueAtTime(this.now());
        }
        _getCurve(t, e) {
            if (Vt(t)) return t;
            {
                let o;
                for (o in Zs) if (Zs[o][e] === t) return o;
                return t;
            }
        }
        _setCurve(t, e, o) {
            if (Vt(o) && Reflect.has(Zs, o)) {
                let s = Zs[o];
                Te(s) ? t !== '_decayCurve' && (this[t] = s[e]) : (this[t] = s);
            } else if (kt(o) && t !== '_decayCurve') this[t] = o;
            else throw new Error('Envelope: invalid curve: ' + o);
        }
        get attackCurve() {
            return this._getCurve(this._attackCurve, 'In');
        }
        set attackCurve(t) {
            this._setCurve('_attackCurve', 'In', t);
        }
        get releaseCurve() {
            return this._getCurve(this._releaseCurve, 'Out');
        }
        set releaseCurve(t) {
            this._setCurve('_releaseCurve', 'Out', t);
        }
        get decayCurve() {
            return this._decayCurve;
        }
        set decayCurve(t) {
            j(
                ['linear', 'exponential'].some(e => e === t),
                `Invalid envelope curve: ${t}`
            ),
                (this._decayCurve = t);
        }
        triggerAttack(t, e = 1) {
            this.log('triggerAttack', t, e), (t = this.toSeconds(t));
            let s = this.toSeconds(this.attack),
                n = this.toSeconds(this.decay),
                i = this.getValueAtTime(t);
            if (i > 0) {
                let a = 1 / s;
                s = (1 - i) / a;
            }
            if (s < this.sampleTime)
                this._sig.cancelScheduledValues(t), this._sig.setValueAtTime(e, t);
            else if (this._attackCurve === 'linear') this._sig.linearRampTo(e, s, t);
            else if (this._attackCurve === 'exponential') this._sig.targetRampTo(e, s, t);
            else {
                this._sig.cancelAndHoldAtTime(t);
                let a = this._attackCurve;
                for (let c = 1; c < a.length; c++)
                    if (a[c - 1] <= i && i <= a[c]) {
                        (a = this._attackCurve.slice(c)), (a[0] = i);
                        break;
                    }
                this._sig.setValueCurveAtTime(a, t, s, e);
            }
            if (n && this.sustain < 1) {
                let a = e * this.sustain,
                    c = t + s;
                this.log('decay', c),
                    this._decayCurve === 'linear'
                        ? this._sig.linearRampToValueAtTime(a, n + c)
                        : this._sig.exponentialApproachValueAtTime(a, c, n);
            }
            return this;
        }
        triggerRelease(t) {
            this.log('triggerRelease', t), (t = this.toSeconds(t));
            let e = this.getValueAtTime(t);
            if (e > 0) {
                let o = this.toSeconds(this.release);
                o < this.sampleTime
                    ? this._sig.setValueAtTime(0, t)
                    : this._releaseCurve === 'linear'
                    ? this._sig.linearRampTo(0, o, t)
                    : this._releaseCurve === 'exponential'
                    ? this._sig.targetRampTo(0, o, t)
                    : (j(
                          kt(this._releaseCurve),
                          "releaseCurve must be either 'linear', 'exponential' or an array"
                      ),
                      this._sig.cancelAndHoldAtTime(t),
                      this._sig.setValueCurveAtTime(this._releaseCurve, t, o, e));
            }
            return this;
        }
        getValueAtTime(t) {
            return this._sig.getValueAtTime(t);
        }
        triggerAttackRelease(t, e, o = 1) {
            return (
                (e = this.toSeconds(e)),
                this.triggerAttack(e, o),
                this.triggerRelease(e + this.toSeconds(t)),
                this
            );
        }
        cancel(t) {
            return this._sig.cancelScheduledValues(this.toSeconds(t)), this;
        }
        connect(t, e = 0, o = 0) {
            return Oo(this, t, e, o), this;
        }
        asArray(t = 1024) {
            return et(this, void 0, void 0, function* () {
                let e = t / this.context.sampleRate,
                    o = new Ze(1, e, this.context.sampleRate),
                    s = this.toSeconds(this.attack) + this.toSeconds(this.decay),
                    n = s + this.toSeconds(this.release),
                    i = n * 0.1,
                    a = n + i,
                    c = new this.constructor(
                        Object.assign(this.get(), {
                            attack: (e * this.toSeconds(this.attack)) / a,
                            decay: (e * this.toSeconds(this.decay)) / a,
                            release: (e * this.toSeconds(this.release)) / a,
                            context: o,
                        })
                    );
                return (
                    c._sig.toDestination(),
                    c.triggerAttackRelease((e * (s + i)) / a, 0),
                    (yield o.render()).getChannelData(0)
                );
            });
        }
        dispose() {
            return super.dispose(), this._sig.dispose(), this;
        }
    };
    Ht([ae(0)], Pt.prototype, 'attack', void 0);
    Ht([ae(0)], Pt.prototype, 'decay', void 0);
    Ht([Qs(0, 1)], Pt.prototype, 'sustain', void 0);
    Ht([ae(0)], Pt.prototype, 'release', void 0);
    var Zs = (() => {
        let r = 128,
            t,
            e,
            o = [];
        for (t = 0; t < r; t++) o[t] = Math.sin((t / (r - 1)) * (Math.PI / 2));
        let s = [],
            n = 6.4;
        for (t = 0; t < r - 1; t++) {
            e = t / (r - 1);
            let p = Math.sin(e * (Math.PI * 2) * n - Math.PI / 2) + 1;
            s[t] = p / 10 + e * 0.83;
        }
        s[r - 1] = 1;
        let i = [],
            a = 5;
        for (t = 0; t < r; t++) i[t] = Math.ceil((t / (r - 1)) * a) / a;
        let c = [];
        for (t = 0; t < r; t++) (e = t / (r - 1)), (c[t] = 0.5 * (1 - Math.cos(Math.PI * e)));
        let u = [];
        for (t = 0; t < r; t++) {
            e = t / (r - 1);
            let p = Math.pow(e, 3) * 4 + 0.2,
                d = Math.cos(p * Math.PI * 2 * e);
            u[t] = Math.abs(d * (1 - e));
        }
        function l(p) {
            let d = new Array(p.length);
            for (let f = 0; f < p.length; f++) d[f] = 1 - p[f];
            return d;
        }
        function h(p) {
            return p.slice(0).reverse();
        }
        return {
            bounce: { In: l(u), Out: u },
            cosine: { In: o, Out: h(o) },
            exponential: 'exponential',
            linear: 'linear',
            ripple: { In: s, Out: l(s) },
            sine: { In: c, Out: l(c) },
            step: { In: i, Out: l(i) },
        };
    })();
    var ue = class extends S {
        constructor() {
            super(g(ue.getDefaults(), arguments));
            (this._scheduledEvents = []),
                (this._synced = !1),
                (this._original_triggerAttack = this.triggerAttack),
                (this._original_triggerRelease = this.triggerRelease);
            let t = g(ue.getDefaults(), arguments);
            (this._volume = this.output = new se({ context: this.context, volume: t.volume })),
                (this.volume = this._volume.volume),
                M(this, 'volume');
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { volume: 0 });
        }
        sync() {
            return (
                this._syncState() &&
                    (this._syncMethod('triggerAttack', 1), this._syncMethod('triggerRelease', 0)),
                this
            );
        }
        _syncState() {
            let t = !1;
            return this._synced || ((this._synced = !0), (t = !0)), t;
        }
        _syncMethod(t, e) {
            let o = (this['_original_' + t] = this[t]);
            this[t] = (...s) => {
                let n = s[e],
                    i = this.context.transport.schedule(a => {
                        (s[e] = a), o.apply(this, s);
                    }, n);
                this._scheduledEvents.push(i);
            };
        }
        unsync() {
            return (
                this._scheduledEvents.forEach(t => this.context.transport.clear(t)),
                (this._scheduledEvents = []),
                this._synced &&
                    ((this._synced = !1),
                    (this.triggerAttack = this._original_triggerAttack),
                    (this.triggerRelease = this._original_triggerRelease)),
                this
            );
        }
        triggerAttackRelease(t, e, o, s) {
            let n = this.toSeconds(o),
                i = this.toSeconds(e);
            return this.triggerAttack(t, n, s), this.triggerRelease(n + i), this;
        }
        dispose() {
            return (
                super.dispose(),
                this._volume.dispose(),
                this.unsync(),
                (this._scheduledEvents = []),
                this
            );
        }
    };
    var Zt = class extends ue {
        constructor() {
            super(g(Zt.getDefaults(), arguments));
            let t = g(Zt.getDefaults(), arguments);
            (this.portamento = t.portamento), (this.onsilence = t.onsilence);
        }
        static getDefaults() {
            return Object.assign(ue.getDefaults(), { detune: 0, onsilence: $, portamento: 0 });
        }
        triggerAttack(t, e, o = 1) {
            this.log('triggerAttack', t, e, o);
            let s = this.toSeconds(e);
            return this._triggerEnvelopeAttack(s, o), this.setNote(t, s), this;
        }
        triggerRelease(t) {
            this.log('triggerRelease', t);
            let e = this.toSeconds(t);
            return this._triggerEnvelopeRelease(e), this;
        }
        setNote(t, e) {
            let o = this.toSeconds(e),
                s = t instanceof Wt ? t.toFrequency() : t;
            if (this.portamento > 0 && this.getLevelAtTime(o) > 0.05) {
                let n = this.toSeconds(this.portamento);
                this.frequency.exponentialRampTo(s, n, o);
            } else this.frequency.setValueAtTime(s, o);
            return this;
        }
    };
    Ht([ae(0)], Zt.prototype, 'portamento', void 0);
    var Po = class extends Pt {
        constructor() {
            super(g(Po.getDefaults(), arguments, ['attack', 'decay', 'sustain', 'release']));
            (this.name = 'AmplitudeEnvelope'),
                (this._gainNode = new P({ context: this.context, gain: 0 })),
                (this.output = this._gainNode),
                (this.input = this._gainNode),
                this._sig.connect(this._gainNode.gain),
                (this.output = this._gainNode),
                (this.input = this._gainNode);
        }
        dispose() {
            return super.dispose(), this._gainNode.dispose(), this;
        }
    };
    var ge = class extends Zt {
        constructor() {
            super(g(ge.getDefaults(), arguments));
            this.name = 'Synth';
            let t = g(ge.getDefaults(), arguments);
            (this.oscillator = new to(
                Object.assign(
                    { context: this.context, detune: t.detune, onstop: () => this.onsilence(this) },
                    t.oscillator
                )
            )),
                (this.frequency = this.oscillator.frequency),
                (this.detune = this.oscillator.detune),
                (this.envelope = new Po(Object.assign({ context: this.context }, t.envelope))),
                this.oscillator.chain(this.envelope, this.output),
                M(this, ['oscillator', 'frequency', 'detune', 'envelope']);
        }
        static getDefaults() {
            return Object.assign(Zt.getDefaults(), {
                envelope: Object.assign(Se(Pt.getDefaults(), Object.keys(S.getDefaults())), {
                    attack: 0.005,
                    decay: 0.1,
                    release: 1,
                    sustain: 0.3,
                }),
                oscillator: Object.assign(
                    Se(to.getDefaults(), [...Object.keys(pt.getDefaults()), 'frequency', 'detune']),
                    { type: 'triangle' }
                ),
            });
        }
        _triggerEnvelopeAttack(t, e) {
            if (
                (this.envelope.triggerAttack(t, e),
                this.oscillator.start(t),
                this.envelope.sustain === 0)
            ) {
                let o = this.toSeconds(this.envelope.attack),
                    s = this.toSeconds(this.envelope.decay);
                this.oscillator.stop(t + o + s);
            }
        }
        _triggerEnvelopeRelease(t) {
            this.envelope.triggerRelease(t),
                this.oscillator.stop(t + this.toSeconds(this.envelope.release));
        }
        getLevelAtTime(t) {
            return (t = this.toSeconds(t)), this.envelope.getValueAtTime(t);
        }
        dispose() {
            return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this;
        }
    };
    var qo = class extends S {
        constructor() {
            super(g(qo.getDefaults(), arguments, ['frequency', 'type']));
            this.name = 'BiquadFilter';
            let t = g(qo.getDefaults(), arguments, ['frequency', 'type']);
            (this._filter = this.context.createBiquadFilter()),
                (this.input = this.output = this._filter),
                (this.Q = new X({
                    context: this.context,
                    units: 'number',
                    value: t.Q,
                    param: this._filter.Q,
                })),
                (this.frequency = new X({
                    context: this.context,
                    units: 'frequency',
                    value: t.frequency,
                    param: this._filter.frequency,
                })),
                (this.detune = new X({
                    context: this.context,
                    units: 'cents',
                    value: t.detune,
                    param: this._filter.detune,
                })),
                (this.gain = new X({
                    context: this.context,
                    units: 'decibels',
                    convert: !1,
                    value: t.gain,
                    param: this._filter.gain,
                })),
                (this.type = t.type);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), {
                Q: 1,
                type: 'lowpass',
                frequency: 350,
                detune: 0,
                gain: 0,
            });
        }
        get type() {
            return this._filter.type;
        }
        set type(t) {
            j(
                [
                    'lowpass',
                    'highpass',
                    'bandpass',
                    'lowshelf',
                    'highshelf',
                    'notch',
                    'allpass',
                    'peaking',
                ].indexOf(t) !== -1,
                `Invalid filter type: ${t}`
            ),
                (this._filter.type = t);
        }
        getFrequencyResponse(t = 128) {
            let e = new Float32Array(t);
            for (let i = 0; i < t; i++) {
                let c = Math.pow(i / t, 2) * (2e4 - 20) + 20;
                e[i] = c;
            }
            let o = new Float32Array(t),
                s = new Float32Array(t),
                n = this.context.createBiquadFilter();
            return (
                (n.type = this.type),
                (n.Q.value = this.Q.value),
                (n.frequency.value = this.frequency.value),
                (n.gain.value = this.gain.value),
                n.getFrequencyResponse(e, o, s),
                o
            );
        }
        dispose() {
            return (
                super.dispose(),
                this._filter.disconnect(),
                this.Q.dispose(),
                this.frequency.dispose(),
                this.gain.dispose(),
                this.detune.dispose(),
                this
            );
        }
    };
    var Ge = class extends S {
        constructor() {
            super(g(Ge.getDefaults(), arguments, ['frequency', 'type', 'rolloff']));
            (this.name = 'Filter'),
                (this.input = new P({ context: this.context })),
                (this.output = new P({ context: this.context })),
                (this._filters = []);
            let t = g(Ge.getDefaults(), arguments, ['frequency', 'type', 'rolloff']);
            (this._filters = []),
                (this.Q = new z({ context: this.context, units: 'positive', value: t.Q })),
                (this.frequency = new z({
                    context: this.context,
                    units: 'frequency',
                    value: t.frequency,
                })),
                (this.detune = new z({ context: this.context, units: 'cents', value: t.detune })),
                (this.gain = new z({
                    context: this.context,
                    units: 'decibels',
                    convert: !1,
                    value: t.gain,
                })),
                (this._type = t.type),
                (this.rolloff = t.rolloff),
                M(this, ['detune', 'frequency', 'gain', 'Q']);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), {
                Q: 1,
                detune: 0,
                frequency: 350,
                gain: 0,
                rolloff: -12,
                type: 'lowpass',
            });
        }
        get type() {
            return this._type;
        }
        set type(t) {
            j(
                [
                    'lowpass',
                    'highpass',
                    'bandpass',
                    'lowshelf',
                    'highshelf',
                    'notch',
                    'allpass',
                    'peaking',
                ].indexOf(t) !== -1,
                `Invalid filter type: ${t}`
            ),
                (this._type = t),
                this._filters.forEach(o => (o.type = t));
        }
        get rolloff() {
            return this._rolloff;
        }
        set rolloff(t) {
            let e = Yt(t) ? t : parseInt(t, 10),
                o = [-12, -24, -48, -96],
                s = o.indexOf(e);
            j(s !== -1, `rolloff can only be ${o.join(', ')}`),
                (s += 1),
                (this._rolloff = e),
                this.input.disconnect(),
                this._filters.forEach(n => n.disconnect()),
                (this._filters = new Array(s));
            for (let n = 0; n < s; n++) {
                let i = new qo({ context: this.context });
                (i.type = this._type),
                    this.frequency.connect(i.frequency),
                    this.detune.connect(i.detune),
                    this.Q.connect(i.Q),
                    this.gain.connect(i.gain),
                    (this._filters[n] = i);
            }
            (this._internalChannels = this._filters),
                Qt(this.input, ...this._internalChannels, this.output);
        }
        getFrequencyResponse(t = 128) {
            let e = new qo({
                    frequency: this.frequency.value,
                    gain: this.gain.value,
                    Q: this.Q.value,
                    type: this._type,
                    detune: this.detune.value,
                }),
                o = new Float32Array(t).map(() => 1);
            return (
                this._filters.forEach(() => {
                    e.getFrequencyResponse(t).forEach((n, i) => (o[i] *= n));
                }),
                e.dispose(),
                o
            );
        }
        dispose() {
            return (
                super.dispose(),
                this._filters.forEach(t => {
                    t.dispose();
                }),
                So(this, ['detune', 'frequency', 'gain', 'Q']),
                this.frequency.dispose(),
                this.Q.dispose(),
                this.detune.dispose(),
                this.gain.dispose(),
                this
            );
        }
    };
    var fh = [1, 1.483, 1.932, 2.546, 2.63, 3.897],
        Vo = class extends Zt {
            constructor() {
                super(g(Vo.getDefaults(), arguments));
                (this.name = 'MetalSynth'), (this._oscillators = []), (this._freqMultipliers = []);
                let t = g(Vo.getDefaults(), arguments);
                (this.detune = new z({ context: this.context, units: 'cents', value: t.detune })),
                    (this.frequency = new z({ context: this.context, units: 'frequency' })),
                    (this._amplitude = new P({ context: this.context, gain: 0 }).connect(
                        this.output
                    )),
                    (this._highpass = new Ge({
                        Q: 0,
                        context: this.context,
                        type: 'highpass',
                    }).connect(this._amplitude));
                for (let e = 0; e < fh.length; e++) {
                    let o = new Ke({
                        context: this.context,
                        harmonicity: t.harmonicity,
                        modulationIndex: t.modulationIndex,
                        modulationType: 'square',
                        onstop: e === 0 ? () => this.onsilence(this) : $,
                        type: 'square',
                    });
                    o.connect(this._highpass), (this._oscillators[e] = o);
                    let s = new _t({ context: this.context, value: fh[e] });
                    (this._freqMultipliers[e] = s),
                        this.frequency.chain(s, o.frequency),
                        this.detune.connect(o.detune);
                }
                (this._filterFreqScaler = new Oe({
                    context: this.context,
                    max: 7e3,
                    min: this.toFrequency(t.resonance),
                })),
                    (this.envelope = new Pt({
                        attack: t.envelope.attack,
                        attackCurve: 'linear',
                        context: this.context,
                        decay: t.envelope.decay,
                        release: t.envelope.release,
                        sustain: 0,
                    })),
                    this.envelope.chain(this._filterFreqScaler, this._highpass.frequency),
                    this.envelope.connect(this._amplitude.gain),
                    (this._octaves = t.octaves),
                    (this.octaves = t.octaves);
            }
            static getDefaults() {
                return me(Zt.getDefaults(), {
                    envelope: Object.assign(Se(Pt.getDefaults(), Object.keys(S.getDefaults())), {
                        attack: 0.001,
                        decay: 1.4,
                        release: 0.2,
                    }),
                    harmonicity: 5.1,
                    modulationIndex: 32,
                    octaves: 1.5,
                    resonance: 4e3,
                });
            }
            _triggerEnvelopeAttack(t, e = 1) {
                return (
                    this.envelope.triggerAttack(t, e),
                    this._oscillators.forEach(o => o.start(t)),
                    this.envelope.sustain === 0 &&
                        this._oscillators.forEach(o => {
                            o.stop(
                                t +
                                    this.toSeconds(this.envelope.attack) +
                                    this.toSeconds(this.envelope.decay)
                            );
                        }),
                    this
                );
            }
            _triggerEnvelopeRelease(t) {
                return (
                    this.envelope.triggerRelease(t),
                    this._oscillators.forEach(e =>
                        e.stop(t + this.toSeconds(this.envelope.release))
                    ),
                    this
                );
            }
            getLevelAtTime(t) {
                return (t = this.toSeconds(t)), this.envelope.getValueAtTime(t);
            }
            get modulationIndex() {
                return this._oscillators[0].modulationIndex.value;
            }
            set modulationIndex(t) {
                this._oscillators.forEach(e => (e.modulationIndex.value = t));
            }
            get harmonicity() {
                return this._oscillators[0].harmonicity.value;
            }
            set harmonicity(t) {
                this._oscillators.forEach(e => (e.harmonicity.value = t));
            }
            get resonance() {
                return this._filterFreqScaler.min;
            }
            set resonance(t) {
                (this._filterFreqScaler.min = this.toFrequency(t)), (this.octaves = this._octaves);
            }
            get octaves() {
                return this._octaves;
            }
            set octaves(t) {
                (this._octaves = t),
                    (this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, t));
            }
            dispose() {
                return (
                    super.dispose(),
                    this._oscillators.forEach(t => t.dispose()),
                    this._freqMultipliers.forEach(t => t.dispose()),
                    this.frequency.dispose(),
                    this.detune.dispose(),
                    this._filterFreqScaler.dispose(),
                    this._amplitude.dispose(),
                    this.envelope.dispose(),
                    this._highpass.dispose(),
                    this
                );
            }
        };
    var eo = class extends ge {
        constructor() {
            super(g(eo.getDefaults(), arguments));
            (this.name = 'MembraneSynth'), (this.portamento = 0);
            let t = g(eo.getDefaults(), arguments);
            (this.pitchDecay = t.pitchDecay),
                (this.octaves = t.octaves),
                M(this, ['oscillator', 'envelope']);
        }
        static getDefaults() {
            return me(Zt.getDefaults(), ge.getDefaults(), {
                envelope: {
                    attack: 0.001,
                    attackCurve: 'exponential',
                    decay: 0.4,
                    release: 1.4,
                    sustain: 0.01,
                },
                octaves: 10,
                oscillator: { type: 'sine' },
                pitchDecay: 0.05,
            });
        }
        setNote(t, e) {
            let o = this.toSeconds(e),
                s = this.toFrequency(t instanceof Wt ? t.toFrequency() : t),
                n = s * this.octaves;
            return (
                this.oscillator.frequency.setValueAtTime(n, o),
                this.oscillator.frequency.exponentialRampToValueAtTime(
                    s,
                    o + this.toSeconds(this.pitchDecay)
                ),
                this
            );
        }
        dispose() {
            return super.dispose(), this;
        }
    };
    Ht([Qs(0)], eo.prototype, 'octaves', void 0);
    Ht([ae(0)], eo.prototype, 'pitchDecay', void 0);
    var ni = new Set();
    function wr(r) {
        ni.add(r);
    }
    function $s(r, t) {
        let e = `registerProcessor("${r}", ${t})`;
        ni.add(e);
    }
    function gh() {
        return Array.from(ni).join(`
`);
    }
    var Ks = class extends S {
        constructor(t) {
            super(t);
            (this.name = 'ToneAudioWorklet'),
                (this.workletOptions = {}),
                (this.onprocessorerror = $);
            let e = URL.createObjectURL(new Blob([gh()], { type: 'text/javascript' })),
                o = this._audioWorkletName();
            (this._dummyGain = this.context.createGain()),
                (this._dummyParam = this._dummyGain.gain),
                this.context.addAudioWorkletModule(e, o).then(() => {
                    this.disposed ||
                        ((this._worklet = this.context.createAudioWorkletNode(
                            o,
                            this.workletOptions
                        )),
                        (this._worklet.onprocessorerror = this.onprocessorerror.bind(this)),
                        this.onReady(this._worklet));
                });
        }
        dispose() {
            return (
                super.dispose(),
                this._dummyGain.disconnect(),
                this._worklet &&
                    (this._worklet.port.postMessage('dispose'), this._worklet.disconnect()),
                this
            );
        }
    };
    var Jd = `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
    wr(Jd);
    var tf = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
    wr(tf);
    var ef = `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
    wr(ef);
    var ii = 'feedback-comb-filter',
        of = `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;
    $s(ii, of);
    var Lo = class extends Ks {
        constructor() {
            super(g(Lo.getDefaults(), arguments, ['delayTime', 'resonance']));
            this.name = 'FeedbackCombFilter';
            let t = g(Lo.getDefaults(), arguments, ['delayTime', 'resonance']);
            (this.input = new P({ context: this.context })),
                (this.output = new P({ context: this.context })),
                (this.delayTime = new X({
                    context: this.context,
                    value: t.delayTime,
                    units: 'time',
                    minValue: 0,
                    maxValue: 1,
                    param: this._dummyParam,
                    swappable: !0,
                })),
                (this.resonance = new X({
                    context: this.context,
                    value: t.resonance,
                    units: 'normalRange',
                    param: this._dummyParam,
                    swappable: !0,
                })),
                M(this, ['resonance', 'delayTime']);
        }
        _audioWorkletName() {
            return ii;
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { delayTime: 0.1, resonance: 0.5 });
        }
        onReady(t) {
            Qt(this.input, t, this.output);
            let e = t.parameters.get('delayTime');
            this.delayTime.setParam(e);
            let o = t.parameters.get('feedback');
            this.resonance.setParam(o);
        }
        dispose() {
            return (
                super.dispose(),
                this.input.dispose(),
                this.output.dispose(),
                this.delayTime.dispose(),
                this.resonance.dispose(),
                this
            );
        }
    };
    var Wo = class extends S {
        constructor() {
            super(g(Wo.getDefaults(), arguments, ['frequency', 'type']));
            this.name = 'OnePoleFilter';
            let t = g(Wo.getDefaults(), arguments, ['frequency', 'type']);
            (this._frequency = t.frequency),
                (this._type = t.type),
                (this.input = new P({ context: this.context })),
                (this.output = new P({ context: this.context })),
                this._createFilter();
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { frequency: 880, type: 'lowpass' });
        }
        _createFilter() {
            let t = this._filter,
                e = this.toFrequency(this._frequency),
                o = 1 / (2 * Math.PI * e);
            if (this._type === 'lowpass') {
                let s = 1 / (o * this.context.sampleRate),
                    n = s - 1;
                this._filter = this.context.createIIRFilter([s, 0], [1, n]);
            } else {
                let s = 1 / (o * this.context.sampleRate) - 1;
                this._filter = this.context.createIIRFilter([1, -1], [1, s]);
            }
            this.input.chain(this._filter, this.output),
                t &&
                    this.context.setTimeout(() => {
                        this.disposed || (this.input.disconnect(t), t.disconnect());
                    }, this.blockTime);
        }
        get frequency() {
            return this._frequency;
        }
        set frequency(t) {
            (this._frequency = t), this._createFilter();
        }
        get type() {
            return this._type;
        }
        set type(t) {
            (this._type = t), this._createFilter();
        }
        getFrequencyResponse(t = 128) {
            let e = new Float32Array(t);
            for (let n = 0; n < t; n++) {
                let a = Math.pow(n / t, 2) * (2e4 - 20) + 20;
                e[n] = a;
            }
            let o = new Float32Array(t),
                s = new Float32Array(t);
            return this._filter.getFrequencyResponse(e, o, s), o;
        }
        dispose() {
            return (
                super.dispose(),
                this.input.dispose(),
                this.output.dispose(),
                this._filter.disconnect(),
                this
            );
        }
    };
    var Bo = class extends S {
        constructor() {
            super(g(Bo.getDefaults(), arguments, ['delayTime', 'resonance', 'dampening']));
            this.name = 'LowpassCombFilter';
            let t = g(Bo.getDefaults(), arguments, ['delayTime', 'resonance', 'dampening']);
            (this._combFilter = this.output =
                new Lo({ context: this.context, delayTime: t.delayTime, resonance: t.resonance })),
                (this.delayTime = this._combFilter.delayTime),
                (this.resonance = this._combFilter.resonance),
                (this._lowpass = this.input =
                    new Wo({ context: this.context, frequency: t.dampening, type: 'lowpass' })),
                this._lowpass.connect(this._combFilter);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), {
                dampening: 3e3,
                delayTime: 0.1,
                resonance: 0.5,
            });
        }
        get dampening() {
            return this._lowpass.frequency;
        }
        set dampening(t) {
            this._lowpass.frequency = t;
        }
        dispose() {
            return super.dispose(), this._combFilter.dispose(), this._lowpass.dispose(), this;
        }
    };
    var br = class extends ue {
        constructor() {
            super(g(br.getDefaults(), arguments, ['urls', 'onload', 'baseUrl'], 'urls'));
            (this.name = 'Sampler'), (this._activeSources = new Map());
            let t = g(br.getDefaults(), arguments, ['urls', 'onload', 'baseUrl'], 'urls'),
                e = {};
            Object.keys(t.urls).forEach(o => {
                let s = parseInt(o, 10);
                if (
                    (j(
                        es(o) || (Yt(s) && isFinite(s)),
                        `url key is neither a note or midi pitch: ${o}`
                    ),
                    es(o))
                ) {
                    let n = new Wt(this.context, o).toMidi();
                    e[n] = t.urls[o];
                } else Yt(s) && isFinite(s) && (e[s] = t.urls[s]);
            }),
                (this._buffers = new Do({
                    urls: e,
                    onload: t.onload,
                    baseUrl: t.baseUrl,
                    onerror: t.onerror,
                })),
                (this.attack = t.attack),
                (this.release = t.release),
                (this.curve = t.curve),
                this._buffers.loaded && Promise.resolve().then(t.onload);
        }
        static getDefaults() {
            return Object.assign(ue.getDefaults(), {
                attack: 0,
                baseUrl: '',
                curve: 'exponential',
                onload: $,
                onerror: $,
                release: 0.1,
                urls: {},
            });
        }
        _findClosest(t) {
            let e = 96,
                o = 0;
            for (; o < e; ) {
                if (this._buffers.has(t + o)) return -o;
                if (this._buffers.has(t - o)) return o;
                o++;
            }
            throw new Error(`No available buffers for note: ${t}`);
        }
        triggerAttack(t, e, o = 1) {
            return (
                this.log('triggerAttack', t, e, o),
                Array.isArray(t) || (t = [t]),
                t.forEach(s => {
                    let n = Jn(new Wt(this.context, s).toFrequency()),
                        i = Math.round(n),
                        a = n - i,
                        c = this._findClosest(i),
                        u = i - c,
                        l = this._buffers.get(u),
                        h = Co(c + a),
                        p = new Ne({
                            url: l,
                            context: this.context,
                            curve: this.curve,
                            fadeIn: this.attack,
                            fadeOut: this.release,
                            playbackRate: h,
                        }).connect(this.output);
                    p.start(e, 0, l.duration / h, o),
                        kt(this._activeSources.get(i)) || this._activeSources.set(i, []),
                        this._activeSources.get(i).push(p),
                        (p.onended = () => {
                            if (this._activeSources && this._activeSources.has(i)) {
                                let d = this._activeSources.get(i),
                                    f = d.indexOf(p);
                                f !== -1 && d.splice(f, 1);
                            }
                        });
                }),
                this
            );
        }
        triggerRelease(t, e) {
            return (
                this.log('triggerRelease', t, e),
                Array.isArray(t) || (t = [t]),
                t.forEach(o => {
                    let s = new Wt(this.context, o).toMidi();
                    if (this._activeSources.has(s) && this._activeSources.get(s).length) {
                        let n = this._activeSources.get(s);
                        (e = this.toSeconds(e)),
                            n.forEach(i => {
                                i.stop(e);
                            }),
                            this._activeSources.set(s, []);
                    }
                }),
                this
            );
        }
        releaseAll(t) {
            let e = this.toSeconds(t);
            return (
                this._activeSources.forEach(o => {
                    for (; o.length; ) o.shift().stop(e);
                }),
                this
            );
        }
        sync() {
            return (
                this._syncState() &&
                    (this._syncMethod('triggerAttack', 1), this._syncMethod('triggerRelease', 1)),
                this
            );
        }
        triggerAttackRelease(t, e, o, s = 1) {
            let n = this.toSeconds(o);
            return (
                this.triggerAttack(t, n, s),
                kt(e)
                    ? (j(kt(t), 'notes must be an array when duration is array'),
                      t.forEach((i, a) => {
                          let c = e[Math.min(a, e.length - 1)];
                          this.triggerRelease(i, n + this.toSeconds(c));
                      }))
                    : this.triggerRelease(t, n + this.toSeconds(e)),
                this
            );
        }
        add(t, e, o) {
            if ((j(es(t) || isFinite(t), `note must be a pitch or midi: ${t}`), es(t))) {
                let s = new Wt(this.context, t).toMidi();
                this._buffers.add(s, e, o);
            } else this._buffers.add(t, e, o);
            return this;
        }
        get loaded() {
            return this._buffers.loaded;
        }
        dispose() {
            return (
                super.dispose(),
                this._buffers.dispose(),
                this._activeSources.forEach(t => {
                    t.forEach(e => e.dispose());
                }),
                this._activeSources.clear(),
                this
            );
        }
    };
    Ht([ae(0)], br.prototype, 'attack', void 0);
    Ht([ae(0)], br.prototype, 'release', void 0);
    var oo = class extends S {
        constructor() {
            super(Object.assign(g(oo.getDefaults(), arguments, ['fade'])));
            (this.name = 'CrossFade'),
                (this._panner = this.context.createStereoPanner()),
                (this._split = this.context.createChannelSplitter(2)),
                (this._g2a = new ri({ context: this.context })),
                (this.a = new P({ context: this.context, gain: 0 })),
                (this.b = new P({ context: this.context, gain: 0 })),
                (this.output = new P({ context: this.context })),
                (this._internalChannels = [this.a, this.b]);
            let t = g(oo.getDefaults(), arguments, ['fade']);
            (this.fade = new z({ context: this.context, units: 'normalRange', value: t.fade })),
                M(this, 'fade'),
                this.context.getConstant(1).connect(this._panner),
                this._panner.connect(this._split),
                (this._panner.channelCount = 1),
                (this._panner.channelCountMode = 'explicit'),
                Et(this._split, this.a.gain, 0),
                Et(this._split, this.b.gain, 1),
                this.fade.chain(this._g2a, this._panner.pan),
                this.a.connect(this.output),
                this.b.connect(this.output);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { fade: 0.5 });
        }
        dispose() {
            return (
                super.dispose(),
                this.a.dispose(),
                this.b.dispose(),
                this.output.dispose(),
                this.fade.dispose(),
                this._g2a.dispose(),
                this._panner.disconnect(),
                this._split.disconnect(),
                this
            );
        }
    };
    var Ut = class extends S {
        constructor(t) {
            super(t);
            (this.name = 'Effect'),
                (this._dryWet = new oo({ context: this.context })),
                (this.wet = this._dryWet.fade),
                (this.effectSend = new P({ context: this.context })),
                (this.effectReturn = new P({ context: this.context })),
                (this.input = new P({ context: this.context })),
                (this.output = this._dryWet),
                this.input.fan(this._dryWet.a, this.effectSend),
                this.effectReturn.connect(this._dryWet.b),
                this.wet.setValueAtTime(t.wet, 0),
                (this._internalChannels = [this.effectReturn, this.effectSend]),
                M(this, 'wet');
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { wet: 1 });
        }
        connectEffect(t) {
            return (
                this._internalChannels.push(t), this.effectSend.chain(t, this.effectReturn), this
            );
        }
        dispose() {
            return (
                super.dispose(),
                this._dryWet.dispose(),
                this.effectSend.dispose(),
                this.effectReturn.dispose(),
                this.wet.dispose(),
                this
            );
        }
    };
    var jo = class extends S {
        constructor() {
            super(Object.assign(g(jo.getDefaults(), arguments, ['pan'])));
            (this.name = 'Panner'),
                (this._panner = this.context.createStereoPanner()),
                (this.input = this._panner),
                (this.output = this._panner);
            let t = g(jo.getDefaults(), arguments, ['pan']);
            (this.pan = new X({
                context: this.context,
                param: this._panner.pan,
                value: t.pan,
                minValue: -1,
                maxValue: 1,
            })),
                (this._panner.channelCount = t.channelCount),
                (this._panner.channelCountMode = 'explicit'),
                M(this, 'pan');
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { pan: 0, channelCount: 1 });
        }
        dispose() {
            return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this;
        }
    };
    var xh = 'bit-crusher',
        nf = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
    $s(xh, nf);
    var Tr = class extends Ut {
        constructor() {
            super(g(Tr.getDefaults(), arguments, ['order']));
            this.name = 'Chebyshev';
            let t = g(Tr.getDefaults(), arguments, ['order']);
            (this._shaper = new zt({ context: this.context, length: 4096 })),
                (this._order = t.order),
                this.connectEffect(this._shaper),
                (this.order = t.order),
                (this.oversample = t.oversample);
        }
        static getDefaults() {
            return Object.assign(Ut.getDefaults(), { order: 1, oversample: 'none' });
        }
        _getCoefficient(t, e, o) {
            return (
                o.has(e) ||
                    (e === 0
                        ? o.set(e, 0)
                        : e === 1
                        ? o.set(e, t)
                        : o.set(
                              e,
                              2 * t * this._getCoefficient(t, e - 1, o) -
                                  this._getCoefficient(t, e - 2, o)
                          )),
                o.get(e)
            );
        }
        get order() {
            return this._order;
        }
        set order(t) {
            (this._order = t), this._shaper.setMap(e => this._getCoefficient(e, t, new Map()));
        }
        get oversample() {
            return this._shaper.oversample;
        }
        set oversample(t) {
            this._shaper.oversample = t;
        }
        dispose() {
            return super.dispose(), this._shaper.dispose(), this;
        }
    };
    var ro = class extends S {
        constructor() {
            super(g(ro.getDefaults(), arguments, ['channels']));
            this.name = 'Split';
            let t = g(ro.getDefaults(), arguments, ['channels']);
            (this._splitter =
                this.input =
                this.output =
                    this.context.createChannelSplitter(t.channels)),
                (this._internalChannels = [this._splitter]);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { channels: 2 });
        }
        dispose() {
            return super.dispose(), this._splitter.disconnect(), this;
        }
    };
    var ze = class extends S {
        constructor() {
            super(g(ze.getDefaults(), arguments, ['channels']));
            this.name = 'Merge';
            let t = g(ze.getDefaults(), arguments, ['channels']);
            this._merger = this.output = this.input = this.context.createChannelMerger(t.channels);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { channels: 2 });
        }
        dispose() {
            return super.dispose(), this._merger.disconnect(), this;
        }
    };
    var Ue = class extends S {
        constructor(t) {
            super(t);
            (this.name = 'StereoEffect'),
                (this.input = new P({ context: this.context })),
                (this.input.channelCount = 2),
                (this.input.channelCountMode = 'explicit'),
                (this._dryWet = this.output = new oo({ context: this.context, fade: t.wet })),
                (this.wet = this._dryWet.fade),
                (this._split = new ro({ context: this.context, channels: 2 })),
                (this._merge = new ze({ context: this.context, channels: 2 })),
                this.input.connect(this._split),
                this.input.connect(this._dryWet.a),
                this._merge.connect(this._dryWet.b),
                M(this, ['wet']);
        }
        connectEffectLeft(...t) {
            this._split.connect(t[0], 0, 0), Qt(...t), Et(t[t.length - 1], this._merge, 0, 0);
        }
        connectEffectRight(...t) {
            this._split.connect(t[0], 1, 0), Qt(...t), Et(t[t.length - 1], this._merge, 0, 1);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { wet: 1 });
        }
        dispose() {
            return (
                super.dispose(),
                this._dryWet.dispose(),
                this._split.dispose(),
                this._merge.dispose(),
                this
            );
        }
    };
    var Ar = class extends Ut {
        constructor() {
            super(g(Ar.getDefaults(), arguments, ['distortion']));
            this.name = 'Distortion';
            let t = g(Ar.getDefaults(), arguments, ['distortion']);
            (this._shaper = new zt({ context: this.context, length: 4096 })),
                (this._distortion = t.distortion),
                this.connectEffect(this._shaper),
                (this.distortion = t.distortion),
                (this.oversample = t.oversample);
        }
        static getDefaults() {
            return Object.assign(Ut.getDefaults(), { distortion: 0.4, oversample: 'none' });
        }
        get distortion() {
            return this._distortion;
        }
        set distortion(t) {
            this._distortion = t;
            let e = t * 100,
                o = Math.PI / 180;
            this._shaper.setMap(s =>
                Math.abs(s) < 0.001 ? 0 : ((3 + e) * s * 20 * o) / (Math.PI + e * Math.abs(s))
            );
        }
        get oversample() {
            return this._shaper.oversample;
        }
        set oversample(t) {
            this._shaper.oversample = t;
        }
        dispose() {
            return super.dispose(), this._shaper.dispose(), this;
        }
    };
    var yh = [
            1557 / 44100,
            1617 / 44100,
            1491 / 44100,
            1422 / 44100,
            1277 / 44100,
            1356 / 44100,
            1188 / 44100,
            1116 / 44100,
        ],
        vh = [225, 556, 441, 341],
        Sr = class extends Ue {
            constructor() {
                super(g(Sr.getDefaults(), arguments, ['roomSize', 'dampening']));
                (this.name = 'Freeverb'),
                    (this._combFilters = []),
                    (this._allpassFiltersL = []),
                    (this._allpassFiltersR = []);
                let t = g(Sr.getDefaults(), arguments, ['roomSize', 'dampening']);
                (this.roomSize = new z({
                    context: this.context,
                    value: t.roomSize,
                    units: 'normalRange',
                })),
                    (this._allpassFiltersL = vh.map(e => {
                        let o = this.context.createBiquadFilter();
                        return (o.type = 'allpass'), (o.frequency.value = e), o;
                    })),
                    (this._allpassFiltersR = vh.map(e => {
                        let o = this.context.createBiquadFilter();
                        return (o.type = 'allpass'), (o.frequency.value = e), o;
                    })),
                    (this._combFilters = yh.map((e, o) => {
                        let s = new Bo({
                            context: this.context,
                            dampening: t.dampening,
                            delayTime: e,
                        });
                        return (
                            o < yh.length / 2
                                ? this.connectEffectLeft(s, ...this._allpassFiltersL)
                                : this.connectEffectRight(s, ...this._allpassFiltersR),
                            this.roomSize.connect(s.resonance),
                            s
                        );
                    })),
                    M(this, ['roomSize']);
            }
            static getDefaults() {
                return Object.assign(Ue.getDefaults(), { roomSize: 0.7, dampening: 3e3 });
            }
            get dampening() {
                return this._combFilters[0].dampening;
            }
            set dampening(t) {
                this._combFilters.forEach(e => (e.dampening = t));
            }
            dispose() {
                return (
                    super.dispose(),
                    this._allpassFiltersL.forEach(t => t.disconnect()),
                    this._allpassFiltersR.forEach(t => t.disconnect()),
                    this._combFilters.forEach(t => t.dispose()),
                    this.roomSize.dispose(),
                    this
                );
            }
        };
    var $K = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3];
    var Cr = class extends Ue {
        constructor() {
            super(g(Cr.getDefaults(), arguments, ['frequency', 'depth']));
            this.name = 'Tremolo';
            let t = g(Cr.getDefaults(), arguments, ['frequency', 'depth']);
            (this._lfoL = new ie({ context: this.context, type: t.type, min: 1, max: 0 })),
                (this._lfoR = new ie({ context: this.context, type: t.type, min: 1, max: 0 })),
                (this._amplitudeL = new P({ context: this.context })),
                (this._amplitudeR = new P({ context: this.context })),
                (this.frequency = new z({
                    context: this.context,
                    value: t.frequency,
                    units: 'frequency',
                })),
                (this.depth = new z({
                    context: this.context,
                    value: t.depth,
                    units: 'normalRange',
                })),
                M(this, ['frequency', 'depth']),
                this.connectEffectLeft(this._amplitudeL),
                this.connectEffectRight(this._amplitudeR),
                this._lfoL.connect(this._amplitudeL.gain),
                this._lfoR.connect(this._amplitudeR.gain),
                this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency),
                this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude),
                (this.spread = t.spread);
        }
        static getDefaults() {
            return Object.assign(Ue.getDefaults(), {
                frequency: 10,
                type: 'sine',
                depth: 0.5,
                spread: 180,
            });
        }
        start(t) {
            return this._lfoL.start(t), this._lfoR.start(t), this;
        }
        stop(t) {
            return this._lfoL.stop(t), this._lfoR.stop(t), this;
        }
        sync() {
            return (
                this._lfoL.sync(),
                this._lfoR.sync(),
                this.context.transport.syncSignal(this.frequency),
                this
            );
        }
        unsync() {
            return (
                this._lfoL.unsync(),
                this._lfoR.unsync(),
                this.context.transport.unsyncSignal(this.frequency),
                this
            );
        }
        get type() {
            return this._lfoL.type;
        }
        set type(t) {
            (this._lfoL.type = t), (this._lfoR.type = t);
        }
        get spread() {
            return this._lfoR.phase - this._lfoL.phase;
        }
        set spread(t) {
            (this._lfoL.phase = 90 - t / 2), (this._lfoR.phase = t / 2 + 90);
        }
        dispose() {
            return (
                super.dispose(),
                this._lfoL.dispose(),
                this._lfoR.dispose(),
                this._amplitudeL.dispose(),
                this._amplitudeR.dispose(),
                this.frequency.dispose(),
                this.depth.dispose(),
                this
            );
        }
    };
    var kr = class extends Ut {
        constructor() {
            super(g(kr.getDefaults(), arguments, ['frequency', 'depth']));
            this.name = 'Vibrato';
            let t = g(kr.getDefaults(), arguments, ['frequency', 'depth']);
            (this._delayNode = new je({
                context: this.context,
                delayTime: 0,
                maxDelay: t.maxDelay,
            })),
                (this._lfo = new ie({
                    context: this.context,
                    type: t.type,
                    min: 0,
                    max: t.maxDelay,
                    frequency: t.frequency,
                    phase: -90,
                })
                    .start()
                    .connect(this._delayNode.delayTime)),
                (this.frequency = this._lfo.frequency),
                (this.depth = this._lfo.amplitude),
                (this.depth.value = t.depth),
                M(this, ['frequency', 'depth']),
                this.effectSend.chain(this._delayNode, this.effectReturn);
        }
        static getDefaults() {
            return Object.assign(Ut.getDefaults(), {
                maxDelay: 0.005,
                frequency: 5,
                depth: 0.1,
                type: 'sine',
            });
        }
        get type() {
            return this._lfo.type;
        }
        set type(t) {
            this._lfo.type = t;
        }
        dispose() {
            return (
                super.dispose(),
                this._delayNode.dispose(),
                this._lfo.dispose(),
                this.frequency.dispose(),
                this.depth.dispose(),
                this
            );
        }
    };
    var vt = class extends S {
        constructor() {
            super(g(vt.getDefaults(), arguments, ['solo']));
            this.name = 'Solo';
            let t = g(vt.getDefaults(), arguments, ['solo']);
            (this.input = this.output = new P({ context: this.context })),
                vt._allSolos.has(this.context) || vt._allSolos.set(this.context, new Set()),
                vt._allSolos.get(this.context).add(this),
                (this.solo = t.solo);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { solo: !1 });
        }
        get solo() {
            return this._isSoloed();
        }
        set solo(t) {
            t ? this._addSolo() : this._removeSolo(),
                vt._allSolos.get(this.context).forEach(e => e._updateSolo());
        }
        get muted() {
            return this.input.gain.value === 0;
        }
        _addSolo() {
            vt._soloed.has(this.context) || vt._soloed.set(this.context, new Set()),
                vt._soloed.get(this.context).add(this);
        }
        _removeSolo() {
            vt._soloed.has(this.context) && vt._soloed.get(this.context).delete(this);
        }
        _isSoloed() {
            return vt._soloed.has(this.context) && vt._soloed.get(this.context).has(this);
        }
        _noSolos() {
            return (
                !vt._soloed.has(this.context) ||
                (vt._soloed.has(this.context) && vt._soloed.get(this.context).size === 0)
            );
        }
        _updateSolo() {
            this._isSoloed()
                ? (this.input.gain.value = 1)
                : this._noSolos()
                ? (this.input.gain.value = 1)
                : (this.input.gain.value = 0);
        }
        dispose() {
            return (
                super.dispose(),
                vt._allSolos.get(this.context).delete(this),
                this._removeSolo(),
                this
            );
        }
    };
    vt._allSolos = new Map();
    vt._soloed = new Map();
    var Nr = class extends S {
        constructor() {
            super(g(Nr.getDefaults(), arguments, ['pan', 'volume']));
            this.name = 'PanVol';
            let t = g(Nr.getDefaults(), arguments, ['pan', 'volume']);
            (this._panner = this.input =
                new jo({ context: this.context, pan: t.pan, channelCount: t.channelCount })),
                (this.pan = this._panner.pan),
                (this._volume = this.output = new se({ context: this.context, volume: t.volume })),
                (this.volume = this._volume.volume),
                this._panner.connect(this._volume),
                (this.mute = t.mute),
                M(this, ['pan', 'volume']);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), { mute: !1, pan: 0, volume: 0, channelCount: 1 });
        }
        get mute() {
            return this._volume.mute;
        }
        set mute(t) {
            this._volume.mute = t;
        }
        dispose() {
            return (
                super.dispose(),
                this._panner.dispose(),
                this.pan.dispose(),
                this._volume.dispose(),
                this.volume.dispose(),
                this
            );
        }
    };
    var xo = class extends S {
        constructor() {
            super(g(xo.getDefaults(), arguments, ['volume', 'pan']));
            this.name = 'Channel';
            let t = g(xo.getDefaults(), arguments, ['volume', 'pan']);
            (this._solo = this.input = new vt({ solo: t.solo, context: this.context })),
                (this._panVol = this.output =
                    new Nr({
                        context: this.context,
                        pan: t.pan,
                        volume: t.volume,
                        mute: t.mute,
                        channelCount: t.channelCount,
                    })),
                (this.pan = this._panVol.pan),
                (this.volume = this._panVol.volume),
                this._solo.connect(this._panVol),
                M(this, ['pan', 'volume']);
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), {
                pan: 0,
                volume: 0,
                mute: !1,
                solo: !1,
                channelCount: 1,
            });
        }
        get solo() {
            return this._solo.solo;
        }
        set solo(t) {
            this._solo.solo = t;
        }
        get muted() {
            return this._solo.muted || this.mute;
        }
        get mute() {
            return this._panVol.mute;
        }
        set mute(t) {
            this._panVol.mute = t;
        }
        _getBus(t) {
            return (
                xo.buses.has(t) || xo.buses.set(t, new P({ context: this.context })),
                xo.buses.get(t)
            );
        }
        send(t, e = 0) {
            let o = this._getBus(t),
                s = new P({ context: this.context, units: 'decibels', gain: e });
            return this.connect(s), s.connect(o), s;
        }
        receive(t) {
            return this._getBus(t).connect(this), this;
        }
        dispose() {
            return (
                super.dispose(),
                this._panVol.dispose(),
                this.pan.dispose(),
                this.volume.dispose(),
                this._solo.dispose(),
                this
            );
        }
    };
    xo.buses = new Map();
    var wh = class extends S {
        constructor() {
            super(...arguments);
            (this.name = 'Listener'),
                (this.positionX = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.positionX,
                })),
                (this.positionY = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.positionY,
                })),
                (this.positionZ = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.positionZ,
                })),
                (this.forwardX = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.forwardX,
                })),
                (this.forwardY = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.forwardY,
                })),
                (this.forwardZ = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.forwardZ,
                })),
                (this.upX = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.upX,
                })),
                (this.upY = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.upY,
                })),
                (this.upZ = new X({
                    context: this.context,
                    param: this.context.rawContext.listener.upZ,
                }));
        }
        static getDefaults() {
            return Object.assign(S.getDefaults(), {
                positionX: 0,
                positionY: 0,
                positionZ: 0,
                forwardX: 0,
                forwardY: 0,
                forwardZ: -1,
                upX: 0,
                upY: 1,
                upZ: 0,
            });
        }
        dispose() {
            return (
                super.dispose(),
                this.positionX.dispose(),
                this.positionY.dispose(),
                this.positionZ.dispose(),
                this.forwardX.dispose(),
                this.forwardY.dispose(),
                this.forwardZ.dispose(),
                this.upX.dispose(),
                this.upY.dispose(),
                this.upZ.dispose(),
                this
            );
        }
    };
    po(r => {
        r.listener = new wh({ context: r });
    });
    fo(r => {
        r.listener.dispose();
    });
    var Urt = Nt().transport;
    var Yrt = Nt().destination,
        Hrt = Nt().destination;
    var Xrt = Nt().listener;
    var Qrt = Nt().draw;
    var Zrt = Nt();
    var Js = class {
        type = 'Sound';
        constructor(t, e) {
            ns(ws()),
                (this.volume = 1),
                (this.frequency = t || 440),
                (this.oscillatorType = e || 'fatsawtooth'),
                this.oscillatorType === 'drum'
                    ? (this.synth = new eo().toDestination())
                    : this.oscillatorType === 'metal'
                    ? (this.synth = new Vo().toDestination())
                    : (this.synth = new ge({
                          oscillator: { type: this.oscillatorType },
                      }).toDestination()),
                this.setFrequency(this.frequency);
        }
        setFrequency(t) {
            (this.frequency = t), (this.synth.frequency.value = t);
        }
        setVolume(t) {
            (this.volume = t), (this.synth.volume.value = t);
        }
        getFrequency() {
            return this.frequency;
        }
        getVolume() {
            return this.volume;
        }
        setOscillatorType(t) {
            t !== this.getOscillatorType() &&
                (t === 'drum'
                    ? (this.disconnect(),
                      (this.synth = new eo().toDestination()),
                      this.setFrequency(this.getFrequency()))
                    : t === 'metal'
                    ? (this.disconnect(),
                      (this.synth = new Vo().toDestination()),
                      this.setFrequency(this.getFrequency()))
                    : this.getOscillatorType() === 'drum' || this.getOscillatorType() === 'metal'
                    ? (this.disconnect(),
                      (this.synth = new ge({ oscillator: { type: t } }).toDestination()),
                      this.setFrequency(this.frequency))
                    : (this.synth, (this.synth.oscillator.type = t)),
                (this.oscillatorType = t));
        }
        getOscillatorType() {
            return this.oscillatorType;
        }
        play() {
            this.getOscillatorType() === 'metal'
                ? this.synth.triggerAttack()
                : this.synth.triggerAttack(this.getFrequency());
        }
        playFor(t) {
            this.getOscillatorType() === 'metal'
                ? this.synth.triggerAttackRelease(t)
                : this.synth.triggerAttackRelease(this.getFrequency(), t);
        }
        stop() {
            this.synth.triggerRelease();
        }
        disconnect() {
            this.synth.disconnect();
        }
        setEffect(t, e) {
            switch (t) {
                case 'distortion':
                    var o = new Ar(e).toDestination();
                    this.synth.connect(o);
                    return;
                case 'chebyshev':
                    var s = new Tr(e * 100).toDestination();
                    this.synth.connect(s);
                    return;
                case 'reverb':
                    var n = new Sr().toDestination();
                    (n.wet.value = e), this.synth.connect(n);
                    return;
                case 'tremolo':
                    var i = new Cr().toDestination().start();
                    (i.wet.value = e), this.synth.connect(i);
                    return;
                case 'vibrato':
                    var a = new kr().toDestination();
                    (a.wet.value = e), this.synth.connect(a);
                    return;
                default:
                    return;
            }
        }
    };
    var Th = class extends bt {
            type = 'Group';
            elements;
            constructor(...t) {
                super();
                (this.elements = t),
                    (this._hiddenCanvas = document.createElement('canvas')),
                    (this._hiddenCanvas.width = 1),
                    (this._hiddenCanvas.height = 1),
                    (this._hiddenContext = this._hiddenCanvas.getContext('2d')),
                    (this._lastRecordedBounds = {}),
                    (this.bounds = null);
            }
            get x() {
                return this.getBounds().left;
            }
            set x(t) {
                !this.bounds || this.setPosition(t, this.bounds.top);
            }
            get y() {
                return this.getBounds().top;
            }
            set y(t) {
                !this.bounds || this.setPosition(this.bounds.left, t);
            }
            get width() {
                let t = this.getBounds();
                return t.right - t.left;
            }
            get height() {
                let t = this.getBounds();
                return t.bottom - t.top;
            }
            getElements() {
                return this.elements;
            }
            add(t) {
                this.elements.push(t),
                    this._invalidateBounds(),
                    t._invalidationDependants.push(this);
            }
            remove(t) {
                t._invalidationDependants.splice(t._invalidationDependants.indexOf(this), 1);
                let e = this.elements.indexOf(t);
                e < 0 || (this.elements.splice(e, 1), this._invalidateBounds());
            }
            move(t, e) {
                this.elements.forEach(o => {
                    o.move(t, e);
                }),
                    this._invalidateBounds();
            }
            setPosition(t, e) {
                let o = this.getBounds(),
                    s = t - o.left,
                    n = e - o.top;
                this.move(s, n);
            }
            draw(t) {
                super.draw(t, () => {
                    t.beginPath();
                    let e = this.getBounds(),
                        o = e.right - e.left,
                        s = e.bottom - e.top;
                    !o ||
                        !s ||
                        (this._hiddenContext.clearRect(0, 0, o, s),
                        this._hiddenContext.translate(-e.left, -e.top),
                        this.elements
                            .filter(n => n.alive)
                            .sort((n, i) => n.layer - i.layer)
                            .forEach(n => {
                                n.draw(this._hiddenContext);
                            }),
                        this._hiddenContext.translate(e.left, e.top),
                        t.drawImage(this._hiddenCanvas, 0, 0, o, s),
                        t.closePath());
                });
            }
            describe() {
                return `A Group at ${this.x}, ${this.y}, containing: ${this.elements
                    .map(t => t.describe())
                    .join(' ')}`;
            }
            _containsPoint(t, e) {
                return (
                    (t += this.width * this.anchor.horizontal),
                    (e += this.height * this.anchor.vertical),
                    this.elements.some(o => o.containsPoint(t, e))
                );
            }
            _updateBounds() {
                let t = 0,
                    e = 0,
                    o = 1 / 0,
                    s = 1 / 0;
                this.elements.forEach(n => {
                    n._lastCalculatedBoundsID > (this._lastRecordedBounds[n._id] || 0) &&
                        (this._lastRecordedBounds[n._id] = n._lastCalculatedBoundsID);
                    let i = n.getBounds(),
                        { left: a, right: c, top: u, bottom: l } = i;
                    if (n.rotation) {
                        let h = (c - a) / 2 + a,
                            p = (l - u) / 2 + u,
                            d = Go([a, u], [h, p], n.rotation),
                            f = Go([c, u], [h, p], n.rotation),
                            m = Go([a, l], [h, p], n.rotation),
                            _ = Go([c, l], [h, p], n.rotation),
                            y = [d, f, m, _],
                            w = y.map(k => k[0]),
                            O = y.map(k => k[1]);
                        (a = Math.min(...w)),
                            (c = Math.max(...w)),
                            (u = Math.min(...O)),
                            (l = Math.max(...O));
                    }
                    (o = Math.min(o, a)),
                        (s = Math.min(s, u)),
                        (t = Math.max(t, c)),
                        (e = Math.max(e, l));
                }),
                    (this.bounds = { left: o, right: t, top: s, bottom: e }),
                    (this._hiddenCanvas.width = t - o),
                    (this._hiddenCanvas.height = e - s),
                    this._lastCalculatedBoundsID++,
                    (this._boundsInvalidated = !1);
            }
        },
        Ah = Th;
    window.Arc = hi;
    window.Audio = vs;
    window.Circle = di;
    window.Color = ht;
    window.Console = Er;
    window.Graphics = hn;
    window.Group = Ah;
    window.Keyboard = yi;
    window.Line = _s;
    window.Oval = xs;
    window.Polygon = wi;
    window.Queue = ls;
    window.Rectangle = Ti;
    window.Sound = Js;
    window.Stack = hs;
    window.Text = Ai;
    window.Thing = bt;
    window.WebVideo = Rr;
    window.WebImage = ki;
    window.Randomizer = an;
    var tt = new hn();
    window.__graphics__ = tt;
    window.add = tt.add.bind(tt);
    window.getWidth = tt.getWidth.bind(tt);
    window.getHeight = tt.getHeight.bind(tt);
    window.mouseClickMethod = tt.mouseClickMethod.bind(tt);
    window.mouseDownMethod = tt.mouseDownMethod.bind(tt);
    window.mouseDragMethod = tt.mouseDragMethod.bind(tt);
    window.mouseUpMethod = tt.mouseUpMethod.bind(tt);
    window.mouseMoveMethod = tt.mouseMoveMethod.bind(tt);
    window.stopAllTimers = tt.stopAllTimers.bind(tt);
    window.setMainTimer = tt.setMainTimer.bind(tt);
    window.stopTimer = tt.stopTimer.bind(tt);
    window.setTimer = tt.setTimer.bind(tt);
    window.keyDownMethod = tt.keyDownMethod.bind(tt);
    window.removeAll = tt.removeAll.bind(tt);
    window.remove = tt.remove.bind(tt);
    window.setBackgroundColor = tt.setBackgroundColor.bind(tt);
    window.getElementAt = tt.getElementAt.bind(tt);
    window.getElementsAt = tt.getElementsAt.bind(tt);
    window.setFullscreen = tt.setFullscreen.bind(tt);
    window.setSize = tt.setSize.bind(tt);
    var tn = new Er();
    window.readLine = tn.readLine.bind(tn);
    window.readInt = tn.readInt.bind(tn);
    var Sh = new bs();
    window.audioChangeMethod = Sh.audioChangeMethod.bind(Sh);
    window.map = ui;
})();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */
