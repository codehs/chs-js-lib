<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>graphics/index.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Arc.html">Arc</a><ul class='methods'><li data-type='method'><a href="Arc.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Arc.html#describe">describe</a></li><li data-type='method'><a href="Arc.html#focus">focus</a></li><li data-type='method'><a href="Arc.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Arc.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Arc.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Arc.html#getBounds">getBounds</a></li><li data-type='method'><a href="Arc.html#getColor">getColor</a></li><li data-type='method'><a href="Arc.html#getEndAngle">getEndAngle</a></li><li data-type='method'><a href="Arc.html#getStartAngle">getStartAngle</a></li><li data-type='method'><a href="Arc.html#getType">getType</a></li><li data-type='method'><a href="Arc.html#getX">getX</a></li><li data-type='method'><a href="Arc.html#getY">getY</a></li><li data-type='method'><a href="Arc.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Arc.html#isFilled">isFilled</a></li><li data-type='method'><a href="Arc.html#move">move</a></li><li data-type='method'><a href="Arc.html#rotate">rotate</a></li><li data-type='method'><a href="Arc.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Arc.html#setBorder">setBorder</a></li><li data-type='method'><a href="Arc.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Arc.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Arc.html#setColor">setColor</a></li><li data-type='method'><a href="Arc.html#setDirection">setDirection</a></li><li data-type='method'><a href="Arc.html#setEndAngle">setEndAngle</a></li><li data-type='method'><a href="Arc.html#setFilled">setFilled</a></li><li data-type='method'><a href="Arc.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Arc.html#setPosition">setPosition</a></li><li data-type='method'><a href="Arc.html#setRotation">setRotation</a></li><li data-type='method'><a href="Arc.html#setStartAngle">setStartAngle</a></li><li data-type='method'><a href="Arc.html#setType">setType</a></li><li data-type='method'><a href="Arc.html#unfocus">unfocus</a></li></ul></li><li><a href="Audio.html">Audio</a></li><li><a href="AudioManager.html">AudioManager</a><ul class='methods'><li data-type='method'><a href="AudioManager.html#audioChangeMethod">audioChangeMethod</a></li></ul></li><li><a href="Circle.html">Circle</a><ul class='methods'><li data-type='method'><a href="Circle.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Circle.html#describe">describe</a></li><li data-type='method'><a href="Circle.html#focus">focus</a></li><li data-type='method'><a href="Circle.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Circle.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Circle.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Circle.html#getBounds">getBounds</a></li><li data-type='method'><a href="Circle.html#getColor">getColor</a></li><li data-type='method'><a href="Circle.html#getHeight">getHeight</a></li><li data-type='method'><a href="Circle.html#getRadius">getRadius</a></li><li data-type='method'><a href="Circle.html#getType">getType</a></li><li data-type='method'><a href="Circle.html#getWidth">getWidth</a></li><li data-type='method'><a href="Circle.html#getX">getX</a></li><li data-type='method'><a href="Circle.html#getY">getY</a></li><li data-type='method'><a href="Circle.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Circle.html#isFilled">isFilled</a></li><li data-type='method'><a href="Circle.html#move">move</a></li><li data-type='method'><a href="Circle.html#rotate">rotate</a></li><li data-type='method'><a href="Circle.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Circle.html#setBorder">setBorder</a></li><li data-type='method'><a href="Circle.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Circle.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Circle.html#setColor">setColor</a></li><li data-type='method'><a href="Circle.html#setFilled">setFilled</a></li><li data-type='method'><a href="Circle.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Circle.html#setPosition">setPosition</a></li><li data-type='method'><a href="Circle.html#setRadius">setRadius</a></li><li data-type='method'><a href="Circle.html#setRotation">setRotation</a></li><li data-type='method'><a href="Circle.html#setType">setType</a></li><li data-type='method'><a href="Circle.html#unfocus">unfocus</a></li></ul></li><li><a href="Console.html">Console</a><ul class='methods'><li data-type='method'><a href="Console.html#configure">configure</a></li><li data-type='method'><a href="Console.html#readLinePrivate">readLinePrivate</a></li><li data-type='method'><a href="Console.html#readLinePrivateAsync">readLinePrivateAsync</a></li></ul></li><li><a href="ExtendedSet.html">ExtendedSet</a><ul class='methods'><li data-type='method'><a href="ExtendedSet.html#elems">elems</a></li><li data-type='method'><a href="ExtendedSet.html#getKey">getKey</a></li><li data-type='method'><a href="ExtendedSet.html#intersect">intersect</a></li><li data-type='method'><a href="ExtendedSet.html#isEmpty">isEmpty</a></li><li data-type='method'><a href="ExtendedSet.html#toString">toString</a></li><li data-type='method'><a href="ExtendedSet.html#union">union</a></li></ul></li><li><a href="GraphicsManager.html">GraphicsManager</a><ul class='methods'><li data-type='method'><a href="GraphicsManager.html#addEventListeners">addEventListeners</a></li><li data-type='method'><a href="GraphicsManager.html#cleanup">cleanup</a></li><li data-type='method'><a href="GraphicsManager.html#getCanvas">getCanvas</a></li><li data-type='method'><a href="GraphicsManager.html#getContext">getContext</a></li><li data-type='method'><a href="GraphicsManager.html#getPixel">getPixel</a></li><li data-type='method'><a href="GraphicsManager.html#setCurrentCanvas">setCurrentCanvas</a></li><li data-type='method'><a href="GraphicsManager.html#waitingForClick">waitingForClick</a></li></ul></li><li><a href="Grid.html">Grid</a><ul class='methods'><li data-type='method'><a href="Grid.html#get">get</a></li><li data-type='method'><a href="Grid.html#inBounds">inBounds</a></li><li data-type='method'><a href="Grid.html#init">init</a></li><li data-type='method'><a href="Grid.html#initFromArray">initFromArray</a></li><li data-type='method'><a href="Grid.html#numCols">numCols</a></li><li data-type='method'><a href="Grid.html#numRows">numRows</a></li><li data-type='method'><a href="Grid.html#set">set</a></li><li data-type='method'><a href="Grid.html#toList">toList</a></li><li data-type='method'><a href="Grid.html#toString">toString</a></li></ul></li><li><a href="Group.html">Group</a><ul class='methods'><li data-type='method'><a href="Group.html#add">add</a></li><li data-type='method'><a href="Group.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Group.html#describe">describe</a></li><li data-type='method'><a href="Group.html#draw">draw</a></li><li data-type='method'><a href="Group.html#focus">focus</a></li><li data-type='method'><a href="Group.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Group.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Group.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Group.html#getBounds">getBounds</a></li><li data-type='method'><a href="Group.html#getColor">getColor</a></li><li data-type='method'><a href="Group.html#getElements">getElements</a></li><li data-type='method'><a href="Group.html#getType">getType</a></li><li data-type='method'><a href="Group.html#getX">getX</a></li><li data-type='method'><a href="Group.html#getY">getY</a></li><li data-type='method'><a href="Group.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Group.html#isFilled">isFilled</a></li><li data-type='method'><a href="Group.html#move">move</a></li><li data-type='method'><a href="Group.html#remove">remove</a></li><li data-type='method'><a href="Group.html#rotate">rotate</a></li><li data-type='method'><a href="Group.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Group.html#setBorder">setBorder</a></li><li data-type='method'><a href="Group.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Group.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Group.html#setColor">setColor</a></li><li data-type='method'><a href="Group.html#setFilled">setFilled</a></li><li data-type='method'><a href="Group.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Group.html#setPosition">setPosition</a></li><li data-type='method'><a href="Group.html#setRotation">setRotation</a></li><li data-type='method'><a href="Group.html#setType">setType</a></li><li data-type='method'><a href="Group.html#unfocus">unfocus</a></li></ul></li><li><a href="Line.html">Line</a><ul class='methods'><li data-type='method'><a href="Line.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Line.html#describe">describe</a></li><li data-type='method'><a href="Line.html#focus">focus</a></li><li data-type='method'><a href="Line.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Line.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Line.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Line.html#getBounds">getBounds</a></li><li data-type='method'><a href="Line.html#getColor">getColor</a></li><li data-type='method'><a href="Line.html#getEndX">getEndX</a></li><li data-type='method'><a href="Line.html#getEndY">getEndY</a></li><li data-type='method'><a href="Line.html#getHeight">getHeight</a></li><li data-type='method'><a href="Line.html#getStartX">getStartX</a></li><li data-type='method'><a href="Line.html#getStartY">getStartY</a></li><li data-type='method'><a href="Line.html#getType">getType</a></li><li data-type='method'><a href="Line.html#getWidth">getWidth</a></li><li data-type='method'><a href="Line.html#getX">getX</a></li><li data-type='method'><a href="Line.html#getY">getY</a></li><li data-type='method'><a href="Line.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Line.html#isFilled">isFilled</a></li><li data-type='method'><a href="Line.html#move">move</a></li><li data-type='method'><a href="Line.html#rotate">rotate</a></li><li data-type='method'><a href="Line.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Line.html#setBorder">setBorder</a></li><li data-type='method'><a href="Line.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Line.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Line.html#setColor">setColor</a></li><li data-type='method'><a href="Line.html#setEndpoint">setEndpoint</a></li><li data-type='method'><a href="Line.html#setFilled">setFilled</a></li><li data-type='method'><a href="Line.html#setLineWidth">setLineWidth</a></li><li data-type='method'><a href="Line.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Line.html#setPosition">setPosition</a></li><li data-type='method'><a href="Line.html#setRotation">setRotation</a></li><li data-type='method'><a href="Line.html#setStartpoint">setStartpoint</a></li><li data-type='method'><a href="Line.html#setType">setType</a></li><li data-type='method'><a href="Line.html#unfocus">unfocus</a></li></ul></li><li><a href="Manager.html">Manager</a><ul class='methods'><li data-type='method'><a href="Manager.html#stopAllTimers">stopAllTimers</a></li><li data-type='method'><a href="Manager.html#stopTimer">stopTimer</a></li></ul></li><li><a href="module-Color-Color.html">Color</a><ul class='methods'><li data-type='method'><a href="module-Color-Color.html#.average">average</a></li><li data-type='method'><a href="module-Color-Color.html#.createFromRGB">createFromRGB</a></li><li data-type='method'><a href="module-Color-Color.html#.createFromRGBL">createFromRGBL</a></li><li data-type='method'><a href="module-Color-Color.html#.getColor">getColor</a></li><li data-type='method'><a href="module-Color-Color.html#.hslToRgb">hslToRgb</a></li><li data-type='method'><a href="module-Color-Color.html#.randomBlue">randomBlue</a></li><li data-type='method'><a href="module-Color-Color.html#.randomGreen">randomGreen</a></li><li data-type='method'><a href="module-Color-Color.html#.randomRed">randomRed</a></li><li data-type='method'><a href="module-Color-Color.html#.rgbToHsl">rgbToHsl</a></li><li data-type='method'><a href="module-Color-Color.html#toString">toString</a></li></ul></li><li><a href="Oval.html">Oval</a><ul class='methods'><li data-type='method'><a href="Oval.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Oval.html#describe">describe</a></li><li data-type='method'><a href="Oval.html#focus">focus</a></li><li data-type='method'><a href="Oval.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Oval.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Oval.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Oval.html#getBounds">getBounds</a></li><li data-type='method'><a href="Oval.html#getColor">getColor</a></li><li data-type='method'><a href="Oval.html#getHeight">getHeight</a></li><li data-type='method'><a href="Oval.html#getType">getType</a></li><li data-type='method'><a href="Oval.html#getWidth">getWidth</a></li><li data-type='method'><a href="Oval.html#getX">getX</a></li><li data-type='method'><a href="Oval.html#getY">getY</a></li><li data-type='method'><a href="Oval.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Oval.html#isFilled">isFilled</a></li><li data-type='method'><a href="Oval.html#move">move</a></li><li data-type='method'><a href="Oval.html#rotate">rotate</a></li><li data-type='method'><a href="Oval.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Oval.html#setBorder">setBorder</a></li><li data-type='method'><a href="Oval.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Oval.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Oval.html#setColor">setColor</a></li><li data-type='method'><a href="Oval.html#setFilled">setFilled</a></li><li data-type='method'><a href="Oval.html#setHeight">setHeight</a></li><li data-type='method'><a href="Oval.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Oval.html#setPosition">setPosition</a></li><li data-type='method'><a href="Oval.html#setRotation">setRotation</a></li><li data-type='method'><a href="Oval.html#setType">setType</a></li><li data-type='method'><a href="Oval.html#setWidth">setWidth</a></li><li data-type='method'><a href="Oval.html#unfocus">unfocus</a></li></ul></li><li><a href="Polygon.html">Polygon</a><ul class='methods'><li data-type='method'><a href="Polygon.html#addPoint">addPoint</a></li><li data-type='method'><a href="Polygon.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Polygon.html#describe">describe</a></li><li data-type='method'><a href="Polygon.html#focus">focus</a></li><li data-type='method'><a href="Polygon.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Polygon.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Polygon.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Polygon.html#getBounds">getBounds</a></li><li data-type='method'><a href="Polygon.html#getColor">getColor</a></li><li data-type='method'><a href="Polygon.html#getHeight">getHeight</a></li><li data-type='method'><a href="Polygon.html#getType">getType</a></li><li data-type='method'><a href="Polygon.html#getWidth">getWidth</a></li><li data-type='method'><a href="Polygon.html#getX">getX</a></li><li data-type='method'><a href="Polygon.html#getY">getY</a></li><li data-type='method'><a href="Polygon.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Polygon.html#isFilled">isFilled</a></li><li data-type='method'><a href="Polygon.html#move">move</a></li><li data-type='method'><a href="Polygon.html#rotate">rotate</a></li><li data-type='method'><a href="Polygon.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Polygon.html#setBorder">setBorder</a></li><li data-type='method'><a href="Polygon.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Polygon.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Polygon.html#setColor">setColor</a></li><li data-type='method'><a href="Polygon.html#setFilled">setFilled</a></li><li data-type='method'><a href="Polygon.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Polygon.html#setPosition">setPosition</a></li><li data-type='method'><a href="Polygon.html#setRotation">setRotation</a></li><li data-type='method'><a href="Polygon.html#setType">setType</a></li><li data-type='method'><a href="Polygon.html#unfocus">unfocus</a></li></ul></li><li><a href="Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="Queue.html#clear">clear</a></li><li data-type='method'><a href="Queue.html#hasNext">hasNext</a></li><li data-type='method'><a href="Queue.html#isEmpty">isEmpty</a></li><li data-type='method'><a href="Queue.html#peek">peek</a></li><li data-type='method'><a href="Queue.html#size">size</a></li></ul></li><li><a href="Rectangle.html">Rectangle</a><ul class='methods'><li data-type='method'><a href="Rectangle.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Rectangle.html#describe">describe</a></li><li data-type='method'><a href="Rectangle.html#focus">focus</a></li><li data-type='method'><a href="Rectangle.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Rectangle.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Rectangle.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Rectangle.html#getBounds">getBounds</a></li><li data-type='method'><a href="Rectangle.html#getColor">getColor</a></li><li data-type='method'><a href="Rectangle.html#getHeight">getHeight</a></li><li data-type='method'><a href="Rectangle.html#getType">getType</a></li><li data-type='method'><a href="Rectangle.html#getWidth">getWidth</a></li><li data-type='method'><a href="Rectangle.html#getX">getX</a></li><li data-type='method'><a href="Rectangle.html#getY">getY</a></li><li data-type='method'><a href="Rectangle.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Rectangle.html#isFilled">isFilled</a></li><li data-type='method'><a href="Rectangle.html#move">move</a></li><li data-type='method'><a href="Rectangle.html#rotate">rotate</a></li><li data-type='method'><a href="Rectangle.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Rectangle.html#setBorder">setBorder</a></li><li data-type='method'><a href="Rectangle.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Rectangle.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Rectangle.html#setColor">setColor</a></li><li data-type='method'><a href="Rectangle.html#setFilled">setFilled</a></li><li data-type='method'><a href="Rectangle.html#setHeight">setHeight</a></li><li data-type='method'><a href="Rectangle.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Rectangle.html#setPosition">setPosition</a></li><li data-type='method'><a href="Rectangle.html#setRotation">setRotation</a></li><li data-type='method'><a href="Rectangle.html#setSize">setSize</a></li><li data-type='method'><a href="Rectangle.html#setType">setType</a></li><li data-type='method'><a href="Rectangle.html#setWidth">setWidth</a></li><li data-type='method'><a href="Rectangle.html#unfocus">unfocus</a></li></ul></li><li><a href="Sound.html">Sound</a><ul class='methods'><li data-type='method'><a href="Sound.html#disconnect">disconnect</a></li><li data-type='method'><a href="Sound.html#getFrequency">getFrequency</a></li><li data-type='method'><a href="Sound.html#getOscillatorType">getOscillatorType</a></li><li data-type='method'><a href="Sound.html#getVolume">getVolume</a></li><li data-type='method'><a href="Sound.html#play">play</a></li><li data-type='method'><a href="Sound.html#playFor">playFor</a></li><li data-type='method'><a href="Sound.html#setEffect">setEffect</a></li><li data-type='method'><a href="Sound.html#setFrequency">setFrequency</a></li><li data-type='method'><a href="Sound.html#setOscillatorType">setOscillatorType</a></li><li data-type='method'><a href="Sound.html#setVolume">setVolume</a></li><li data-type='method'><a href="Sound.html#stop">stop</a></li></ul></li><li><a href="Stack.html">Stack</a><ul class='methods'><li data-type='method'><a href="Stack.html#clear">clear</a></li><li data-type='method'><a href="Stack.html#hasNext">hasNext</a></li><li data-type='method'><a href="Stack.html#isEmpty">isEmpty</a></li><li data-type='method'><a href="Stack.html#peek">peek</a></li><li data-type='method'><a href="Stack.html#size">size</a></li></ul></li><li><a href="Text.html">Text</a><ul class='methods'><li data-type='method'><a href="Text.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Text.html#describe">describe</a></li><li data-type='method'><a href="Text.html#focus">focus</a></li><li data-type='method'><a href="Text.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Text.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Text.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Text.html#getBounds">getBounds</a></li><li data-type='method'><a href="Text.html#getColor">getColor</a></li><li data-type='method'><a href="Text.html#getHeight">getHeight</a></li><li data-type='method'><a href="Text.html#getLabel">getLabel</a></li><li data-type='method'><a href="Text.html#getText">getText</a></li><li data-type='method'><a href="Text.html#getType">getType</a></li><li data-type='method'><a href="Text.html#getWidth">getWidth</a></li><li data-type='method'><a href="Text.html#getX">getX</a></li><li data-type='method'><a href="Text.html#getY">getY</a></li><li data-type='method'><a href="Text.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Text.html#isFilled">isFilled</a></li><li data-type='method'><a href="Text.html#move">move</a></li><li data-type='method'><a href="Text.html#resetDimensions">resetDimensions</a></li><li data-type='method'><a href="Text.html#rotate">rotate</a></li><li data-type='method'><a href="Text.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Text.html#setBorder">setBorder</a></li><li data-type='method'><a href="Text.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Text.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Text.html#setColor">setColor</a></li><li data-type='method'><a href="Text.html#setFilled">setFilled</a></li><li data-type='method'><a href="Text.html#setFont">setFont</a></li><li data-type='method'><a href="Text.html#setLabel">setLabel</a></li><li data-type='method'><a href="Text.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Text.html#setPosition">setPosition</a></li><li data-type='method'><a href="Text.html#setRotation">setRotation</a></li><li data-type='method'><a href="Text.html#setText">setText</a></li><li data-type='method'><a href="Text.html#setType">setType</a></li><li data-type='method'><a href="Text.html#unfocus">unfocus</a></li></ul></li><li><a href="Thing.html">Thing</a><ul class='methods'><li data-type='method'><a href="Thing.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Thing.html#describe">describe</a></li><li data-type='method'><a href="Thing.html#draw">draw</a></li><li data-type='method'><a href="Thing.html#focus">focus</a></li><li data-type='method'><a href="Thing.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="Thing.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="Thing.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="Thing.html#getBounds">getBounds</a></li><li data-type='method'><a href="Thing.html#getColor">getColor</a></li><li data-type='method'><a href="Thing.html#getType">getType</a></li><li data-type='method'><a href="Thing.html#getX">getX</a></li><li data-type='method'><a href="Thing.html#getY">getY</a></li><li data-type='method'><a href="Thing.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="Thing.html#isFilled">isFilled</a></li><li data-type='method'><a href="Thing.html#move">move</a></li><li data-type='method'><a href="Thing.html#rotate">rotate</a></li><li data-type='method'><a href="Thing.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="Thing.html#setBorder">setBorder</a></li><li data-type='method'><a href="Thing.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="Thing.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="Thing.html#setColor">setColor</a></li><li data-type='method'><a href="Thing.html#setFilled">setFilled</a></li><li data-type='method'><a href="Thing.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Thing.html#setPosition">setPosition</a></li><li data-type='method'><a href="Thing.html#setRotation">setRotation</a></li><li data-type='method'><a href="Thing.html#setType">setType</a></li><li data-type='method'><a href="Thing.html#unfocus">unfocus</a></li></ul></li><li></li><li><a href="Vector.html">Vector</a><ul class='methods'><li data-type='method'><a href="Vector.html#add">add</a></li><li data-type='method'><a href="Vector.html#angleBetween">angleBetween</a></li><li data-type='method'><a href="Vector.html#array">array</a></li><li data-type='method'><a href="Vector.html#clone">clone</a></li><li data-type='method'><a href="Vector.html#copy">copy</a></li><li data-type='method'><a href="Vector.html#cross">cross</a></li><li data-type='method'><a href="Vector.html#dot">dot</a></li><li data-type='method'><a href="Vector.html#heading">heading</a></li><li data-type='method'><a href="Vector.html#magnitude">magnitude</a></li><li data-type='method'><a href="Vector.html#multiply">multiply</a></li><li data-type='method'><a href="Vector.html#normalize">normalize</a></li><li data-type='method'><a href="Vector.html#rotate">rotate</a></li><li data-type='method'><a href="Vector.html#setHeading">setHeading</a></li><li data-type='method'><a href="Vector.html#subtract">subtract</a></li></ul></li><li><a href="WebImage.html">WebImage</a><ul class='methods'><li data-type='method'><a href="WebImage.html#checkDimensions">checkDimensions</a></li><li data-type='method'><a href="WebImage.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="WebImage.html#describe">describe</a></li><li data-type='method'><a href="WebImage.html#draw">draw</a></li><li data-type='method'><a href="WebImage.html#focus">focus</a></li><li data-type='method'><a href="WebImage.html#getAlpha">getAlpha</a></li><li data-type='method'><a href="WebImage.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="WebImage.html#getBlue">getBlue</a></li><li data-type='method'><a href="WebImage.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="WebImage.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="WebImage.html#getBounds">getBounds</a></li><li data-type='method'><a href="WebImage.html#getColor">getColor</a></li><li data-type='method'><a href="WebImage.html#getGreen">getGreen</a></li><li data-type='method'><a href="WebImage.html#getHeight">getHeight</a></li><li data-type='method'><a href="WebImage.html#getPixel">getPixel</a></li><li data-type='method'><a href="WebImage.html#getRed">getRed</a></li><li data-type='method'><a href="WebImage.html#getType">getType</a></li><li data-type='method'><a href="WebImage.html#getWidth">getWidth</a></li><li data-type='method'><a href="WebImage.html#getX">getX</a></li><li data-type='method'><a href="WebImage.html#getY">getY</a></li><li data-type='method'><a href="WebImage.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="WebImage.html#isFilled">isFilled</a></li><li data-type='method'><a href="WebImage.html#loaded">loaded</a></li><li data-type='method'><a href="WebImage.html#loadPixelData">loadPixelData</a></li><li data-type='method'><a href="WebImage.html#move">move</a></li><li data-type='method'><a href="WebImage.html#rotate">rotate</a></li><li data-type='method'><a href="WebImage.html#setAlpha">setAlpha</a></li><li data-type='method'><a href="WebImage.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="WebImage.html#setBlue">setBlue</a></li><li data-type='method'><a href="WebImage.html#setBorder">setBorder</a></li><li data-type='method'><a href="WebImage.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="WebImage.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="WebImage.html#setColor">setColor</a></li><li data-type='method'><a href="WebImage.html#setFilled">setFilled</a></li><li data-type='method'><a href="WebImage.html#setGreen">setGreen</a></li><li data-type='method'><a href="WebImage.html#setImage">setImage</a></li><li data-type='method'><a href="WebImage.html#setImageData">setImageData</a></li><li data-type='method'><a href="WebImage.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="WebImage.html#setPixel">setPixel</a></li><li data-type='method'><a href="WebImage.html#setPosition">setPosition</a></li><li data-type='method'><a href="WebImage.html#setRed">setRed</a></li><li data-type='method'><a href="WebImage.html#setRotation">setRotation</a></li><li data-type='method'><a href="WebImage.html#setSize">setSize</a></li><li data-type='method'><a href="WebImage.html#setType">setType</a></li><li data-type='method'><a href="WebImage.html#unfocus">unfocus</a></li><li data-type='method'><a href="WebImage.html#updateHiddenCanvas">updateHiddenCanvas</a></li></ul></li><li><a href="WebVideo.html">WebVideo</a><ul class='methods'><li data-type='method'><a href="WebVideo.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="WebVideo.html#describe">describe</a></li><li data-type='method'><a href="WebVideo.html#draw">draw</a></li><li data-type='method'><a href="WebVideo.html#focus">focus</a></li><li data-type='method'><a href="WebVideo.html#getAnchor">getAnchor</a></li><li data-type='method'><a href="WebVideo.html#getBorderColor">getBorderColor</a></li><li data-type='method'><a href="WebVideo.html#getBorderWidth">getBorderWidth</a></li><li data-type='method'><a href="WebVideo.html#getBounds">getBounds</a></li><li data-type='method'><a href="WebVideo.html#getColor">getColor</a></li><li data-type='method'><a href="WebVideo.html#getHeight">getHeight</a></li><li data-type='method'><a href="WebVideo.html#getType">getType</a></li><li data-type='method'><a href="WebVideo.html#getWidth">getWidth</a></li><li data-type='method'><a href="WebVideo.html#getX">getX</a></li><li data-type='method'><a href="WebVideo.html#getY">getY</a></li><li data-type='method'><a href="WebVideo.html#hasBorder">hasBorder</a></li><li data-type='method'><a href="WebVideo.html#isFilled">isFilled</a></li><li data-type='method'><a href="WebVideo.html#isMuted">isMuted</a></li><li data-type='method'><a href="WebVideo.html#isPlaying">isPlaying</a></li><li data-type='method'><a href="WebVideo.html#move">move</a></li><li data-type='method'><a href="WebVideo.html#onReadyToPlay">onReadyToPlay</a></li><li data-type='method'><a href="WebVideo.html#pause">pause</a></li><li data-type='method'><a href="WebVideo.html#play">play</a></li><li data-type='method'><a href="WebVideo.html#rotate">rotate</a></li><li data-type='method'><a href="WebVideo.html#setAnchor">setAnchor</a></li><li data-type='method'><a href="WebVideo.html#setAutoplay">setAutoplay</a></li><li data-type='method'><a href="WebVideo.html#setBorder">setBorder</a></li><li data-type='method'><a href="WebVideo.html#setBorderColor">setBorderColor</a></li><li data-type='method'><a href="WebVideo.html#setBorderWidth">setBorderWidth</a></li><li data-type='method'><a href="WebVideo.html#setColor">setColor</a></li><li data-type='method'><a href="WebVideo.html#setFilled">setFilled</a></li><li data-type='method'><a href="WebVideo.html#setLoop">setLoop</a></li><li data-type='method'><a href="WebVideo.html#setMuted">setMuted</a></li><li data-type='method'><a href="WebVideo.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="WebVideo.html#setPosition">setPosition</a></li><li data-type='method'><a href="WebVideo.html#setRotation">setRotation</a></li><li data-type='method'><a href="WebVideo.html#setSize">setSize</a></li><li data-type='method'><a href="WebVideo.html#setType">setType</a></li><li data-type='method'><a href="WebVideo.html#stop">stop</a></li><li data-type='method'><a href="WebVideo.html#unfocus">unfocus</a></li></ul></li><li></li></ul><h3>Modules</h3><ul><li><a href="module-Color.html">Color</a><ul class='methods'><li data-type='method'><a href="module-Color.html#.getColor">getColor</a></li><li data-type='method'><a href="module-Color.html#.hexToRgb">hexToRgb</a></li><li data-type='method'><a href="module-Color.html#.hue2rgb">hue2rgb</a></li><li data-type='method'><a href="module-Color.html#.rgbToHex">rgbToHex</a></li></ul></li><li><a href="module-Keyboard.html">Keyboard</a><ul class='methods'><li data-type='method'><a href="module-Keyboard.html#.digit">digit</a></li><li data-type='method'><a href="module-Keyboard.html#.isEditingKey">isEditingKey</a></li><li data-type='method'><a href="module-Keyboard.html#.letter">letter</a></li></ul></li><li><a href="module-Randomizer.html">Randomizer</a><ul class='methods'><li data-type='method'><a href="module-Randomizer.html#.nextBoolean">nextBoolean</a></li><li data-type='method'><a href="module-Randomizer.html#.nextColor">nextColor</a></li><li data-type='method'><a href="module-Randomizer.html#.nextFloat">nextFloat</a></li><li data-type='method'><a href="module-Randomizer.html#.nextHex">nextHex</a></li><li data-type='method'><a href="module-Randomizer.html#.nextInt">nextInt</a></li><li data-type='method'><a href="module-Randomizer.html#.noise">noise</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#deviceMotionMethod">deviceMotionMethod</a></li><li><a href="global.html#deviceOrientationMethod">deviceOrientationMethod</a></li><li><a href="global.html#elementExistsWithParameters">elementExistsWithParameters</a></li><li><a href="global.html#getDistance">getDistance</a></li><li><a href="global.html#getElementAt">getElementAt</a></li><li><a href="global.html#getElements">getElements</a></li><li><a href="global.html#getElementsAt">getElementsAt</a></li><li><a href="global.html#getHeight">getHeight</a></li><li><a href="global.html#getWidth">getWidth</a></li><li><a href="global.html#isKeyPressed">isKeyPressed</a></li><li><a href="global.html#keyDownMethod">keyDownMethod</a></li><li><a href="global.html#keyUpMethod">keyUpMethod</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mouseClickMethod">mouseClickMethod</a></li><li><a href="global.html#mouseDownMethod">mouseDownMethod</a></li><li><a href="global.html#mouseDragMethod">mouseDragMethod</a></li><li><a href="global.html#mouseMoveMethod">mouseMoveMethod</a></li><li><a href="global.html#mouseUpMethod">mouseUpMethod</a></li><li><a href="global.html#pressedKeys">pressedKeys</a></li><li><a href="global.html#print">print</a></li><li><a href="global.html#println">println</a></li><li><a href="global.html#readBoolean">readBoolean</a></li><li><a href="global.html#readBooleanAsync">readBooleanAsync</a></li><li><a href="global.html#readFloat">readFloat</a></li><li><a href="global.html#readFloatAsync">readFloatAsync</a></li><li><a href="global.html#readInt">readInt</a></li><li><a href="global.html#readIntAsync">readIntAsync</a></li><li><a href="global.html#readLine">readLine</a></li><li><a href="global.html#readLineAsync">readLineAsync</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeAll">removeAll</a></li><li><a href="global.html#resetAllTimers">resetAllTimers</a></li><li><a href="global.html#rotatePointAboutPosition">rotatePointAboutPosition</a></li><li><a href="global.html#setBackgroundColor">setBackgroundColor</a></li><li><a href="global.html#setFullscreen">setFullscreen</a></li><li><a href="global.html#setSize">setSize</a></li><li><a href="global.html#setTimer">setTimer</a></li><li><a href="global.html#stopAllTimers">stopAllTimers</a></li><li><a href="global.html#waitForClick">waitForClick</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">graphics/index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Manager, { DEFAULT_UPDATE_INTERVAL } from '../manager.js';
import Thing from './thing.js';
import WebVideo from './webvideo.js';

export const FULLSCREEN_PADDING = 5;
export const KEYBOARD_NAVIGATION_DOM_ELEMENT_STYLE =
    'position: absolute; width: 1px; height: 1px; top: -10px; overflow: hidden;';

export const HIDDEN_KEYBOARD_NAVIGATION_DOM_ELEMENT_STYLE =
    KEYBOARD_NAVIGATION_DOM_ELEMENT_STYLE + 'display: none;';

export const HIDDEN_KEYBOARD_NAVIGATION_DOM_ELEMENT_ID = id => `${id}focusbutton`;

/**
 * @type {Object.&lt;string, GraphicsManager>}
 * @private
 */
export let GraphicsInstances = {};
/**
 * @type {Array.&lt;any>}
 * @example
 * if (pressedKeys.indexOf(Keyboard.SPACE) > -1) {
 *     alert('you are pressing space!');
 * }
 */
export let pressedKeys = [];
let graphicsInstanceID = 0;

/**
 * Class for interacting with Graphics.
 * @class
 */
class GraphicsManager extends Manager {
    elementPool = [];
    elementPoolSize = 0;
    accessibleDOMElements = [];
    /**
     * The ratio of physical pixels to CSS pixels for the current device.
     * This allows the canvas to be scaled for higher resolution drawing.
     * For example, a devicePixelRatio of 2 indicates that the device will use
     * 2 physical pixels to draw a single css pixel.
     * https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
     * @private
     * @type {number}
     */
    devicePixelRatio = Math.ceil(window.devicePixelRatio) ?? 1;
    /**
     * Used to record when a resort is necessary as a result of adding an element with
     * an invalidated sort. Sorting will be performed on next redraw when _sortInvalidated
     * is true.
     * @type {boolean}
     * @private
     */
    _sortInvalidated = false;

    /**
     * Set up an instance of the graphics library.
     * @constructor
     * @param {Object} options - Options, primarily .canvas, the selector
     *      string for the canvas.
     *      If multiple are returned, we'll take the first one.
     *      If none is passed, we'll look for any canvas
     *      tag on the page.
     */
    constructor(options = {}) {
        super(options);
        this.resetAllState();
        this.setCurrentCanvas(options.canvas);
        this.onError = options.onError || undefined;
        this.fullscreenMode = false;
        this.fpsInterval = 1000 / DEFAULT_UPDATE_INTERVAL;
        this.lastDrawTime = Date.now();
        /**
         * Whether the user is using the keyboard to navigate the page.
         * This is used to toggle whether the hidden DOM elements used for keyboard
         * navigation should show up.
         * @private
         * @type {boolean}
         */
        this.userNavigatingWithKeyboard = false;
        this.addEventListeners();
        this.shouldUpdate = options.shouldUpdate ?? true;
        GraphicsInstances[graphicsInstanceID++] = this;
    }

    onKeyDown = e => {
        const index = pressedKeys.indexOf(e.keyCode);
        if (index === -1) {
            pressedKeys.push(e.keyCode);
        }

        if (e.key === 'Tab') {
            for (let i = 0; i &lt; this.elementPoolSize; i++) {
                const elem = this.elementPool[i];
                if (!elem._hasAccessibleDOMElement) {
                    this.createAccessibleDOMElement(elem);
                }
            }
            this.userNavigatingWithKeyboard = true;
            this.showKeyboardNavigationDOMElements();
        }

        this.keyDownCallback?.(e);
        return true;
    };

    onKeyUp = e => {
        const index = pressedKeys.indexOf(e.keyCode);
        if (index !== -1) {
            pressedKeys.splice(index, 1);
        }
        this.keyUpCallback?.(e);
    };

    onResize = e => {
        // https://developer.mozilla.org/en-US/docs/Web/Events/resize
        // Throttle the resize event handler since it fires at such a rapid rate
        // Only respond to the resize event if there's not already a response queued up
        if (!this._resizeTimeout) {
            this._resizeTimeout = setTimeout(() => {
                this._resizeTimeout = null;
                this.fullscreenMode &amp;&amp; this.setFullscreen?.();
            }, DEFAULT_UPDATE_INTERVAL);
        }
    };

    onOrientationChange = e => {
        this.deviceOrientationCallback?.(e);
    };

    onDeviceMotion = e => {
        this.deviceMotionCallback?.(e);
    };

    /**
     * Add all handlers to the window for triggering functions on the instance.
     */
    addEventListeners() {
        window.addEventListener('keydown', this.onKeyDown);
        window.addEventListener('keyup', this.onKeyUp);
        window.addEventListener('resize', this.onResize);

        /** MOBILE DEVICE EVENTS ****/
        if (window.DeviceOrientationEvent) {
            window.addEventListener('orientationchange', this.onOrientationChange);
        }

        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', this.onDeviceMotion);
        }
    }

    /**
     * Remove all handlers from the window and clean up any memory.
     */
    cleanup() {
        window.removeEventListener('keydown', this.onKeyDown);
        window.removeEventListener('keyup', this.onKeyUp);
        window.removeEventListener('resize', this.onResize);
        window.removeEventListener('orientationchange', this.onOrientationChange);
        window.removeEventListener('devicemotion', this.onDeviceMotion);
    }

    configure(options = {}) {
        this.onError = options.onError || undefined;
    }

    /**
     * Get all living elements.
     * @global
     * @returns {Array.&lt;Thing>}
     */
    getElements() {
        return this.elementPool.filter(element => element.alive);
    }

    /**
     * Add an element to the graphics instance.
     * @example
     * let circle = new Circle(20);
     * add(circle);
     *
     * @global
     * @param {Thing} elem - A subclass of Thing to be added to the graphics instance.
     */
    add(elem) {
        elem.alive = true;
        this.elementPool[this.elementPoolSize++] = elem;
        if (elem._sortInvalidated) {
            this._sortInvalidated = true;
        }
    }

    /**
     * Creates a hidden DOM element that can be navigated with a screen reader.
     * @private
     * @param {Thing} elem
     */
    createAccessibleDOMElement(elem) {
        const button = document.createElement('button');
        // https://webaim.org/techniques/css/invisiblecontent/
        button.style = this.userNavigatingWithKeyboard
            ? KEYBOARD_NAVIGATION_DOM_ELEMENT_STYLE
            : HIDDEN_KEYBOARD_NAVIGATION_DOM_ELEMENT_STYLE;

        button.id = HIDDEN_KEYBOARD_NAVIGATION_DOM_ELEMENT_ID(elem._id);

        button.onfocus = () => {
            elem.focus();
            button.textContent = elem.describe?.() ?? 'An unknown graphics element';
        };
        button.onblur = () => {
            elem.unfocus();
        };
        button.onkeydown = e => {
            if (e.code === 'Space' &amp;&amp; !e.repeat) {
                const event = new Event('mousedown');
                event.getX = () => elem.x;
                event.getY = () => elem.y;
                this.mouseDownCallback?.(event);
            }
        };
        button.onkeyup = e => {
            if (e.code === 'Space') {
                const event = new Event('mouseup');
                event.getX = () => elem.x;
                event.getY = () => elem.y;
                this.mouseUpCallback?.(event);
            }
        };
        document.body.appendChild(button);
        this.accessibleDOMElements.push(button);
        elem._hasAccessibleDOMElement = true;
    }

    /**
     * Exits keyboard navigation mode.
     * @private
     */
    exitKeyboardNavigation() {
        this.userNavigatingWithKeyboard = false;
        this.hideKeyboardNavigationDOMElements();
    }

    /**
     * Makes DOM elements designed to be navigated with keyboard visible so they can be tabbed.
     * @private
     */
    showKeyboardNavigationDOMElements() {
        this.accessibleDOMElements.forEach(
            element => (element.style = KEYBOARD_NAVIGATION_DOM_ELEMENT_STYLE)
        );
    }

    /**
     * Makes DOM elements designed to be navigated with keyboard invisible.
     * This is to make sure they don't accidentally appear and affect layout if they are not needed.
     * @private
     */
    hideKeyboardNavigationDOMElements() {
        this.accessibleDOMElements.forEach(
            element => (element.style = HIDDEN_KEYBOARD_NAVIGATION_DOM_ELEMENT_STYLE)
        );
    }

    /**
     * Record a click.
     * This will cause all timers to be postponed until a click event happens.
     * @deprecated
     * @global
     */
    waitForClick() {
        this.clickCount++;
    }

    /**
     * Assign a function as a callback for click (mouse down, mouse up) events.
     * @example
     * mouseClickMethod(e => {
     *   alert('You just clicked at ' + e.getX() + ', ' + e.getY());
     * });
     * @global
     * @param {function} fn - A callback to be triggered on click events.
     */
    mouseClickMethod(fn) {
        this.clickCallback = this.withErrorHandler(fn);
    }

    /**
     * Assign a function as a callback for mouse move events.
     * @example
     * mouseMoveMethod(e => {
     *   alert('You moved your mouse to ' + e.getX() + ', ' + e.getY());
     * });
     * @global
     * @param {function} fn - A callback to be triggered on mouse move events.
     */
    mouseMoveMethod(fn) {
        this.moveCallback = this.withErrorHandler(fn);
    }

    /**
     * Assign a function as a callback for mouse down events.
     * @example
     * mouseDownMethod(e => {
     *   alert('You depressed your mouse button at ' + e.getX() + ', ' + e.getY());
     * });
     * @global
     * @param {function} fn - A callback to be triggered on mouse down.
     */
    mouseDownMethod(fn) {
        this.mouseDownCallback = this.withErrorHandler(fn);
    }

    /**
     * Assign a function as a callback for mouse up events.
     * @example
     * mouseUpMethod(e => {
     *   alert('You lifted your mouse button at ' + e.getX() + ', ' + e.getY());
     * });
     * @global
     * @param {function} fn - A callback to be triggered on mouse up events.
     */
    mouseUpMethod(fn) {
        this.mouseUpCallback = this.withErrorHandler(fn);
    }

    /**
     * Assign a function as a callback for drag events.
     * @example
     * mouseDragMethod(e => {
     *   alert('You dragged your mouse to' + e.getX() + ', ' + e.getY());
     * });
     * @global
     * @param {function} fn - A callback to be triggered on drag events.
     */
    mouseDragMethod(fn) {
        this.dragCallback = this.withErrorHandler(fn);
    }

    /**
     * Assign a function as a callback for keydown events.
     * @example
     * keyDownMethod(e => {
     *     if (e.keyCode === Keyboard.letter('A')) {
     *         alert('You just pushed the a key!');
     *     }
     * })
     * @global
     * @param {function} fn - A callback to be triggered on keydown events.
     */
    keyDownMethod(fn) {
        this.keyDownCallback = this.withErrorHandler(fn);
    }

    /**
     * Assign a function as a callback for key up events.
     * @example
     * keyUpMethod(e => {
     *     if (e.keyCode === Keyboard.letter('A')) {
     *         alert('You just lifted the a key!');
     *     }
     * })
     * @global
     * @param {function} fn - A callback to be triggered on key up events.
     */
    keyUpMethod(fn) {
        this.keyUpCallback = this.withErrorHandler(fn);
    }

    /**
     * Assign a function as a callback for device orientation events.
     * @global
     * @param {function} fn - A callback to be triggered on device orientation
     *                        events.
     */
    deviceOrientationMethod(fn) {
        this.deviceOrientationCallback = this.withErrorHandler(fn);
    }

    /**
     * Assign a function as a callback for device motion events.
     * @global
     * @param {function} fn - A callback to be triggered device motion events.
     */
    deviceMotionMethod(fn) {
        this.deviceMotionCallback = this.withErrorHandler(fn);
    }

    /**
     * Check if a key is currently pressed
     * @example
     * if (isKeyPressed(Keyboard.letter('a'))) {
     *     alert('Youre currently pressing A!');
     * }
     * @global
     * @param {integer} keyCode - Key code of key being checked.
     * @returns {boolean} Whether or not that key is being pressed.
     */
    isKeyPressed(keyCode) {
        return pressedKeys.indexOf(keyCode) !== -1;
    }

    /**
     * Get the width of the entire graphics canvas.
     * @example
     * if (getWidth() > 200) {
     *     alert('The canvas is wider than 200 pixels!');
     * }
     * @global
     * @returns {float} The width of the canvas.
     */
    getWidth() {
        const canvas = this.getCanvas();
        return parseFloat(canvas.getAttribute('width') / this.devicePixelRatio);
    }

    /**
     * Get the height of the entire graphics canvas.
     * @example
     * if (getHeight() > 200) {
     *     alert('The canvas is taller than 200 pixels!');
     * }
     * @global
     * @returns {float} The height of the canvas.
     */
    getHeight() {
        const canvas = this.getCanvas();
        return parseFloat(canvas.getAttribute('height') / this.devicePixelRatio);
    }

    /**
     * Stop all timers.
     * @global
     */
    stopAllTimers() {
        for (let i = 1; i &lt; 99999; i++) {
            window.clearInterval(i);
        }
        super.stopAllTimers();
        this.setMainTimer();
    }

    /**
     * Create a new timer.
     * {@link Manager#setTimer}
     * @global
     * @param {function} fn - Function to be called at intervals.
     * @param {integer} time - Time interval to call function `fn`
     * @param {dictionary} data - Any data associated with the timer.
     * @param {string} name - Name of this timer.
     */
    setTimer(fn, time, data, name) {
        if (arguments.length &lt; 2) {
            throw new Error(
                '2 parameters required for `' +
                    'setTimer`, ' +
                    arguments.length +
                    ' found. You must ' +
                    'provide a callback function and ' +
                    'a number representing the time delay ' +
                    'to `setTimer`.'
            );
        }
        if (typeof fn !== 'function') {
            throw new TypeError(
                'Invalid callback function. ' +
                    'Make sure you are passing an actual function to ' +
                    '`setTimer`.'
            );
        }
        if (typeof time !== 'number' || !isFinite(time)) {
            throw new TypeError(
                'Invalid value for time delay. ' +
                    'Make sure you are passing a finite number to ' +
                    '`setTimer` for the delay.'
            );
        }

        if (this.waitingForClick()) {
            this.delayedTimers.push({
                fn: fn,
                time: time,
                data: data,
                clicks: this.clickCount,
                name: name,
            });
        } else {
            return super.setTimer(this.withErrorHandler(fn), time, data, name ?? fn.name);
        }
    }

    /**
     * Set the background color of the canvas.
     * @global
     * @param {Color} color - The desired color of the canvas.
     */
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }

    /**
     * Clear everything from the canvas.
     * @private
     */
    clear(context) {
        var ctx = context || this.getContext();
        ctx.clearRect(0, 0, this.getWidth(), this.getHeight());
    }

    /**
     * Get an element at a specific point.
     * If several elements are present at the position, return the one put there first.
     * @example
     * let circle = new Circle(20);
     * circle.setPosition(100, 100);
     * add(circle);
     *
     * getElementAt(100, 100) === circle;
     * @global
     * @param {number} x - The x coordinate of a point to get element at.
     * @param {number} y - The y coordinate of a point to get element at.
     * @returns {Thing|null} The object at the point (x, y), if there is one (else null).
     */
    getElementAt(x, y) {
        for (let i = this.elementPool.length; i--; ) {
            if (this.elementPool[i].alive &amp;&amp; this.elementPool[i].containsPoint(x, y)) {
                return this.elementPool[i];
            }
        }
        return null;
    }

    /**
     * Get all elements at a specific point.
     * @example
     * let circle = new Circle(20);
     * circle.setPosition(100, 100);
     * add(circle);
     *
     * let rectangle = new Rectangle(30, 30);
     * rectangle.setPosition(80, 80);
     * add(rectangle);
     *
     * getElementsAt(100, 100)[1] === rectangle;
     * @global
     * @param {number} x - The x coordinate of a point to get element at.
     * @param {number} y - The y coordinate of a point to get element at.
     * @returns {Array.&lt;Thing>} The objects at the point (x, y).
     */
    getElementsAt(x, y) {
        return this.elementPool.filter(e => {
            return e.alive &amp;&amp; e.containsPoint(x, y);
        });
    }

    /**
     * Check if an element exists with the given paramenters.
     * @global
     * @param {object} params - Dictionary of parameters for the object.
     *      Includes x, y, heigh, width, color, radius, label and type.
     * @returns {boolean}
     */
    elementExistsWithParameters(params) {
        for (let i = this.elementPool.length; i--; ) {
            const elem = this.elementPool[i];
            const checkedParams = Object.entries(params).map(([name, value]) => {
                return value === elem[name];
            });

            if (elem.alive &amp;&amp; checkedParams.every(param => param)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Remove all elements from the canvas.
     * @example
     * add(new Circle(10));
     * add(new Rectangle(30, 30));
     * removeAll();
     *
     * @global
     */
    removeAll() {
        this.stopAllVideo();
        this.elementPool = [];
        this.elementPoolSize = 0;
        this.accessibleDOMElements.forEach(node => node.remove());
        this.accessibleDOMElements = [];
    }

    /**
     * Remove a specific element from the canvas.
     * @global
     * @param {Thing} elem - The element to be removed from the canvas.
     */
    remove(elem) {
        if (!(elem instanceof Thing)) {
            return;
        }

        if (elem instanceof WebVideo) {
            elem.stop();
        }
        elem.alive = false;
        // mark the element as having invalidated sort, so in the case that it's
        // add()ed later, a re-sort will happen and trigger an update in the pool size
        elem._sortInvalidated = true;
        if (elem._hasAccessibleDOMElement) {
            const focusButtonID = HIDDEN_KEYBOARD_NAVIGATION_DOM_ELEMENT_ID(elem._id);
            document.getElementById(focusButtonID)?.remove();
            elem._hasAccessibleDOMElement = false;
        }
    }

    /**
     * Resizes the canvas, creating a temporary canvas to prevent flickering and
     * perform size adjustments based on the devices's devicePixelRatio.
     * @private
     * @param {number} w
     * @param {number} h
     */
    _resize(w, h) {
        w = Math.floor(w);
        h = Math.floor(h);
        const canvas = this.getCanvas();
        // prevent flickering effect by saving the canvas and immediately drawing back.
        // this will be cleared in redraw(), but it prevents a jarring
        // flickering effect.
        const temporaryCanvas = document.createElement('canvas');
        temporaryCanvas.width = canvas.width;
        temporaryCanvas.height = canvas.height;
        temporaryCanvas.style.width = `${canvas.width / this.devicePixelRatio}px`;
        temporaryCanvas.style.height = `${canvas.height / this.devicePixelRatio}px`;
        const temporaryContext = temporaryCanvas.getContext('2d');
        temporaryContext.drawImage(canvas, 0, 0);

        canvas.width = w * this.devicePixelRatio;
        canvas.height = h * this.devicePixelRatio;
        canvas.style.width = `${w}px`;
        canvas.style.height = `${h}px`;
        const context = this.getContext();
        context.drawImage(temporaryCanvas, 0, 0);
        context.scale(this.devicePixelRatio, this.devicePixelRatio);
        temporaryCanvas.remove();
    }

    /**
     * Set the size of the canvas.
     * @global
     * @param {number} w - Desired width of the canvas.
     * @param {number} h - Desired height of the canvas.
     */
    setSize(w, h) {
        this.fullscreenMode = false;
        this._resize(w, h);
    }

    /**
     * Set the canvas to take up the entire parent element
     * @global
     */
    setFullscreen() {
        this.fullscreenMode = true; // when this is true, canvas will resize with parent
        const canvas = this.getCanvas();
        const width = canvas.parentElement.offsetWidth - FULLSCREEN_PADDING;
        const height = canvas.parentElement.offsetHeight - FULLSCREEN_PADDING;
        this._resize(width, height);
    }

    /**
     * Resets all the timers to time 0.
     * @global
     */
    resetAllTimers() {
        for (var cur in this.timers) {
            clearInterval(this.timers[cur]);
        }
    }

    /**
     * Stop all video elements.
     * @private
     */
    stopAllVideo() {
        for (var i = this.elementPool.length; i--; ) {
            if (this.elementPool[i] instanceof WebVideo) {
                this.elementPool[i].stop();
            }
        }
    }

    /**
     * Resets the graphics instance to a clean slate.
     * @private
     */
    resetAllState() {
        this.backgroundColor = null;
        this.removeAll();
        this.clickCallback = null;
        this.moveCallback = null;
        this.mouseDownCallback = null;
        this.mouseUpCallback = null;
        this.dragCallback = null;
        this.keyDownCallback = null;
        this.keyUpCallback = null;
        this.deviceOrientationCallback = null;
        this.deviceMotionCallback = null;

        // A fast hash from timer key to timer interval #
        this.timers = {};

        // A useful list to store information about all timers.
        this.timersList = [];

        this.clickCount = 0;
        this.delayedTimers = [];

        this.fullscreenMode = false;
    }

    /**
     * Reset all timers to 0 and clear timers and canvas.
     * @private
     */
    fullReset() {
        this.stopAllVideo();
        this.resetAllTimers();
        this.resetAllState();
        this.setMainTimer();
    }

    /**
     * Return if the graphics canvas exists.
     * @private
     * @returns {boolean} Whether or not the canvas exists.
     */
    canvasExists() {
        return this.getCanvas() !== null;
    }

    /**
     * Return the current canvas we are using. If there is no
     * canvas on the page this will return null.
     * @returns {HTMLCanvasElement} The current canvas.
     */
    getCanvas() {
        return this.currentCanvas;
    }

    /**
     * Set the current canvas we are working with. If no canvas
     * tag matches the selectorv then we will just have the current
     * canvas set to null.
     * @param {string} canvasSelector - String representing canvas class or ID.
     *      Selected with jQuery.
     */
    setCurrentCanvas(canvasSelector) {
        let currentCanvas;
        if (canvasSelector) {
            currentCanvas = document.querySelector(canvasSelector);
        } else {
            currentCanvas = document.getElementsByTagName('canvas')[0];
        }
        if (!currentCanvas) {
            currentCanvas = document.createElement('canvas');
            currentCanvas.width = 400;
            currentCanvas.height = 400;
            document.body.appendChild(currentCanvas);
        }
        this.currentCanvas = currentCanvas;
        this.setSize(currentCanvas.width, currentCanvas.height);

        // On changing the canvas reset the state.
        this.fullReset();
        this.setup();
    }

    /**
     * Draw the background color for the current object.
     * @private
     */
    drawBackground() {
        if (this.backgroundColor) {
            var context = this.getContext();
            context.fillStyle = this.backgroundColor;
            context.beginPath();
            context.rect(0, 0, this.getWidth(), this.getHeight());
            context.closePath();
            context.fill();
        }
    }

    /**
     * Return the 2D graphics context for this graphics
     * object, or null if none exists.
     * @returns {CanvasRenderingContext2D} The 2D graphics context.
     */
    getContext() {
        return this.getCanvas()?.getContext?.('2d');
    }

    /**
     * Return the RGBA value of the pixel at the x, y coordinate.
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @returns {Array&lt;number>} pixel - the [r, g, b, a] values for the pixel.
     */
    getPixel(x, y) {
        const context = this.getContext();
        x *= this.devicePixelRatio;
        y *= this.devicePixelRatio;
        const pixelData = context.getImageData(x, y, 1, 1).data;
        const index = 0;
        return [
            pixelData[index + 0],
            pixelData[index + 1],
            pixelData[index + 2],
            pixelData[index + 3],
        ];
    }

    /**
     * Sort the element pool, putting all elements with .alive=false at the end and
     * all elements with lower layer before elements with higher layer.
     * @private
     */
    sortElementPool() {
        this.elementPool.sort((a, b) => b.alive - a.alive || a.layer - b.layer);
        let lastAliveElementIndex = -1;
        for (let i = this.elementPool.length - 1; i >= 0; i--) {
            if (this.elementPool[i].alive) {
                lastAliveElementIndex = i;
                break;
            }
        }
        this.elementPoolSize = lastAliveElementIndex + 1;
        this._sortInvalidated = false;
    }

    /**
     * Redraw this graphics canvas.
     * @private
     */
    redraw() {
        this.clear();
        this.drawBackground();
        let elem;
        let sortPool = this._sortInvalidated;
        for (let i = 0; i &lt; this.elementPoolSize; i++) {
            elem = this.elementPool[i];
            // the pool needs to be resorted if:
            // - the graphics manager has an invalid sort (as a result of adding a new element),
            // - if an element has an invalid sort (as a result of having its layer changed),
            // - or if an element has been removed, which will be true if .alive is false and it
            //   is within the elementPool &lt; elementPoolSize
            sortPool = sortPool || elem._sortInvalidated || !elem.alive;
            // mark the element as having valid sort, even though it has not yet been sorted.
            // it will be sorted immediately after in sortElementPool
            elem._sortInvalidated = false;
        }
        if (sortPool) {
            this.sortElementPool();
        }
        const context = this.getContext();
        for (let i = 0; i &lt; this.elementPoolSize; i++) {
            elem = this.elementPool[i];
            elem.draw(context);
        }
    }

    /**
     * Set the main timer for graphics.
     * @private
     */
    setMainTimer() {
        this.shouldUpdate = true;
        this.update();
    }

    /**
     * The main update loop for the Graphics manager.
     * @private
     */
    update() {
        if (this.shouldUpdate) {
            requestAnimationFrame(this.update.bind(this));
        }
        this.now = Date.now();
        const elapsed = this.now - this.lastDrawTime;
        if (elapsed > this.fpsInterval) {
            this.lastDrawTime = this.now - (elapsed % this.fpsInterval);
            this.redraw();
        }
    }

    /**
     * Whether the graphics instance is waiting for a click.
     * @returns {boolean} Whether or not the instance is waiting for a click.
     */
    waitingForClick() {
        return this.clickCount !== 0;
    }

    /**
     * Whether the selected canvas already has an instance associated.
     * @private
     */
    canvasHasInstance(canvas) {
        let instance;
        for (let i = 0; i &lt; allGraphicsInstances.length; i++) {
            instance = allGraphicsInstances[i];
            if (instance.instanceId !== this.instanceId &amp;&amp; instance.getCanvas() === canvas) {
                return instance.instanceId;
            }
        }
        return null;
    }

    /**
     * Set up the graphics instance to prepare for interaction
     * @private
     */
    setup() {
        var drawingCanvas = this.getCanvas();

        drawingCanvas.onclick = e => {
            if (this.waitingForClick()) {
                this.clickCount--;

                for (var i = 0; i &lt; this.delayedTimers.length; i++) {
                    var timer = this.delayedTimers[i];
                    timer.clicks--;
                    if (timer.clicks === 0) {
                        this.setTimer(this.withErrorHandler(timer.fn), timer.time, timer.data);
                    }
                }
                return;
            }

            if (this.clickCallback) {
                this.clickCallback(e);
            }
        };

        var mouseDown = false;

        drawingCanvas.onmousemove = this.withErrorHandler(e => {
            if (this.userNavigatingWithKeyboard) {
                this.exitKeyboardNavigation();
            }
            if (this.moveCallback) {
                this.moveCallback(e);
            }
            if (mouseDown &amp;&amp; this.dragCallback) {
                this.dragCallback(e);
            }
        });

        drawingCanvas.onmousedown = e => {
            if (this.userNavigatingWithKeyboard) {
                this.exitKeyboardNavigation();
            }
            mouseDown = true;
            if (this.mouseDownCallback) {
                this.mouseDownCallback(e);
            }
        };

        drawingCanvas.onmouseup = e => {
            if (this.userNavigatingWithKeyboard) {
                this.exitKeyboardNavigation();
            }
            mouseDown = false;
            if (this.mouseUpCallback) {
                this.mouseUpCallback(e);
            }
        };

        drawingCanvas.ontouchmove = e => {
            if (this.userNavigatingWithKeyboard) {
                this.exitKeyboardNavigation();
            }
            e.preventDefault();
            if (this.dragCallback) {
                this.dragCallback(e);
            } else if (this.moveCallback) {
                this.moveCallback(e);
            }
        };

        drawingCanvas.ontouchstart = e => {
            if (this.userNavigatingWithKeyboard) {
                this.exitKeyboardNavigation();
            }
            e.preventDefault();
            if (this.mouseDownCallback) {
                this.mouseDownCallback(e);
            } else if (this.clickCallback) {
                this.clickCallback(e);
            }

            if (this.waitingForClick()) {
                this.clickCount--;

                for (var i = 0; i &lt; this.delayedTimers.length; i++) {
                    var timer = this.delayedTimers[i];
                    timer.clicks--;
                    if (timer.clicks === 0) {
                        this.setTimer(timer.fn, timer.time, timer.data);
                    }
                }
                return;
            }
        };

        drawingCanvas.ontouchend = e => {
            if (this.userNavigatingWithKeyboard) {
                this.exitKeyboardNavigation();
            }
            e.preventDefault();
            if (this.mouseUpCallback) {
                this.mouseUpCallback(e);
            }
        };
    }
}

/* Mouse and Touch Event Helpers */
const calculateCoordinates = e => {
    const canvas = e.target;
    const rect = canvas.getBoundingClientRect();
    return {
        x: Math.round(e.clientX - rect.left),
        y: Math.round(e.clientY - rect.top),
    };
};

MouseEvent.prototype.getX = function () {
    return calculateCoordinates(this).x;
};

MouseEvent.prototype.getY = function () {
    return calculateCoordinates(this).y;
};

if (typeof TouchEvent !== 'undefined') {
    TouchEvent.prototype.getX = function () {
        return (this.touches.length &amp;&amp; calculateCoordinates(this.touches[0]).x) || null;
    };

    TouchEvent.prototype.getY = function () {
        return (this.touches.length &amp;&amp; calculateCoordinates(this.touches[0]).y) || null;
    };
}

export default GraphicsManager;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Tue Apr 12 2022 23:49:33 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
